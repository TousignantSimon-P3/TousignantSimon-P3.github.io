{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Programmation 3 (420-4A6-VI) - Hiver 2026","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Vous trouverez ici les notes et exercices du cours. J'ajouterai du nouveau contenu continuellement.</p> <p>Pr\u00e9alable \u00e0 ce cours : 420-2A6-VI : Programmation 2 </p> <p>Ce cours est pr\u00e9alable \u00e0 : 420-5B5-VI Projet int\u00e9grateur 1 Cheminement complet: https://informatique.apical.xyz/</p>"},{"location":"#environnement-de-travail","title":"Environnement de travail","text":"<p>Pour le cours vous avez deux logiciels \u00e0 installer:</p> <ul> <li>WSL (Windows subsystem for linux)</li> <li>Un \u00e9diteur de texte \u00e9volu\u00e9 tel notepad++ (recommand\u00e9) </li> <li>Codeblock</li> <li>Git</li> </ul>"},{"location":"#wsl","title":"WSL","text":"<p>Vous devez installer git et build-essential dans l'environnement linux. Les paquets tels que, mais non limit\u00e9s \u00e0, gemini, claude, chatgpt sont proscrit. \u2003</p>"},{"location":"#notepad-ou-autre-editeur-compatible","title":"Notepad++ (ou autre \u00e9diteur compatible)","text":"<p>Parfois git vous demande de faire l'\u00e9ditions de fichiers tel que les commentaires pour les soumissions. (git commit). Il arrive \u00e9galement que des conflits soient pr\u00e9sent. Le logiciels permet de mieux travailler dans ces situations plus complexe.</p>"},{"location":"#git","title":"Git","text":"<p>Installation normale, portez attention \u00e0 l'\u00e9diteur par d\u00e9faut. Autrement, vous allez vous retrouver avec vim pour \u00e9diter vos fichiers</p> <p>Votre identit\u00e9 : dans WSL vous \u00eates dans un environnement \"nouveau\" donc git va vous demander votre identit\u00e9. Utilisez votre courriel coll\u00e8ge comme configuration de courriel globale : @etudiant.cegepvicto.ca  Pour votre nom vous pouvez r\u00e9utiliser votre num\u00e9ro de DA  </p> <pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"[DA]@etudiant.cegepvicto.ca\"\n  git config --global user.name \"Votre nom\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n</code></pre>"},{"location":"#regles-de-classes-et-explications","title":"R\u00e8gles de classes et explications :","text":"<p>Petit rappel des r\u00e8gles au niveau de la P.D.E.A</p>"},{"location":"#conditions-pedagogiques-particulieres","title":"Conditions p\u00e9dagogiques particuli\u00e8res","text":"<p>Utilisation de g\u00e9n\u00e9rateur automatique :  </p> <p>Dans le cadre des activit\u00e9s acad\u00e9miques du cours, l'utilisation de g\u00e9n\u00e9rateurs de code automatiques, d'assistants d'IA tels que ChatGPT, Copilot ou tout autre outil similaire permettant la cr\u00e9ation automatique de contenu, la g\u00e9n\u00e9ration de code ou l\u2019assistance \u00e0 la r\u00e9solution d'exercices, est formellement interdite. Toute utilisation de ces outils durant un cours entra\u00eenera l'exclusion imm\u00e9diate de l'\u00e9l\u00e8ve de la p\u00e9riode concern\u00e9e.  </p>"},{"location":"#utilisation-des-cellulaires-ou-dappareils-mobiles-en-classe","title":"Utilisation des cellulaires ou d'appareils mobiles en classe","text":"<p>Toute utilisation d'appareil mobile tel que cellulaire, tablette ou console de jeux mobile est proscrite pendant le bloc horaire \u00e0 l'int\u00e9rieur du local. (Pr\u00e9cision : pauses incluses.) L'utilisation de tels appareils doit imp\u00e9rativement se faire hors du local afin de favoriser le climat d'apprentissage.  </p> <p>Les manquements aux articles pr\u00e9c\u00e9dents seront consign\u00e9s. Apr\u00e8s trois (3) exclusions, des d\u00e9marches administratives seront entreprises avec l'API afin de d\u00e9terminer les modalit\u00e9s de cheminement.</p>"},{"location":"#environnement-numerique-dapprentissage-plateforme","title":"Environnement num\u00e9rique d\u2019apprentissage (plateforme)","text":"<ul> <li>Team</li> <li>Github</li> <li>Github classroom</li> </ul> <p>L'\u00e9l\u00e8ve a la responsabilit\u00e9 d'avoir un compte github avec un nom d'utilisateur r\u00e9pondant \u00e0 la norme suivante :</p> <p>cgpvicto-[son num\u00e9ro de DA]</p> <p>exemple : cgpvicto-9999999</p> <p>Une fois le compte github cr\u00e9\u00e9. On doit rejoindre le github classroom correspondant \u00e0 son groupe, proc\u00e9dure qui sera donn\u00e9e en classe lors des premi\u00e8res semaines</p>"},{"location":"conventions/","title":"Normes et Conventions de Code C++","text":"<p>Standard du Cours</p> <p>Ce cours utilise officiellement le standard C++20. Tous les exemples et exercices doivent \u00eatre compil\u00e9s avec un compilateur compatible.</p> <p>Ce document d\u00e9finit les standards de programmation attendus pour tous les travaux pratiques et examens. L'objectif est de produire un code lisible, maintenable et proche des standards industriels modernes.</p>"},{"location":"conventions/#1-structure-du-code-et-nommage","title":"1. Structure du Code et Nommage","text":""},{"location":"conventions/#11-nommage-naming-convention","title":"1.1. Nommage (Naming Convention)","text":"<p>Nous adoptons le style de la Biblioth\u00e8que Standard C++ (STL).</p> \u00c9l\u00e9ment Format Exemple Variables <code>snake_case</code> <code>nombre_etudiants</code>, <code>index_courant</code> Fonctions <code>snake_case</code> <code>calculer_moyenne()</code>, <code>sauvegarder_fichier()</code> Classes / Structs <code>PascalCase</code> <code>Etudiant</code>, <code>GestionnaireFichier</code> Constantes <code>SCREAMING_SNAKE</code> <code>MAX_BUFFER_SIZE</code>, <code>PI</code>"},{"location":"conventions/#12-initialisation-uniforme-avec-les-accolades","title":"1.2. Initialisation Uniforme avec les Accolades <code>{}</code>","text":"<p>R\u00e8gle : Pour initialiser toute variable, utilisez toujours la syntaxe avec accolades <code>{}</code> (Uniform Initialization).</p> <p>Pourquoi ? - S\u00e9curit\u00e9 : Emp\u00eache les conversions de type risqu\u00e9es (ex: <code>int x {5.5};</code> g\u00e9n\u00e8re une erreur de compilation). - Uniformit\u00e9 : La m\u00eame syntaxe fonctionne pour tout (variables simples, tableaux, objets). - Garantie Z\u00e9ro : Une initialisation avec des accolades vides (<code>int x {};</code>) garantit que la variable vaut z\u00e9ro (ou son \u00e9quivalent), pr\u00e9venant les bogues de variables non-initialis\u00e9es.</p>"},{"location":"conventions/#2-structure-et-complexite","title":"2. Structure et Complexit\u00e9","text":""},{"location":"conventions/#21-regle-des-3-niveaux","title":"2.1. R\u00e8gle des 3 niveaux","text":"<p>L'imbrication (nesting) ne doit jamais d\u00e9passer 3 niveaux de profondeur.</p>"},{"location":"conventions/#22-clause-de-garde-guard-clause","title":"2.2. Clause de Garde (Guard Clause)","text":"<p>Privil\u00e9giez toujours le retour anticip\u00e9 (Early Return) pour r\u00e9duire la complexit\u00e9.</p>"},{"location":"conventions/#3-bonnes-pratiques-fichiers-et-performance","title":"3. Bonnes pratiques : Fichiers et Performance","text":""},{"location":"conventions/#31-organisation-une-classe-par-fichier","title":"3.1. Organisation : Une Classe par Fichier","text":"<p>Chaque <code>class</code> ou <code>struct</code> doit \u00eatre d\u00e9finie dans son propre couple de fichiers (<code>.hpp</code> et <code>.cpp</code>).</p>"},{"location":"conventions/#32-fichiers-den-tete-et-pragma-once","title":"3.2. Fichiers d'en-t\u00eate et <code>#pragma once</code>","text":"<p>Tout fichier <code>.hpp</code> doit commencer imp\u00e9rativement par <code>#pragma once</code>.</p>"},{"location":"conventions/#33-le-const-et-le-passage-par-reference","title":"3.3. Le <code>const</code> et le passage par r\u00e9f\u00e9rence","text":"<p>Pour les types complexes (<code>string</code>, <code>vector</code>, etc.), utilisez <code>const type&amp;</code> en param\u00e8tre pour \u00e9viter des copies inutiles.</p>"},{"location":"conventions/#4-documentation-du-code-doxygen","title":"4. Documentation du Code (Doxygen)","text":"<p>Le standard est Doxygen. La documentation se place toujours dans les fichiers <code>.hpp</code>.</p> <ul> <li>Classes/Structs : Doivent avoir un bloc <code>/** ... */</code> avec au minimum <code>@brief</code>.</li> <li>M\u00e9thodes : Doivent avoir un bloc <code>///</code> avec <code>@brief</code>, <code>@param</code> et <code>@return</code> si applicable.</li> </ul>"},{"location":"conventions/#5-exemple-complet-dapplication","title":"5. Exemple Complet d'Application","text":"<p>T\u00e9l\u00e9charger l'exemple complet (ZIP)</p> <p>Voici un exemple concret qui rassemble tous les standards.</p>"},{"location":"conventions/#51-structure-des-fichiers","title":"5.1. Structure des fichiers","text":"<pre><code>/exemple_commande\n|-- Article.hpp\n|-- Commande.cpp\n|-- Commande.hpp\n|-- main.cpp\n|-- ServiceConnexion.cpp\n`-- ServiceConnexion.hpp\n</code></pre>"},{"location":"conventions/#52-fichiers-den-tete-et-source","title":"5.2. Fichiers d'en-t\u00eate et Source","text":"Fichier : <code>main.cpp</code> <pre><code>#include &lt;iostream&gt;\n#include \"Commande.hpp\"\n\nint main() {\n    ServiceConnexion service_connexion {};\n    Article article_disponible {\"Stylo\", 10};\n    Article article_indisponible {\"Cahier\", 0};\n\n    std::cout &lt;&lt; \"--- Debut des tests de scenarios ---\\\\n\" &lt;&lt; std::endl;\n\n    // Sc\u00e9nario 1 : Commande valide\n    Commande cmd_valide {101};\n    cmd_valide.ajouter_article(article_disponible);\n    cmd_valide.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 2 : Article en rupture de stock\n    Commande cmd_stock_epuise {102};\n    cmd_stock_epuise.ajouter_article(article_disponible);\n    cmd_stock_epuise.ajouter_article(article_indisponible);\n    cmd_stock_epuise.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 3 : Commande invalide (vide)\n    Commande cmd_vide {103};\n    cmd_vide.traiter_commande(service_connexion);\n\n    std::cout &lt;&lt; \"\\n--- Fin des tests ---\\\\n\";\n\n    return 0;\n}\n</code></pre> <p>(Le code des autres fichiers <code>Article.hpp</code>, <code>Commande.hpp</code>, etc. est omis pour la lisibilit\u00e9, mais est inclus dans le ZIP t\u00e9l\u00e9chargeable.)</p>"},{"location":"conventions/#53-compilation-et-resultat","title":"5.3. Compilation et R\u00e9sultat","text":"<p>Pour compiler et ex\u00e9cuter cet exemple : <pre><code>g++ -std=c++20 -Wall -o exemple_commande/exemple exemple_commande/main.cpp exemple_commande/Commande.cpp exemple_commande/ServiceConnexion.cpp\n./exemple_commande/exemple\n</code></pre></p> <p>Le r\u00e9sultat attendu est : <pre><code>--- Debut des tests de scenarios ---\n\nSUCCES : La commande 101 a ete envoyee.\nERREUR (Cmd 102): Un ou plusieurs articles en rupture de stock.\nERREUR (Cmd 103): Commande invalide ou vide.\n\n--- Fin des tests ---\n</code></pre></p>"},{"location":"horaire/","title":"Horaire du cours","text":"<p>Planification de la session Hiver 2026.</p> <p>Remarque importante</p> <p>Les dates de remises sont indiqu\u00e9es par le drapeau \ud83d\udea9. Assurez-vous de v\u00e9rifier cette colonne r\u00e9guli\u00e8rement.</p>"},{"location":"horaire/#partie-1-avant-la-relache","title":"Partie 1 : Avant la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 1 Cours 01 19-01-2026 08:15 Pr\u00e9sentation du plan de cours Cours 02 21-01-2026 13:15 Semaine 2 Cours 03 26-01-2026 08:15 Cours 04 29-01-2026 13:15 Semaine 3 Cours 05 02-02-2026 08:15 Cours 06 05-02-2026 13:15 Semaine 4 Cours 07 09-02-2026 08:15 Cours 08 12-02-2026 13:15 Semaine 5 Cours 09 16-02-2026 08:15 Cours 10 19-02-2026 13:15 Semaine 6 Cours 11 23-02-2026 08:15 Cours 12 26-02-2026 13:15 {: .horaire } <p>\ud83c\udf34 SEMAINE DE REL\u00c2CHE : Du 2 au 6 mars 2026</p> <p>Aucun cours.</p>"},{"location":"horaire/#partie-2-apres-la-relache","title":"Partie 2 : Apr\u00e8s la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 7 Cours 13 09-03-2026 08:15 Cours 14 12-03-2026 13:15 Semaine 8 Cours 15 16-03-2026 08:15 Cours 16 19-03-2026 13:15 Semaine 9 Cours 17 23-03-2026 08:15 Cours 18 26-03-2026 13:15 Semaine 10 Cours 19 30-03-2026 08:15 Cours 20 02-04-2026 13:15 Prochaine rencontre dans 1 sem. Semaine 11 Cours 21 09-04-2026 13:15 Cours 22 13-04-2026 08:15 Semaine 12 Cours 23 16-04-2026 13:15 Cours 24 20-04-2026 08:15 Semaine 13 Cours 25 27-04-2026 08:15 Cours 26 30-04-2026 13:15 Semaine 14 Cours 27 04-05-2026 08:15 Cours 28 07-05-2026 13:15 Semaine 15 Cours 29 11-05-2026 08:15 Cours 30 14-05-2026 13:15 {: .horaire }"},{"location":"ressources/","title":"Ressources","text":""},{"location":"ressources/#documentation-officielle","title":"Documentation officielle","text":"<p>C# documentation officielle : https://learn.microsoft.com/fr-ca/dotnet/csharp/tour-of-csharp/</p> <p>.Net 8.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-8.0</p> <p>.Net 9.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-9.0</p> <p>Tests unitaires MSTest : https://learn.microsoft.com/fr-ca/dotnet/core/testing/unit-testing-with-mstest </p> <p>Table ASCII : https://www.asciitable.com/</p>"},{"location":"exercices/exercice_semaine_1_1/","title":"Exercices de la Semaine 1 : Les Bases","text":"<p>Ces exercices sont con\u00e7us pour pratiquer les concepts de base vus dans les notes de la semaine 1. Concentrez-vous sur la ma\u00eetrise de la compilation, de l'affichage, de la saisie et des fonctions simples.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-1-affichage-et-saisie-simple","title":"Bloc 1 : Affichage et Saisie Simple","text":"<p>Exercice 1 : Bonjour le Monde - Objectif : Cr\u00e9er un programme C++ de base. - T\u00e2che : \u00c9crivez un programme qui affiche \"Bonjour le monde !\" dans la console et qui se termine en retournant <code>0</code>.</p> <p>Exercice 2 : Fiche de Pr\u00e9sentation - Objectif : Manipuler <code>std::cout</code> avec plusieurs lignes. - T\u00e2che : \u00c9crivez un programme qui affiche votre nom, votre ville et votre \u00e2ge sur des lignes s\u00e9par\u00e9es.</p> <p>Exercice 3 : D\u00e9claration de Variables - Objectif : Se familiariser avec l'initialisation uniforme. - T\u00e2che : D\u00e9clarez quatre variables en utilisant la syntaxe d'accolades <code>{}</code> : un <code>int</code>, un <code>double</code>, un <code>char</code>, et un <code>bool</code>. Assignez-leur des valeurs de votre choix et affichez chaque valeur avec une description.</p> <p>Exercice 4 : Interaction Simple - Objectif : Utiliser <code>std::cin &gt;&gt;</code> avec <code>std::string</code> et <code>int</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur son pr\u00e9nom et son ann\u00e9e de naissance. Calculez (approximativement) son \u00e2ge et affichez un message comme <code>\"Bonjour [Pr\u00e9nom], vous avez environ [Age] ans.\"</code>.</p> <p>Exercice 5 : Calcul d'Aire - Objectif : Utiliser des types <code>double</code> avec <code>std::cin</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur la largeur et la hauteur d'un rectangle. Calculez et affichez son aire.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-2-gestion-du-buffer-et-erreurs-de-saisie","title":"Bloc 2 : Gestion du Buffer et Erreurs de Saisie","text":"<p>Exercice 6 : Le Pi\u00e8ge de <code>getline</code> - Objectif : R\u00e9soudre le conflit entre <code>std::cin &gt;&gt;</code> et <code>std::getline</code>. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur son num\u00e9ro de porte (un <code>int</code>).   2. Demandez-lui ensuite son nom de rue complet (un <code>std::string</code> avec <code>getline</code>).   3. Observez que le programme ignore la saisie de la rue.   4. Corrigez le probl\u00e8me en nettoyant le buffer apr\u00e8s la lecture du nombre.</p> <p>Exercice 7 : Gestion d'Erreur Simple - Objectif : Utiliser <code>std::cin.fail()</code> pour d\u00e9tecter une erreur. - T\u00e2che : Demandez \u00e0 l'utilisateur d'entrer un nombre. Si la saisie \u00e9choue (si l'utilisateur tape du texte), affichez \"Erreur : saisie invalide.\". Sinon, affichez \"Merci !\".</p> <p>Exercice 8 : Boucle de Saisie Robuste - Objectif : Cr\u00e9er une boucle qui force une saisie num\u00e9rique valide. - T\u00e2che : Cr\u00e9ez une boucle <code>while</code> qui continue de demander \"Entrez votre age :\" jusqu'\u00e0 ce que l'utilisateur entre un nombre entier valide. Si l'utilisateur se trompe, le programme doit afficher une erreur et lui redemander.</p> <p>Exercice 9 : Analyse d'Entr\u00e9e Mixte - Objectif : Comprendre comment <code>cin</code> g\u00e8re les lectures partielles. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur un nombre. L'utilisateur doit taper <code>45abc</code>.   2. Lisez la saisie dans une variable de type <code>int</code>.   3. Affichez l'entier que vous avez r\u00e9ussi \u00e0 lire.   4. Ensuite, lisez le reste du buffer dans une variable <code>std::string</code>.   5. Affichez la cha\u00eene de caract\u00e8res. Le r\u00e9sultat devrait vous montrer ce qui restait dans le buffer.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-3-fonctions-et-tableaux","title":"Bloc 3 : Fonctions et Tableaux","text":"<p>Exercice 10 : Calculatrice Simple - Objectif : \u00c9crire et appeler des fonctions simples. - T\u00e2che : \u00c9crivez quatre fonctions : <code>addition(int a, int b)</code>, <code>soustraction(int a, int b)</code>, <code>multiplication(int a, int b)</code>, et <code>division(int a, int b)</code>. Chaque fonction doit retourner le r\u00e9sultat du calcul. Dans <code>main</code>, testez chaque fonction avec des valeurs de votre choix et affichez les r\u00e9sultats.</p> <p>Exercice 11 : Passage par Copie - Objectif : Constater l'effet d'un passage par copie. - T\u00e2che :   1. \u00c9crivez une fonction <code>ajouter_vingt(int nombre)</code> qui re\u00e7oit un entier, lui ajoute 20, et n'a pas de <code>return</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {10}</code>.   3. Appelez <code>ajouter_vingt(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 12 : Passage par R\u00e9f\u00e9rence - Objectif : Utiliser une r\u00e9f\u00e9rence pour modifier une variable externe. - T\u00e2che :   1. \u00c9crivez une fonction <code>reinitialiser(int&amp; nombre)</code> qui change la valeur de l'entier re\u00e7u \u00e0 <code>0</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {123}</code>.   3. Appelez <code>reinitialiser(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 13 : Somme d'un Tableau - Objectif : Passer un tableau \u00e0 une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>calculer_somme(const int tableau[], int taille)</code> qui retourne la somme de tous les \u00e9l\u00e9ments d'un tableau. Dans <code>main</code>, initialisez un tableau (ex: <code>int tableau[] {10, 20, 30};</code>), trouvez sa taille avec <code>std::ssize</code>, et affichez la somme retourn\u00e9e par votre fonction.</p> <p>Exercice 14 : Trouver le Maximum - Objectif : Parcourir un tableau dans une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>trouver_max(const int tableau[], int taille)</code> qui retourne la plus grande valeur d'un tableau. Testez-la dans <code>main</code>.</p> <p>Exercice 15 : Inversion de Tableau - Objectif : Modifier un tableau via une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau sur place (le premier devient le dernier, etc.). Dans <code>main</code>, d\u00e9clarez un tableau comme <code>int tableau[] {1, 2, 3, 4, 5};</code>, affichez-le, appelez la fonction, puis affichez-le \u00e0 nouveau pour voir le changement.</p>"},{"location":"notes/semaine_1/","title":"Notes de la Semaine 1","text":""},{"location":"notes/semaine_1/#sujets-abordes","title":"Sujets Abord\u00e9s","text":"<ul> <li>Pr\u00e9sentation du cours</li> <li>Environnement de d\u00e9veloppement C++ (IDE, compilateur)</li> <li>Concepts de base du C++ (variables, types, op\u00e9rateurs)</li> </ul>"},{"location":"notes/semaine_1/#exercices-et-laboratoires","title":"Exercices et Laboratoires","text":"<ul> <li>Configuration de l'environnement</li> <li>Premiers programmes \"Hello World\"</li> </ul>"},{"location":"notes/semaine_1/#remarques","title":"Remarques","text":"<ul> <li>Assurez-vous que votre environnement de d\u00e9veloppement est fonctionnel avant le prochain cours.</li> <li>Consultez le plan de cours pour les lectures et pr\u00e9parations.</li> </ul>"},{"location":"notes/semaine_1/#la-fonction-main-en-c","title":"La fonction <code>main()</code> en C++","text":"<p>La fonction <code>main()</code> est le point d'entr\u00e9e de chaque programme C++. C'est l\u00e0 que l'ex\u00e9cution de votre code commence.</p>"},{"location":"notes/semaine_1/#main-sans-arguments","title":"<code>main()</code> sans arguments","text":"<p>La forme la plus simple de <code>main()</code> ne prend pas d'arguments. <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Bonjour !\" &lt;&lt; std::endl;\n    return 0; // Indique que le programme s'est ex\u00e9cut\u00e9 avec succ\u00e8s\n}\n</code></pre></p>"},{"location":"notes/semaine_1/#return-int-vs-void-main-c","title":"<code>return int</code> vs <code>void Main</code> (C#)","text":"<p>Contrairement \u00e0 C# o\u00f9 la fonction <code>Main</code> peut \u00eatre <code>void</code>, la fonction <code>main()</code> en C++ doit retourner un <code>int</code>.</p> <ul> <li><code>return 0;</code> : Conventionnellement, un retour de <code>0</code> indique que le programme s'est termin\u00e9 avec succ\u00e8s.</li> <li><code>return un_nombre_non_nul;</code> : Un retour diff\u00e9rent de <code>0</code> (ex: <code>1</code>) indique qu'une erreur s'est produite. Ce code peut \u00eatre utilis\u00e9 par d'autres programmes ou scripts pour d\u00e9tecter un probl\u00e8me.</li> </ul>"},{"location":"notes/semaine_1/#entrees-et-sorties-en-c-avec-iostream","title":"Entr\u00e9es et Sorties en C++ avec <code>iostream</code>","text":"<p>La m\u00e9thode standard et s\u00e9curitaire pour g\u00e9rer les entr\u00e9es et sorties en C++ est la biblioth\u00e8que <code>&lt;iostream&gt;</code>. Elle utilise des flux (<code>streams</code>) pour envoyer ou recevoir des donn\u00e9es.</p> <ul> <li><code>std::cout</code> : Flux de sortie standard (g\u00e9n\u00e9ralement la console).</li> <li><code>std::cin</code> : Flux d'entr\u00e9e standard (g\u00e9n\u00e9ralement le clavier).</li> <li><code>std::endl</code> : Ins\u00e8re un retour \u00e0 la ligne (<code>\\n</code>) et vide le tampon de sortie.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string nom;\n    std::cout &lt;&lt; \"Entrez votre nom : \";\n    std::cin &gt;&gt; nom;\n\n    std::cout &lt;&lt; \"Bonjour \" &lt;&lt; nom &lt;&lt; \" !\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1/#piege-n1-melanger-cin-et-getline","title":"Pi\u00e8ge n\u00b01 : M\u00e9langer <code>cin &gt;&gt;</code> et <code>getline</code>","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> lit les donn\u00e9es jusqu'au premier espace blanc (espace, tabulation, retour \u00e0 la ligne). Le reste, y compris le <code>\\n</code> que vous tapez avec <code>Entr\u00e9e</code>, reste dans le buffer (tampon) d'entr\u00e9e.</p> <p>\u274c Code probl\u00e9matique : <pre><code>int age;\nstd::string nom_complet;\n\nstd::cout &lt;&lt; \"Entrez votre age : \";\nstd::cin &gt;&gt; age; // L'utilisateur tape \"25\" puis \"Entr\u00e9e\".\n                 // \"25\" est lu, mais \"\\n\" reste dans le buffer.\n\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // getline() voit le \"\\n\" restant et croit\n                                     // que l'utilisateur a d\u00e9j\u00e0 entr\u00e9 une ligne vide.\n                                     // Il ne demande pas d'input.\n\nstd::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;\n// Affiche : Age: 25, Nom: ''\n</code></pre></p> <p>\u2705 Solution : Vider le buffer avant <code>getline</code> On utilise <code>std::cin.ignore()</code> pour ignorer les caract\u00e8res restants dans le buffer, notamment le <code>\\n</code>.</p> <pre><code>// ... apr\u00e8s std::cin &gt;&gt; age;\nstd::cin.ignore(); // Ignore le caract\u00e8re \\n restant\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // Fonctionne comme pr\u00e9vu\n</code></pre>"},{"location":"notes/semaine_1/#piege-n2-erreur-de-type-lettres-pour-un-nombre","title":"Pi\u00e8ge n\u00b02 : Erreur de type (lettres pour un nombre)","text":"<p>Si l'utilisateur entre des lettres alors que <code>std::cin &gt;&gt;</code> s'attend \u00e0 un <code>int</code>, le flux <code>cin</code> entre en \u00e9tat d'erreur (<code>failbit</code>). Toute tentative de lecture ult\u00e9rieure \u00e9chouera tant que l'erreur n'est pas corrig\u00e9e et le buffer vid\u00e9.</p> <p>Pour g\u00e9rer robustement les erreurs de saisie :</p> <ol> <li>V\u00e9rifier l'\u00e9tat de <code>cin</code> : Boucler tant que la lecture \u00e9choue.</li> <li>Nettoyer les indicateurs d'erreur : <code>std::cin.clear()</code> r\u00e9initialise l'\u00e9tat de <code>cin</code>.</li> <li>Vider le buffer : <code>std::cin.ignore(...)</code> jette le contenu invalide.</li> </ol> <p>\u2705 Solution robuste :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt; // Requis pour numeric_limits\n\nint main() {\n    int age = 0;\n\n    // Boucle tant que l'entr\u00e9e est invalide\n    while (true) {\n        std::cout &lt;&lt; \"Veuillez entrer votre age : \";\n        std::cin &gt;&gt; age;\n\n        if (std::cin.good()) {\n            // La saisie est un nombre valide, on peut sortir de la boucle.\n            break; \n        }\n\n        // Si on arrive ici, la saisie a \u00e9chou\u00e9.\n        std::cout &lt;&lt; \"Erreur : Veuillez entrer un nombre valide.\" &lt;&lt; std::endl;\n\n        // 1. Nettoyer l'indicateur d'erreur de cin\n        std::cin.clear();\n\n        // 2. Vider le buffer d'entr\u00e9e\n        // On ignore tous les caract\u00e8res jusqu'\u00e0 la prochaine fin de ligne '\\n'.\n        // C'est la mani\u00e8re idiomatique et s\u00e9curitaire de le faire.\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    }\n\n    std::cout &lt;&lt; \"Vous avez \" &lt;&lt; age &lt;&lt; \" ans.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Attention aux Nombres Magiques</p> <p>Vous verrez parfois <code>std::cin.ignore(10000, '\\n');</code>. C'est une mauvaise pratique. On suppose arbitrairement que l'utilisateur ne tapera pas plus de 10 000 caract\u00e8res invalides. </p> <p>La m\u00e9thode correcte, <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');</code>, est la fa\u00e7on C++ standard de dire \"ignorer autant de caract\u00e8res que n\u00e9cessaire\". Elle ne repose sur aucune supposition.</p>"},{"location":"notes/semaine_1_1/","title":"Les Types de Donn\u00e9es et l'Initialisation en C++","text":"<p>Cette section couvre les types de donn\u00e9es fondamentaux et la mani\u00e8re moderne et s\u00e9curitaire de les initialiser en C++.</p>"},{"location":"notes/semaine_1_1/#1-les-types-primitifs","title":"1. Les Types Primitifs","text":"<p>Les types primitifs sont les briques de base pour stocker des donn\u00e9es. Leur taille en m\u00e9moire peut varier selon l'architecture (32-bit ou 64-bit), mais voici les valeurs les plus courantes sur un syst\u00e8me moderne.</p> Type Taille (Octets) Plage de Valeurs Typique Valeur par D\u00e9faut (<code>{}</code>) <code>bool</code> 1 <code>true</code> ou <code>false</code> <code>false</code> <code>char</code> 1 -128 \u00e0 127 <code>'\\0'</code> <code>int</code> 4 -2,1 milliards \u00e0 +2,1 milliards <code>0</code> <code>long long</code> 8 Environ -9 x 10\u00b9\u2078 \u00e0 +9 x 10\u00b9\u2078 <code>0</code> <code>float</code> 4 ~6-7 chiffres de pr\u00e9cision <code>0.0f</code> <code>double</code> 8 ~15-16 chiffres de pr\u00e9cision <code>0.0</code>"},{"location":"notes/semaine_1_1/#2-linitialisation-uniforme-avec-les-accolades","title":"2. L'Initialisation Uniforme avec les Accolades <code>{}</code>","text":"<p>Depuis C++11, la m\u00e9thode privil\u00e9gi\u00e9e pour initialiser toute variable est d'utiliser les accolades <code>{}</code>.</p> <p>(Les d\u00e9tails sur la s\u00e9curit\u00e9, l'uniformit\u00e9 et la garantie z\u00e9ro sont dans les sections pr\u00e9c\u00e9dentes)</p>"},{"location":"notes/semaine_1_1/#3-les-chaines-de-caracteres-et-tableaux","title":"3. Les Cha\u00eenes de Caract\u00e8res et Tableaux","text":"<p>(Contenu omis pour la bri\u00e8vet\u00e9)</p>"},{"location":"notes/semaine_1_1/#4-utiliser-les-tableaux-avec-des-fonctions","title":"4. Utiliser les Tableaux avec des Fonctions","text":""},{"location":"notes/semaine_1_1/#le-probleme-la-taille-est-perdue","title":"Le Probl\u00e8me : La Taille est Perdue","text":"<p>Quand vous passez un tableau \u00e0 une fonction, sa taille est perdue. La fonction ne re\u00e7oit qu'un pointeur.</p>"},{"location":"notes/semaine_1_1/#determiner-la-taille-dun-tableau-localement","title":"D\u00e9terminer la taille d'un tableau (localement)","text":"<p>La m\u00e9thode C++20 recommand\u00e9e est <code>std::ssize()</code> (de la biblioth\u00e8que <code>&lt;iterator&gt;</code>).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nint main() {\n    int notes_cours[] {80, 85, 90, 75, 88};\n    int taille {std::ssize(notes_cours)}; \n    std::cout &lt;&lt; \"La taille du tableau est : \" &lt;&lt; taille &lt;&lt; std::endl; // Affiche 5\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_1/#la-solution-generale-passer-la-taille-en-parametre","title":"La Solution G\u00e9n\u00e9rale : Passer la taille en param\u00e8tre","text":"<p>La convention est de toujours passer la taille comme un param\u00e8tre suppl\u00e9mentaire. Mais quel type choisir pour ce param\u00e8tre ?</p>"},{"location":"notes/semaine_1_1/#quel-type-utiliser-pour-la-taille-analyse","title":"Quel type utiliser pour la taille ? (Analyse)","text":"<p>Le choix du type pour la <code>taille</code> est un compromis entre simplicit\u00e9, s\u00e9curit\u00e9 et portabilit\u00e9. Le fichier d'exemple ci-dessous (que vous pouvez t\u00e9l\u00e9charger et compiler) d\u00e9montre plusieurs approches.</p> Fichier d'exemple : <code>exemple_types_taille.cpp</code> <pre><code>/**\n * @file main.cpp\n * @brief Fichier d'exemple pour d\u00e9montrer les diff\u00e9rentes mani\u00e8res de passer la taille\n *        d'un tableau \u00e0 une fonction en C++, en soulignant les avantages et les risques\n *        de chaque approche.\n */\n\n#include &lt;iostream&gt;\n#include &lt;iterator&gt; // Pour std::ssize\n#include &lt;cstddef&gt;  // Pour std::ptrdiff_t\n\n/**\n * @brief APPROCHE 1 : Utilise 'long long' pour la taille.\n * @note L'utilisation de `long long` est un choix simple et s\u00fbr sur la plupart des \n *       syst\u00e8mes 64-bit, car il est garanti d'\u00eatre assez grand.\n */\nvoid afficher_moyenne_long(const int notes[], long long taille) {\n    if (taille &lt;= 0) return;\n    double somme {0.0};\n    for (long long i {0}; i &lt; taille; ++i) { \n        somme += notes[i];\n    }\n    std::cout &lt;&lt; \"[long long] La moyenne est : \" &lt;&lt; somme / taille &lt;&lt; std::endl;\n}\n\n/**\n * @brief APPROCHE 2 : Utilise 'int' pour la taille.\n * @note Cette version est **risqu\u00e9e** pour des applications g\u00e9n\u00e9rales. Un `int` (32 bits)\n *       est trop petit pour contenir la taille d'un tr\u00e8s grand tableau, menant \u00e0 des bogues.\n *       Pour des exercices simples, c'est souvent acceptable.\n */\nvoid afficher_moyenne_risque(const int notes[], int taille) {\n    std::cout &lt;&lt; \"[int] Appel a la fonction risquee...\" &lt;&lt; std::endl;\n}\n\n/**\n * @brief APPROCHE 3 : Utilise 'std::ptrdiff_t' pour la taille.\n * @note Cette version est la plus **techniquement correcte et portable**. `std::ptrdiff_t` est le \n *       type sign\u00e9 que `std::ssize` retourne. Il est garanti d'\u00eatre assez grand\n *       sur n'importe quelle plateforme.\n */\nvoid afficher_moyenne_semi_pro(const int notes[], std::ptrdiff_t taille) {\n    std::cout &lt;&lt; \"[ptrdiff_t] Appel a la fonction semi-pro...\" &lt;&lt; std::endl;\n}\n\n/**\n * @brief APPROCHE 4 : Utilise un template de fonction (C++20).\n * @note L'utilisation de `auto` dans un param\u00e8tre est une fonctionnalit\u00e9 C++20\n *       qui cr\u00e9e un \"template\". C'est tr\u00e8s flexible, mais moins explicite.\n */\nvoid afficher_moyenne_moderne(const int notes[], auto taille)\n{\n    std::cout &lt;&lt; \"[auto] Appel moderne qui redirige vers la version 'long long'.\" &lt;&lt; std::endl;\n    afficher_moyenne_long(notes, taille);\n}\n\nint main() {\n    int notes_cours[] {80, 85, 90, 75, 88};\n\n    // On utilise std::ssize (C++20) pour obtenir la taille de mani\u00e8re s\u00fbre.\n    // std::ssize retourne un type sign\u00e9 (std::ptrdiff_t).\n    auto taille_notes { std::ssize(notes_cours) };\n\n    std::cout &lt;&lt; \"--- Affichage des moyennes ---\" &lt;&lt; std::endl;\n\n    // Appel \u00e0 la version `long long`. C'est un bon compromis entre simplicit\u00e9 et s\u00e9curit\u00e9.\n    afficher_moyenne_long(notes_cours, taille_notes);\n\n    // Appel \u00e0 la version C++20 avec `auto`.\n    afficher_moyenne_moderne(notes_cours, taille_notes);\n\n    return 0;\n}\n</code></pre> <p>Conclusion : - Pour les exercices de ce cours, utiliser <code>int</code> est souvent suffisant et simple. - Dans un contexte professionnel, <code>std::size_t</code> (non sign\u00e9) ou <code>std::ptrdiff_t</code> (sign\u00e9) sont de meilleurs choix pour la portabilit\u00e9 et la s\u00e9curit\u00e9.</p>"},{"location":"notes/semaine_1_2/","title":"Comprendre <code>std::cin</code> : La Saisie Simple en C++","text":"<p>Cette section vous aidera \u00e0 ma\u00eetriser <code>std::cin</code> pour obtenir des informations de l'utilisateur, en \u00e9vitant les pi\u00e8ges courants.</p>"},{"location":"notes/semaine_1_2/#1-comment-fonctionne-stdcin-et-le-buffer-dentree","title":"1. Comment fonctionne <code>std::cin</code> et le \"Buffer\" d'entr\u00e9e ?","text":"<p>Quand vous tapez au clavier, vos caract\u00e8res ne vont pas directement dans vos variables. Ils sont d'abord mis de c\u00f4t\u00e9 dans une zone d'attente appel\u00e9e le \"buffer\" d'entr\u00e9e. - <code>std::cin</code> va chercher les donn\u00e9es dans ce buffer. - Quand vous appuyez sur <code>Entr\u00e9e</code>, tous les caract\u00e8res tap\u00e9s (y compris <code>\\n</code>) sont envoy\u00e9s dans le buffer. - <code>std::cin</code> va alors lire ce dont il a besoin.</p>"},{"location":"notes/semaine_1_2/#2-lire-differents-types-de-donnees","title":"2. Lire Diff\u00e9rents Types de Donn\u00e9es","text":""},{"location":"notes/semaine_1_2/#a-lire-un-mot-ou-un-nombre-stdcin","title":"a) Lire un mot ou un nombre (<code>std::cin &gt;&gt;</code>)","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> est le plus simple. Il lit des mots ou des nombres, en s'arr\u00eatant au premier espace blanc (<code></code>, <code>\\t</code>, <code>\\n</code>). Le caract\u00e8re d'espacement reste dans le buffer.</p>"},{"location":"notes/semaine_1_2/#b-lire-une-ligne-complete-stdgetline","title":"b) Lire une ligne compl\u00e8te (<code>std::getline</code>)","text":"<p><code>std::getline(std::cin, ma_string)</code> lit une phrase enti\u00e8re, espaces inclus, jusqu'\u00e0 <code>\\n</code>. Il consomme et supprime le <code>\\n</code> du buffer.</p>"},{"location":"notes/semaine_1_2/#3-le-piege-courant-suivi-de-getline","title":"3. Le Pi\u00e8ge Courant : <code>&gt;&gt;</code> suivi de <code>getline</code>","text":"<p>Si vous utilisez <code>std::cin &gt;&gt;</code> pour lire un nombre, le <code>\\n</code> reste dans le buffer. Un <code>std::getline</code> juste apr\u00e8s le verra et s'arr\u00eatera imm\u00e9diatement, pensant que vous avez entr\u00e9 une ligne vide.</p> <p>La solution est de toujours nettoyer le buffer apr\u00e8s un <code>std::cin &gt;&gt;</code> si une lecture de ligne doit suivre. <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;limits&gt;\n\nint main() {\n    int age {};\n    std::string nom_complet {};\n\n    std::cout &lt;&lt; \"Entrez votre age : \";\n    std::cin &gt;&gt; age; \n\n    // On nettoie le buffer du '\\n' et de tout autre caract\u00e8re restant\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::cout &lt;&lt; \"Entrez votre nom complet : \";\n    std::getline(std::cin, nom_complet);\n\n    std::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p>"},{"location":"notes/semaine_1_2/#4-gerer-les-erreurs-lectures-partielles-et-echecs","title":"4. G\u00e9rer les Erreurs : Lectures Partielles et \u00c9checs","text":""},{"location":"notes/semaine_1_2/#cas-1-on-veut-un-int-on-recoit-45abc","title":"Cas 1 : On veut un <code>int</code>, on re\u00e7oit <code>45abc</code>","text":"<p>Le code : <pre><code>int age {};\nstd::cin &gt;&gt; age;\n</code></pre> Ce qui se passe : 1.  Le Buffer contient : <code>['4', '5', 'a', 'b', 'c', '\\n']</code> 2.  <code>cin</code> lit <code>4</code>, puis <code>5</code>. 3.  <code>cin</code> voit le <code>a</code>. Ce n'est pas un chiffre. Il s'arr\u00eate avant le <code>a</code>.</p> <p>Le R\u00e9sultat : - Variable <code>age</code> : Vaut <code>45</code>. La lecture est un succ\u00e8s partiel. - \u00c9tat du Buffer : Il reste <code>'a', 'b', 'c', '\\n'</code> \u00e0 l'int\u00e9rieur. - Danger \u26a0\ufe0f : La prochaine lecture par <code>cin</code> commencera sur le <code>a</code>, ce qui causera probablement une erreur si elle attend un nombre.</p>"},{"location":"notes/semaine_1_2/#cas-2-on-veut-une-string-on-recoit-abc45","title":"Cas 2 : On veut une <code>string</code>, on re\u00e7oit <code>abc45</code>","text":"<p>Le code : <pre><code>std::string texte {};\nstd::cin &gt;&gt; texte;\n</code></pre> Ce qui se passe : 1.  Le Buffer contient : <code>['a', 'b', 'c', '4', '5', '\\n']</code> 2.  <code>cin</code> lit <code>a</code>, <code>b</code>, <code>c</code>, <code>4</code>, <code>5</code>. Ce sont tous des caract\u00e8res valides pour une <code>string</code>. 3.  <code>cin</code> voit le <code>\\n</code>. C'est un \"espace blanc\". Il s'arr\u00eate.</p> <p>Le R\u00e9sultat : - Variable <code>texte</code> : Vaut <code>\"abc45\"</code>. - \u00c9tat du Buffer : Il reste <code>\\n</code> \u00e0 l'int\u00e9rieur.</p>"},{"location":"notes/semaine_1_2/#le-nettoyage-la-solution-de-pro","title":"Le \"Nettoyage\" (La solution de pro)","text":"<p>Voici une structure de code qui g\u00e8re \u00e0 la fois les lectures partielles (comme <code>45abc</code>) et les \u00e9checs totaux (comme <code>abc45</code>).</p> <p><pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;limits&gt;\n\nint main() {\n    int age {0};\n    std::cout &lt;&lt; \"Entrez votre age (ex: 45, 45abc, abc45) : \";\n\n    if (std::cin &gt;&gt; age) {\n        std::cout &lt;&lt; \"Partie numerique lue : \" &lt;&lt; age &lt;&lt; std::endl;\n    } else {\n        std::cout &lt;&lt; \"Erreur : Saisie invalide. Aucune valeur numerique lue.\" &lt;&lt; std::endl;\n        std::cin.clear(); \n    }\n\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::string autre_saisie {};\n    std::cout &lt;&lt; \"Entrez autre chose pour continuer : \";\n    std::cin &gt;&gt; autre_saisie;\n    std::cout &lt;&lt; \"Vous avez entre : \" &lt;&lt; autre_saisie &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> Cette approche qui consiste \u00e0 toujours vider le buffer apr\u00e8s une lecture est la plus robuste pour \u00e9viter les erreurs en cascade.</p>"},{"location":"notes/semaine_1_3/","title":"Passage par Copie vs. Passage par R\u00e9f\u00e9rence","text":"<p>Comprendre comment les donn\u00e9es sont pass\u00e9es aux fonctions est l'un des concepts les plus importants en C++. Cela d\u00e9termine si une fonction peut modifier une variable originale ou si elle travaille sur une simple copie.</p>"},{"location":"notes/semaine_1_3/#1-le-passage-par-copie-pass-by-value","title":"1. Le Passage par Copie (Pass-by-Value)","text":"<p>C'est le comportement par d\u00e9faut pour les types simples (<code>int</code>, <code>double</code>, <code>char</code>, etc.).</p> <ul> <li>Principe : La fonction re\u00e7oit une copie de la variable que vous lui passez. Elle ne re\u00e7oit jamais l'original.</li> <li>Analogie : C'est comme donner une photocopie d'un document \u00e0 quelqu'un. Il peut \u00e9crire dessus, la modifier... votre document original reste intact.</li> </ul>"},{"location":"notes/semaine_1_3/#exemple-avec-un-int","title":"Exemple avec un <code>int</code>","text":"<pre><code>#include &lt;iostream&gt;\n\nvoid ajouter_dix_copie(int nombre) { // `nombre` est une copie de la variable du main\n    nombre += 10;\n    std::cout &lt;&lt; \"Valeur dans la fonction (copie) : \" &lt;&lt; nombre &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#2-le-passage-par-reference-pass-by-reference","title":"2. Le Passage par R\u00e9f\u00e9rence (Pass-by-Reference)","text":"<p>Le passage par r\u00e9f\u00e9rence (<code>&amp;</code>) permet \u00e0 une fonction d'acc\u00e9der directement \u00e0 la variable originale.</p> <ul> <li>Principe : La fonction re\u00e7oit une r\u00e9f\u00e9rence (un alias) vers la variable originale. Toute modification affecte la variable d'origine.</li> <li>Analogie : C'est comme envoyer un lien de partage Google Docs avec les droits d'\u00e9dition. Les modifications sont vues par tout le monde.</li> </ul>"},{"location":"notes/semaine_1_3/#exemple-avec-un-int_1","title":"Exemple avec un <code>int&amp;</code>","text":"<pre><code>#include &lt;iostream&gt;\n\n// Le '&amp;' indique que `nombre` est une r\u00e9f\u00e9rence \u00e0 la variable originale.\nvoid ajouter_dix_reference(int&amp; nombre) {\n    nombre += 10;\n    std::cout &lt;&lt; \"Valeur dans la fonction (reference) : \" &lt;&lt; nombre &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#3-demonstration-copie-vs-reference","title":"3. D\u00e9monstration : Copie vs. R\u00e9f\u00e9rence","text":"<p>Voyons l'impact de ces deux m\u00e9thodes sur les variables dans <code>main</code>.</p> <pre><code>#include &lt;iostream&gt;\n\n// ... (coller les deux fonctions ajouter_dix_copie et ajouter_dix_reference ici) ...\n\nint main() {\n    // --- Test avec le passage par copie ---\n    int ma_variable_copie {20};\n    std::cout &lt;&lt; \"1. Avant l'appel (copie), ma_variable_copie = \" &lt;&lt; ma_variable_copie &lt;&lt; std::endl;\n    ajouter_dix_copie(ma_variable_copie);\n    std::cout &lt;&lt; \"3. Apres l'appel (copie), ma_variable_copie = \" &lt;&lt; ma_variable_copie &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\n-----------------------------------\\n\\n\";\n\n    // --- Test avec le passage par r\u00e9f\u00e9rence ---\n    int ma_variable_reference {20};\n    std::cout &lt;&lt; \"1. Avant l'appel (reference), ma_variable_reference = \" &lt;&lt; ma_variable_reference &lt;&lt; std::endl;\n    ajouter_dix_reference(ma_variable_reference);\n    std::cout &lt;&lt; \"3. Apres l'appel (reference), ma_variable_reference = \" &lt;&lt; ma_variable_reference &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#resultat-du-programme","title":"R\u00e9sultat du programme :","text":"<p><pre><code>1. Avant l'appel (copie), ma_variable_copie = 20\nValeur dans la fonction (copie) : 30\n3. Apres l'appel (copie), ma_variable_copie = 20\n\n-----------------------------------\n\n1. Avant l'appel (reference), ma_variable_reference = 20\nValeur dans la fonction (reference) : 30\n3. Apres l'appel (reference), ma_variable_reference = 30\n</code></pre> Conclusion : - La variable pass\u00e9e par copie est rest\u00e9e intacte. - La variable pass\u00e9e par r\u00e9f\u00e9rence a \u00e9t\u00e9 modifi\u00e9e de mani\u00e8re permanente.</p>"},{"location":"notes/semaine_1_3/#4-le-cas-special-des-tableaux","title":"4. Le Cas Sp\u00e9cial des Tableaux","text":"<p>Les tableaux de style C (<code>int mon_tableau[10];</code>) ont un comportement unique.</p> <p>Comportement Important</p> <p>Quand vous passez un tableau statique \u00e0 une fonction, il n'est pas copi\u00e9. La fonction re\u00e7oit un acc\u00e8s direct au tableau original. Toute modification faite \u00e0 l'int\u00e9rieur de la fonction affectera le tableau original dans le <code>main</code>.</p>"},{"location":"notes/semaine_1_3/#exemple-avec-un-tableau","title":"Exemple avec un Tableau","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt; // Pour std::ssize\n\n// M\u00eame sans le '&amp;', la fonction peut modifier le tableau original.\nvoid modifier_premier_element(int tableau[], int taille) {\n    if (taille &gt; 0) {\n        tableau[0] = 999; // Cette modification sera visible dans le main !\n    }\n}\n\nvoid afficher_tableau(const int tableau[], int taille) {\n    for (int i {0}; i &lt; taille; ++i) {\n        std::cout &lt;&lt; tableau[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nint main() {\n    int mes_notes[] {80, 75, 92, 88, 79};\n    auto taille {std::ssize(mes_notes)};\n\n    std::cout &lt;&lt; \"Tableau original : \";\n    afficher_tableau(mes_notes, taille);\n\n    modifier_premier_element(mes_notes, taille);\n\n    std::cout &lt;&lt; \"Tableau apres la modification : \";\n    afficher_tableau(mes_notes, taille);\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#resultat-du-programme_1","title":"R\u00e9sultat du programme :","text":"<p><pre><code>Tableau original : 80 75 92 88 79 \nTableau apres la modification : 999 75 92 88 79 \n</code></pre> Conclusion : La note <code>80</code> a bien \u00e9t\u00e9 remplac\u00e9e par <code>999</code>. Le passage d'un tableau \u00e0 une fonction se comporte comme un passage par r\u00e9f\u00e9rence, m\u00eame sans le <code>&amp;</code>. Nous verrons plus tard pourquoi.</p>"},{"location":"notes/semaine_1_4/","title":"Guide de Compilation en C++20","text":"<p>Ce document explique comment transformer votre code source (<code>.cpp</code>, <code>.hpp</code>) en un programme ex\u00e9cutable \u00e0 l'aide du compilateur <code>g++</code> et du standard C++20.</p>"},{"location":"notes/semaine_1_4/#1-quest-ce-que-la-compilation","title":"1. Qu'est-ce que la Compilation ?","text":"<p>La compilation est le processus qui traduit votre code C++, lisible par un humain, en code machine, compr\u00e9hensible par l'ordinateur. L'outil qui r\u00e9alise cette traduction est appel\u00e9 un compilateur. Dans ce cours, nous utiliserons <code>g++</code>, le compilateur C++ du projet GNU, l'un des plus populaires.</p> <p></p>"},{"location":"notes/semaine_1_4/#2-la-commande-de-compilation-essentielle","title":"2. La Commande de Compilation Essentielle","text":"<p>Pour compiler, vous ouvrirez un terminal (ou une console) et taperez une commande qui ressemble \u00e0 ceci :</p> <pre><code>g++ [options] -o [nom_executable] [vos_fichiers.cpp]\n</code></pre> <p>D\u00e9taillons chaque partie :</p> <ul> <li><code>g++</code> : C'est l'appel au compilateur lui-m\u00eame.</li> <li><code>[options]</code> : Ce sont des \"drapeaux\" (flags) qui modifient le comportement du compilateur. Les deux plus importants pour nous sont :<ul> <li><code>-std=c++20</code> : C'est le drapeau crucial qui dit \u00e0 <code>g++</code> d'utiliser le standard C++20. Sans cela, les fonctionnalit\u00e9s modernes du langage ne seront pas disponibles.</li> <li><code>-Wall</code> : (Abr\u00e9viation de \"Warnings All\") C'est une option tr\u00e8s fortement recommand\u00e9e qui active presque tous les avertissements (<code>warnings</code>). Le compilateur vous signalera des erreurs potentielles dans votre code, m\u00eame si elles ne l'emp\u00eachent pas de compiler. C'est un filet de s\u00e9curit\u00e9 indispensable.</li> </ul> </li> <li><code>-o [nom_executable]</code> : L'option <code>-o</code> (pour \"output\") vous permet de nommer votre programme final. Si vous l'omettez, le fichier de sortie s'appellera <code>a.out</code> (sur Linux/macOS) ou <code>a.exe</code> (sur Windows).</li> <li><code>[vos_fichiers.cpp]</code> : C'est la liste de tous vos fichiers <code>.cpp</code>, s\u00e9par\u00e9s par des espaces. Vous n'avez pas besoin d'inclure les fichiers <code>.hpp</code>, car ils sont g\u00e9r\u00e9s via les directives <code>#include</code> dans vos fichiers <code>.cpp</code>.</li> </ul>"},{"location":"notes/semaine_1_4/#3-exemples-concrets","title":"3. Exemples Concrets","text":""},{"location":"notes/semaine_1_4/#cas-1-un-projet-avec-un-seul-fichier","title":"Cas 1 : Un Projet avec un Seul Fichier","text":"<p>Imaginons que vous avez un seul fichier <code>main.cpp</code>.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp\n</code></pre> -   Ceci cr\u00e9era un ex\u00e9cutable nomm\u00e9 <code>mon_programme</code>.</p>"},{"location":"notes/semaine_1_4/#cas-2-un-projet-avec-plusieurs-fichiers","title":"Cas 2 : Un Projet avec Plusieurs Fichiers","text":"<p>Reprenons notre exemple <code>Commande</code>. Nous avons trois fichiers <code>.cpp</code> \u00e0 compiler ensemble.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o exemple main.cpp Commande.cpp ServiceConnexion.cpp\n</code></pre> -   <code>g++</code> va compiler chaque fichier <code>.cpp</code> et les lier (\"link\") ensemble pour cr\u00e9er un seul ex\u00e9cutable nomm\u00e9 <code>exemple</code>.</p>"},{"location":"notes/semaine_1_4/#4-executer-votre-programme","title":"4. Ex\u00e9cuter votre Programme","text":"<p>Une fois la compilation r\u00e9ussie (si la commande ne retourne aucune erreur), un nouveau fichier ex\u00e9cutable appara\u00eetra dans votre dossier.</p> <p>Pour l'ex\u00e9cuter dans le terminal :</p> <ul> <li> <p>Sur Linux ou macOS : <pre><code>./nom_executable \n</code></pre>     (Le <code>./</code> signifie \"dans le dossier actuel\")</p> </li> <li> <p>Sur Windows (cmd ou PowerShell) : <pre><code>.\\nom_executable.exe\n</code></pre></p> </li> </ul>"},{"location":"notes/semaine_1_4/#5-ca-ne-compile-pas-gerer-les-erreurs","title":"5. \"\u00c7a ne compile pas !\" - G\u00e9rer les Erreurs","text":"<p>Il est normal d'avoir des erreurs de compilation. L'art de la programmation est de savoir les lire.</p> <p>Les erreurs les plus courantes au d\u00e9but : -   Oubli d'un point-virgule (<code>;</code>) \u00e0 la fin d'une ligne. -   Faute de frappe dans un nom de variable ou de fonction. -   Accolade (<code>{</code> ou <code>}</code>) manquante. -   Oubli d'inclure un en-t\u00eate (ex: <code>#include &lt;string&gt;</code> pour utiliser <code>std::string</code>).</p> <p>Lisez attentivement les messages d'erreur. <code>g++</code> vous donnera g\u00e9n\u00e9ralement le nom du fichier et le num\u00e9ro de la ligne o\u00f9 l'erreur a \u00e9t\u00e9 d\u00e9tect\u00e9e.</p> <p>Exemple de message d'erreur : <pre><code>main.cpp: In function 'int main()':\nmain.cpp:5:3: error: expected ';' before 'return'\n   return 0;\n   ^~~~~~\n</code></pre> Le compilateur nous dit qu'\u00e0 la ligne 5 du fichier <code>main.cpp</code>, il s'attendait \u00e0 un point-virgule avant le mot-cl\u00e9 <code>return</code>.</p> <p>```</p>"}]}