{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Programmation 3 (420-4A6-VI) - Hiver 2026","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Vous trouverez ici les notes et exercices du cours. J'ajouterai du nouveau contenu continuellement.</p> <p>Pr\u00e9alable \u00e0 ce cours : 420-2A6-VI : Programmation 2 </p> <p>Ce cours est pr\u00e9alable \u00e0 : 420-5B5-VI Projet int\u00e9grateur 1 Cheminement complet: https://informatique.apical.xyz/</p>"},{"location":"#environnement-de-travail","title":"Environnement de travail","text":"<p>Pour le cours vous avez deux logiciels \u00e0 installer:</p> <ul> <li>WSL (Windows subsystem for linux)</li> <li>Un \u00e9diteur de texte \u00e9volu\u00e9 tel notepad++ (recommand\u00e9) </li> <li>Codeblock</li> <li>Git</li> </ul>"},{"location":"#wsl","title":"WSL","text":"<p>Vous devez installer git et build-essential dans l'environnement linux. Les paquets tels que, mais non limit\u00e9s \u00e0, gemini, claude, chatgpt sont proscrit. \u2003</p>"},{"location":"#notepad-ou-autre-editeur-compatible","title":"Notepad++ (ou autre \u00e9diteur compatible)","text":"<p>Parfois git vous demande de faire l'\u00e9ditions de fichiers tel que les commentaires pour les soumissions. (git commit). Il arrive \u00e9galement que des conflits soient pr\u00e9sent. Le logiciels permet de mieux travailler dans ces situations plus complexe.</p>"},{"location":"#git","title":"Git","text":"<p>Installation normale, portez attention \u00e0 l'\u00e9diteur par d\u00e9faut. Autrement, vous allez vous retrouver avec vim pour \u00e9diter vos fichiers</p> <p>Votre identit\u00e9 : dans WSL vous \u00eates dans un environnement \"nouveau\" donc git va vous demander votre identit\u00e9. Utilisez votre courriel coll\u00e8ge comme configuration de courriel globale : @etudiant.cegepvicto.ca  Pour votre nom vous pouvez r\u00e9utiliser votre num\u00e9ro de DA  </p> <pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"[DA]@etudiant.cegepvicto.ca\"\n  git config --global user.name \"Votre nom\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n</code></pre>"},{"location":"#regles-de-classes-et-explications","title":"R\u00e8gles de classes et explications :","text":"<p>Petit rappel des r\u00e8gles au niveau de la P.D.E.A</p>"},{"location":"#conditions-pedagogiques-particulieres","title":"Conditions p\u00e9dagogiques particuli\u00e8res","text":"<p>Utilisation de g\u00e9n\u00e9rateur automatique :  </p> <p>Dans le cadre des activit\u00e9s acad\u00e9miques du cours, l'utilisation de g\u00e9n\u00e9rateurs de code automatiques, d'assistants d'IA tels que ChatGPT, Copilot ou tout autre outil similaire permettant la cr\u00e9ation automatique de contenu, la g\u00e9n\u00e9ration de code ou l\u2019assistance \u00e0 la r\u00e9solution d'exercices, est formellement interdite. Toute utilisation de ces outils durant un cours entra\u00eenera l'exclusion imm\u00e9diate de l'\u00e9l\u00e8ve de la p\u00e9riode concern\u00e9e.  </p>"},{"location":"#utilisation-des-cellulaires-ou-dappareils-mobiles-en-classe","title":"Utilisation des cellulaires ou d'appareils mobiles en classe","text":"<p>Toute utilisation d'appareil mobile tel que cellulaire, tablette ou console de jeux mobile est proscrite pendant le bloc horaire \u00e0 l'int\u00e9rieur du local. (Pr\u00e9cision : pauses incluses.) L'utilisation de tels appareils doit imp\u00e9rativement se faire hors du local afin de favoriser le climat d'apprentissage.  </p> <p>Les manquements aux articles pr\u00e9c\u00e9dents seront consign\u00e9s. Apr\u00e8s trois (3) exclusions, des d\u00e9marches administratives seront entreprises avec l'API afin de d\u00e9terminer les modalit\u00e9s de cheminement.</p>"},{"location":"#environnement-numerique-dapprentissage-plateforme","title":"Environnement num\u00e9rique d\u2019apprentissage (plateforme)","text":"<ul> <li>Team</li> <li>Github</li> <li>Github classroom</li> </ul> <p>L'\u00e9l\u00e8ve a la responsabilit\u00e9 d'avoir un compte github avec un nom d'utilisateur r\u00e9pondant \u00e0 la norme suivante :</p> <p>cgpvicto-[son num\u00e9ro de DA]</p> <p>exemple : cgpvicto-9999999</p> <p>Une fois le compte github cr\u00e9\u00e9. On doit rejoindre le github classroom correspondant \u00e0 son groupe, proc\u00e9dure qui sera donn\u00e9e en classe lors des premi\u00e8res semaines</p>"},{"location":"conventions/","title":"Normes et Conventions de Code C++","text":"<p>Standard du Cours</p> <p>Ce cours utilise officiellement le standard C++20. Tous les exemples et exercices doivent \u00eatre compil\u00e9s avec un compilateur compatible.</p> <p>Ce document d\u00e9finit les standards de programmation attendus pour tous les travaux pratiques et examens. L'objectif est de produire un code lisible, maintenable et proche des standards industriels modernes.</p>"},{"location":"conventions/#1-structure-du-code-et-nommage","title":"1. Structure du Code et Nommage","text":""},{"location":"conventions/#11-nommage-naming-convention","title":"1.1. Nommage (Naming Convention)","text":"<p>Nous adoptons le style de la Biblioth\u00e8que Standard C++ (STL).</p> \u00c9l\u00e9ment Format Exemple Variables <code>snake_case</code> <code>nombre_etudiants</code>, <code>index_courant</code> Fonctions <code>snake_case</code> <code>calculer_moyenne()</code>, <code>sauvegarder_fichier()</code> Classes / Structs <code>PascalCase</code> <code>Etudiant</code>, <code>GestionnaireFichier</code> Constantes <code>SCREAMING_SNAKE</code> <code>MAX_BUFFER_SIZE</code>, <code>PI</code>"},{"location":"conventions/#12-initialisation-uniforme-avec-les-accolades","title":"1.2. Initialisation Uniforme avec les Accolades <code>{}</code>","text":"<p>R\u00e8gle : Pour initialiser toute variable, utilisez toujours la syntaxe avec accolades <code>{}</code> (Uniform Initialization).</p> <p>Pourquoi ? - S\u00e9curit\u00e9 : Emp\u00eache les conversions de type risqu\u00e9es (ex: <code>int x {5.5};</code> g\u00e9n\u00e8re une erreur de compilation). - Uniformit\u00e9 : La m\u00eame syntaxe fonctionne pour tout (variables simples, tableaux, objets). - Garantie Z\u00e9ro : Une initialisation avec des accolades vides (<code>int x {};</code>) garantit que la variable vaut z\u00e9ro (ou son \u00e9quivalent), pr\u00e9venant les bogues de variables non-initialis\u00e9es.</p>"},{"location":"conventions/#2-structure-et-complexite","title":"2. Structure et Complexit\u00e9","text":""},{"location":"conventions/#21-regle-des-3-niveaux","title":"2.1. R\u00e8gle des 3 niveaux","text":"<p>L'imbrication (nesting) ne doit jamais d\u00e9passer 3 niveaux de profondeur.</p>"},{"location":"conventions/#22-clause-de-garde-guard-clause","title":"2.2. Clause de Garde (Guard Clause)","text":"<p>Privil\u00e9giez toujours le retour anticip\u00e9 (Early Return) pour r\u00e9duire la complexit\u00e9.</p>"},{"location":"conventions/#3-bonnes-pratiques-fichiers-et-performance","title":"3. Bonnes pratiques : Fichiers et Performance","text":""},{"location":"conventions/#31-organisation-une-classe-par-fichier","title":"3.1. Organisation : Une Classe par Fichier","text":"<p>Chaque <code>class</code> ou <code>struct</code> doit \u00eatre d\u00e9finie dans son propre couple de fichiers (<code>.hpp</code> et <code>.cpp</code>).</p>"},{"location":"conventions/#32-fichiers-den-tete-et-pragma-once","title":"3.2. Fichiers d'en-t\u00eate et <code>#pragma once</code>","text":"<p>Tout fichier <code>.hpp</code> doit commencer imp\u00e9rativement par <code>#pragma once</code>.</p>"},{"location":"conventions/#33-le-const-et-le-passage-par-reference","title":"3.3. Le <code>const</code> et le passage par r\u00e9f\u00e9rence","text":"<p>Pour les types complexes (<code>string</code>, <code>vector</code>, etc.), utilisez <code>const type&amp;</code> en param\u00e8tre pour \u00e9viter des copies inutiles.</p>"},{"location":"conventions/#4-documentation-du-code-doxygen","title":"4. Documentation du Code (Doxygen)","text":"<p>Le standard est Doxygen. La documentation se place toujours dans les fichiers <code>.hpp</code>.</p> <ul> <li>Classes/Structs : Doivent avoir un bloc <code>/** ... */</code> avec au minimum <code>@brief</code>.</li> <li>M\u00e9thodes : Doivent avoir un bloc <code>///</code> avec <code>@brief</code>, <code>@param</code> et <code>@return</code> si applicable.</li> </ul>"},{"location":"conventions/#5-exemple-complet-dapplication","title":"5. Exemple Complet d'Application","text":"<p>T\u00e9l\u00e9charger l'exemple complet (ZIP)</p> <p>Voici un exemple concret qui rassemble tous les standards.</p>"},{"location":"conventions/#51-structure-des-fichiers","title":"5.1. Structure des fichiers","text":"<pre><code>/exemple_commande\n|-- Article.hpp\n|-- Commande.cpp\n|-- Commande.hpp\n|-- main.cpp\n|-- ServiceConnexion.cpp\n`-- ServiceConnexion.hpp\n</code></pre>"},{"location":"conventions/#52-fichiers-den-tete-et-source","title":"5.2. Fichiers d'en-t\u00eate et Source","text":"Fichier : <code>main.cpp</code> <pre><code>#include &lt;iostream&gt;\n#include \"Commande.hpp\"\n\nint main() {\n    ServiceConnexion service_connexion {};\n    Article article_disponible {\"Stylo\", 10};\n    Article article_indisponible {\"Cahier\", 0};\n\n    std::cout &lt;&lt; \"--- Debut des tests de scenarios ---\\\\n\" &lt;&lt; std::endl;\n\n    // Sc\u00e9nario 1 : Commande valide\n    Commande cmd_valide {101};\n    cmd_valide.ajouter_article(article_disponible);\n    cmd_valide.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 2 : Article en rupture de stock\n    Commande cmd_stock_epuise {102};\n    cmd_stock_epuise.ajouter_article(article_disponible);\n    cmd_stock_epuise.ajouter_article(article_indisponible);\n    cmd_stock_epuise.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 3 : Commande invalide (vide)\n    Commande cmd_vide {103};\n    cmd_vide.traiter_commande(service_connexion);\n\n    std::cout &lt;&lt; \"\\n--- Fin des tests ---\\\\n\";\n\n    return 0;\n}\n</code></pre> <p>(Le code des autres fichiers <code>Article.hpp</code>, <code>Commande.hpp</code>, etc. est omis pour la lisibilit\u00e9, mais est inclus dans le ZIP t\u00e9l\u00e9chargeable.)</p>"},{"location":"conventions/#53-compilation-et-resultat","title":"5.3. Compilation et R\u00e9sultat","text":"<p>Pour compiler et ex\u00e9cuter cet exemple : <pre><code>g++ -std=c++20 -Wall -o exemple_commande/exemple exemple_commande/main.cpp exemple_commande/Commande.cpp exemple_commande/ServiceConnexion.cpp\n./exemple_commande/exemple\n</code></pre></p> <p>Le r\u00e9sultat attendu est : <pre><code>--- Debut des tests de scenarios ---\n\nSUCCES : La commande 101 a ete envoyee.\nERREUR (Cmd 102): Un ou plusieurs articles en rupture de stock.\nERREUR (Cmd 103): Commande invalide ou vide.\n\n--- Fin des tests ---\n</code></pre></p>"},{"location":"horaire/","title":"Horaire du cours","text":"<p>Planification de la session Hiver 2026.</p> <p>Remarque importante</p> <p>Les dates de remises sont indiqu\u00e9es par le drapeau \ud83d\udea9. Assurez-vous de v\u00e9rifier cette colonne r\u00e9guli\u00e8rement.</p>"},{"location":"horaire/#partie-1-avant-la-relache","title":"Partie 1 : Avant la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 1 Cours 01 19-01-2026 08:15 Pr\u00e9sentation du plan de cours Cours 02 21-01-2026 13:15 Semaine 2 Cours 03 26-01-2026 08:15 Cours 04 29-01-2026 13:15 Semaine 3 Cours 05 02-02-2026 08:15 Cours 06 05-02-2026 13:15 Semaine 4 Cours 07 09-02-2026 08:15 Cours 08 12-02-2026 13:15 Semaine 5 Cours 09 16-02-2026 08:15 Cours 10 19-02-2026 13:15 Semaine 6 Cours 11 23-02-2026 08:15 Cours 12 26-02-2026 13:15 {: .horaire } <p>\ud83c\udf34 SEMAINE DE REL\u00c2CHE : Du 2 au 6 mars 2026</p> <p>Aucun cours.</p>"},{"location":"horaire/#partie-2-apres-la-relache","title":"Partie 2 : Apr\u00e8s la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 7 Cours 13 09-03-2026 08:15 Cours 14 12-03-2026 13:15 Semaine 8 Cours 15 16-03-2026 08:15 Cours 16 19-03-2026 13:15 Semaine 9 Cours 17 23-03-2026 08:15 Cours 18 26-03-2026 13:15 Semaine 10 Cours 19 30-03-2026 08:15 Cours 20 02-04-2026 13:15 Prochaine rencontre dans 1 sem. Semaine 11 Cours 21 09-04-2026 13:15 Cours 22 13-04-2026 08:15 Semaine 12 Cours 23 16-04-2026 13:15 Cours 24 20-04-2026 08:15 Semaine 13 Cours 25 27-04-2026 08:15 Cours 26 30-04-2026 13:15 Semaine 14 Cours 27 04-05-2026 08:15 Cours 28 07-05-2026 13:15 Semaine 15 Cours 29 11-05-2026 08:15 Cours 30 14-05-2026 13:15 {: .horaire }"},{"location":"ressources/","title":"Ressources","text":""},{"location":"ressources/#documentation-officielle","title":"Documentation officielle","text":"<p>C# documentation officielle : https://learn.microsoft.com/fr-ca/dotnet/csharp/tour-of-csharp/</p> <p>.Net 8.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-8.0</p> <p>.Net 9.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-9.0</p> <p>Tests unitaires MSTest : https://learn.microsoft.com/fr-ca/dotnet/core/testing/unit-testing-with-mstest </p> <p>Table ASCII : https://www.asciitable.com/</p>"},{"location":"exercices/exercice_semaine_1_1/","title":"Exercices de la Semaine 1 : Les Bases","text":"<p>Ces exercices sont con\u00e7us pour pratiquer les concepts de base vus dans les notes de la semaine 1. Concentrez-vous sur la ma\u00eetrise de la compilation, de l'affichage, de la saisie et des fonctions simples.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-1-affichage-et-saisie-simple","title":"Bloc 1 : Affichage et Saisie Simple","text":"<p>Exercice 1 : Bonjour le Monde - Objectif : Cr\u00e9er un programme C++ de base. - T\u00e2che : \u00c9crivez un programme qui affiche \"Bonjour le monde !\" dans la console et qui se termine en retournant <code>0</code>.</p> <p>Exercice 2 : Fiche de Pr\u00e9sentation - Objectif : Manipuler <code>std::cout</code> avec plusieurs lignes. - T\u00e2che : \u00c9crivez un programme qui affiche votre nom, votre ville et votre \u00e2ge sur des lignes s\u00e9par\u00e9es.</p> <p>Exercice 3 : D\u00e9claration de Variables - Objectif : Se familiariser avec l'initialisation uniforme. - T\u00e2che : D\u00e9clarez quatre variables en utilisant la syntaxe d'accolades <code>{}</code> : un <code>int</code>, un <code>double</code>, un <code>char</code>, et un <code>bool</code>. Assignez-leur des valeurs de votre choix et affichez chaque valeur avec une description.</p> <p>Exercice 4 : Interaction Simple - Objectif : Utiliser <code>std::cin &gt;&gt;</code> avec <code>std::string</code> et <code>int</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur son pr\u00e9nom et son ann\u00e9e de naissance. Calculez (approximativement) son \u00e2ge et affichez un message comme <code>\"Bonjour [Pr\u00e9nom], vous avez environ [Age] ans.\"</code>.</p> <p>Exercice 5 : Calcul d'Aire - Objectif : Utiliser des types <code>double</code> avec <code>std::cin</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur la largeur et la hauteur d'un rectangle. Calculez et affichez son aire.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-2-gestion-du-buffer-et-erreurs-de-saisie","title":"Bloc 2 : Gestion du Buffer et Erreurs de Saisie","text":"<p>Exercice 6 : Le Pi\u00e8ge de <code>getline</code> - Objectif : R\u00e9soudre le conflit entre <code>std::cin &gt;&gt;</code> et <code>std::getline</code>. - T\u00e2che : 1. Demandez \u00e0 l'utilisateur son num\u00e9ro de porte (un <code>int</code>).   2. Demandez-lui ensuite son nom de rue complet (un <code>std::string</code> avec <code>getline</code>).   3. Observez que le programme ignore la saisie de la rue.   4. Corrigez le probl\u00e8me en nettoyant le buffer apr\u00e8s la lecture du nombre.</p> <p>Exercice 7 : Gestion d'Erreur Simple - Objectif : Utiliser <code>std::cin.fail()</code> pour d\u00e9tecter une erreur. - T\u00e2che : Demandez \u00e0 l'utilisateur d'entrer un nombre. Si la saisie \u00e9choue (si l'utilisateur tape du texte), affichez \"Erreur : saisie invalide.\". Sinon, affichez \"Merci !\".</p> <p>Exercice 8 : Boucle de Saisie Robuste - Objectif : Cr\u00e9er une boucle qui force une saisie num\u00e9rique valide. - T\u00e2che : Cr\u00e9ez une boucle <code>while</code> qui continue de demander \"Entrez votre age :\" jusqu'\u00e0 ce que l'utilisateur entre un nombre entier valide. Si l'utilisateur se trompe, le programme doit afficher une erreur et lui redemander.</p> <p>Exercice 9 : Analyse d'Entr\u00e9e Mixte - Objectif : Comprendre comment <code>cin</code> g\u00e8re les lectures partielles. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur un nombre. L'utilisateur doit taper <code>45abc</code>.   2. Lisez la saisie dans une variable de type <code>int</code>.   3. Affichez l'entier que vous avez r\u00e9ussi \u00e0 lire.   4. Ensuite, lisez le reste du buffer dans une variable <code>std::string</code>.   5. Affichez la cha\u00eene de caract\u00e8res. Le r\u00e9sultat devrait vous montrer ce qui restait dans le buffer.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-3-fonctions-et-tableaux-classique","title":"Bloc 3 : Fonctions et Tableaux (Classique)","text":"<p>Exercice 10 : Calculatrice Simple - Objectif : \u00c9crire et appeler des fonctions simples. - T\u00e2che : \u00c9crivez quatre fonctions : <code>addition(int a, int b)</code>, <code>soustraction(int a, int b)</code>, <code>multiplication(int a, int b)</code>, et <code>division(int a, int b)</code>. Chaque fonction doit retourner le r\u00e9sultat du calcul. Dans <code>main</code>, testez chaque fonction avec des valeurs de votre choix et affichez les r\u00e9sultats.</p> <p>Exercice 11 : Passage par Copie - Objectif : Constater l'effet d'un passage par copie. - T\u00e2che :   1. \u00c9crivez une fonction <code>ajouter_vingt(int nombre)</code> qui re\u00e7oit un entier, lui ajoute 20, et n'a pas de <code>return</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {10}</code>.   3. Appelez <code>ajouter_vingt(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 12 : Passage par R\u00e9f\u00e9rence - Objectif : Utiliser une r\u00e9f\u00e9rence pour modifier une variable externe. - T\u00e2che :   1. \u00c9crivez une fonction <code>reinitialiser(int&amp; nombre)</code> qui change la valeur de l'entier re\u00e7u \u00e0 <code>0</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {123}</code>.   3. Appelez <code>reinitialiser(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 13 : Somme d'un Tableau (Style C) - Objectif : Passer un tableau \u00e0 une fonction (m\u00e9thode classique). - T\u00e2che : Cr\u00e9ez une fonction <code>calculer_somme(const int tableau[], int taille)</code> qui retourne la somme de tous les \u00e9l\u00e9ments d'un tableau. Dans <code>main</code>, initialisez un tableau (ex: <code>int tableau[] {10, 20, 30};</code>), trouvez sa taille avec <code>std::ssize</code>, et affichez la somme retourn\u00e9e par votre fonction.</p> <p>Exercice 14 : Trouver le Maximum - Objectif : Parcourir un tableau dans une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>trouver_max(const int tableau[], int taille)</code> qui retourne la plus grande valeur d'un tableau. Testez-la dans <code>main</code>.</p> <p>Exercice 15 : Inversion de Tableau - Objectif : Modifier un tableau via une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau sur place (le premier devient le dernier, etc.). Dans <code>main</code>, d\u00e9clarez un tableau comme <code>int tableau[] {1, 2, 3, 4, 5};</code>, affichez-le, appelez la fonction, puis affichez-le \u00e0 nouveau pour voir le changement.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-4-c-moderne-stdspan-vector","title":"Bloc 4 : C++ Moderne (std::span &amp; Vector)","text":"<p>Exercice 16 : La R\u00e8gle d'Or (std::span) - Objectif : Remplacer le couple <code>(tableau, taille)</code> par <code>std::span</code>. - T\u00e2che :   1. Reprenez votre fonction <code>calculer_somme</code> de l'exercice 13.   2. Changez sa signature pour qu'elle prenne un <code>std::span&lt;const int&gt;</code> au lieu d'un tableau et une taille.   3. Dans <code>main</code>, cr\u00e9ez un tableau brut (<code>int t[]...</code>).   4. Appelez la fonction. Remarquez que vous n'avez plus besoin de passer la taille manuellement !</p> <p>Exercice 17 : Optimisation avec R\u00e9f\u00e9rence Constante - Objectif : \u00c9viter les copies inutiles sur les gros objets. - T\u00e2che :   1. \u00c9crivez une fonction <code>afficher_message(std::string message)</code> (par copie).   2. Modifiez-la pour utiliser le passage par r\u00e9f\u00e9rence constante (<code>const std::string&amp;</code>).   3. Ajoutez un <code>cout</code> dans la fonction pour v\u00e9rifier que le message s'affiche bien.   Question : \u00c0 l'utilisation dans le <code>main</code>, est-ce que le code d'appel change ? (R\u00e9ponse attendue : Non, c'est transparent, mais plus rapide).</p> <p>Exercice 18 : Vecteur Dynamique et Span - Objectif : Utiliser un tableau qui peut grandir (<code>vector</code>) avec une fonction moderne. - T\u00e2che :   1. Incluez <code>&lt;vector&gt;</code>.   2. Cr\u00e9ez un <code>std::vector&lt;int&gt;</code> vide.   3. Utilisez une boucle <code>while</code> pour demander des nombres \u00e0 l'utilisateur. Ajoutez-les au vecteur avec <code>.push_back()</code>. Arr\u00eatez quand il tape -1.   4. Appelez votre fonction <code>calculer_somme</code> (celle avec le <code>std::span</code> de l'exercice 16) en lui passant ce vecteur.   Observation : Notez que le <code>span</code> accepte aussi bien le tableau brut (Ex 16) que le vecteur (Ex 18).</p>"},{"location":"notes/semaine_1/","title":"Notes de la Semaine 1","text":""},{"location":"notes/semaine_1/#sujets-abordes","title":"Sujets Abord\u00e9s","text":"<ul> <li>Pr\u00e9sentation du cours</li> <li>Environnement de d\u00e9veloppement C++ (IDE, compilateur)</li> <li>Concepts de base du C++ (variables, types, op\u00e9rateurs)</li> </ul>"},{"location":"notes/semaine_1/#exercices-et-laboratoires","title":"Exercices et Laboratoires","text":"<ul> <li>Configuration de l'environnement</li> <li>Premiers programmes \"Hello World\"</li> </ul>"},{"location":"notes/semaine_1/#remarques","title":"Remarques","text":"<ul> <li>Assurez-vous que votre environnement de d\u00e9veloppement est fonctionnel avant le prochain cours.</li> <li>Consultez le plan de cours pour les lectures et pr\u00e9parations.</li> </ul>"},{"location":"notes/semaine_1/#la-fonction-main-en-c","title":"La fonction <code>main()</code> en C++","text":"<p>La fonction <code>main()</code> est le point d'entr\u00e9e de chaque programme C++. C'est l\u00e0 que l'ex\u00e9cution de votre code commence.</p>"},{"location":"notes/semaine_1/#main-sans-arguments","title":"<code>main()</code> sans arguments","text":"<p>La forme la plus simple de <code>main()</code> ne prend pas d'arguments. <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Bonjour !\" &lt;&lt; std::endl;\n    return 0; // Indique que le programme s'est ex\u00e9cut\u00e9 avec succ\u00e8s\n}\n</code></pre></p>"},{"location":"notes/semaine_1/#return-int-vs-void-main-c","title":"<code>return int</code> vs <code>void Main</code> (C#)","text":"<p>Contrairement \u00e0 C# o\u00f9 la fonction <code>Main</code> peut \u00eatre <code>void</code>, la fonction <code>main()</code> en C++ doit retourner un <code>int</code>.</p> <ul> <li><code>return 0;</code> : Conventionnellement, un retour de <code>0</code> indique que le programme s'est termin\u00e9 avec succ\u00e8s.</li> <li><code>return un_nombre_non_nul;</code> : Un retour diff\u00e9rent de <code>0</code> (ex: <code>1</code>) indique qu'une erreur s'est produite. Ce code peut \u00eatre utilis\u00e9 par d'autres programmes ou scripts pour d\u00e9tecter un probl\u00e8me.</li> </ul>"},{"location":"notes/semaine_1/#entrees-et-sorties-en-c-avec-iostream","title":"Entr\u00e9es et Sorties en C++ avec <code>iostream</code>","text":"<p>La m\u00e9thode standard et s\u00e9curitaire pour g\u00e9rer les entr\u00e9es et sorties en C++ est la biblioth\u00e8que <code>&lt;iostream&gt;</code>. Elle utilise des flux (<code>streams</code>) pour envoyer ou recevoir des donn\u00e9es.</p> <ul> <li><code>std::cout</code> : Flux de sortie standard (g\u00e9n\u00e9ralement la console).</li> <li><code>std::cin</code> : Flux d'entr\u00e9e standard (g\u00e9n\u00e9ralement le clavier).</li> <li><code>std::endl</code> : Ins\u00e8re un retour \u00e0 la ligne (<code>\\n</code>) et vide le tampon de sortie.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string nom;\n    std::cout &lt;&lt; \"Entrez votre nom : \";\n    std::cin &gt;&gt; nom;\n\n    std::cout &lt;&lt; \"Bonjour \" &lt;&lt; nom &lt;&lt; \" !\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1/#piege-n1-melanger-cin-et-getline","title":"Pi\u00e8ge n\u00b01 : M\u00e9langer <code>cin &gt;&gt;</code> et <code>getline</code>","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> lit les donn\u00e9es jusqu'au premier espace blanc (espace, tabulation, retour \u00e0 la ligne). Le reste, y compris le <code>\\n</code> que vous tapez avec <code>Entr\u00e9e</code>, reste dans le buffer (tampon) d'entr\u00e9e.</p> <p>\u274c Code probl\u00e9matique : <pre><code>int age;\nstd::string nom_complet;\n\nstd::cout &lt;&lt; \"Entrez votre age : \";\nstd::cin &gt;&gt; age; // L'utilisateur tape \"25\" puis \"Entr\u00e9e\".\n                 // \"25\" est lu, mais \"\\n\" reste dans le buffer.\n\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // getline() voit le \"\\n\" restant et croit\n                                     // que l'utilisateur a d\u00e9j\u00e0 entr\u00e9 une ligne vide.\n                                     // Il ne demande pas d'input.\n\nstd::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;\n// Affiche : Age: 25, Nom: ''\n</code></pre></p> <p>\u2705 Solution : Vider le buffer avant <code>getline</code> On utilise <code>std::cin.ignore()</code> pour ignorer les caract\u00e8res restants dans le buffer, notamment le <code>\\n</code>.</p> <pre><code>// ... apr\u00e8s std::cin &gt;&gt; age;\nstd::cin.ignore(); // Ignore LE caract\u00e8re suivant. Soit le \\n restant\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // Fonctionne comme pr\u00e9vu\n</code></pre>"},{"location":"notes/semaine_1/#piege-n2-erreur-de-type-lettres-pour-un-nombre","title":"Pi\u00e8ge n\u00b02 : Erreur de type (lettres pour un nombre)","text":"<p>Si l'utilisateur entre des lettres alors que <code>std::cin &gt;&gt;</code> s'attend \u00e0 un <code>int</code>, le flux <code>cin</code> entre en \u00e9tat d'erreur (<code>failbit</code>). Toute tentative de lecture ult\u00e9rieure \u00e9chouera tant que l'erreur n'est pas corrig\u00e9e et le buffer vid\u00e9.</p> <p>Pour g\u00e9rer robustement les erreurs de saisie :</p> <ol> <li>V\u00e9rifier l'\u00e9tat de <code>cin</code> : Boucler tant que la lecture \u00e9choue.</li> <li>Nettoyer les indicateurs d'erreur : <code>std::cin.clear()</code> r\u00e9initialise l'\u00e9tat de <code>cin</code>.</li> <li>Vider le buffer : <code>std::cin.ignore(...)</code> jette le contenu invalide.</li> </ol> <p>\u2705 Solution robuste :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt; // Requis pour numeric_limits\n\nint main() {\n    int age = 0;\n\n    // Boucle tant que l'entr\u00e9e est invalide\n    while (true) {\n        std::cout &lt;&lt; \"Veuillez entrer votre age : \";\n        std::cin &gt;&gt; age;\n\n        if (std::cin.good()) {\n            // La saisie est un nombre valide, on peut sortir de la boucle.\n            break; \n        }\n\n        // Si on arrive ici, la saisie a \u00e9chou\u00e9.\n        std::cout &lt;&lt; \"Erreur : Veuillez entrer un nombre valide.\" &lt;&lt; std::endl;\n\n        // 1. Nettoyer l'indicateur d'erreur de cin\n        std::cin.clear();\n\n        // 2. Vider le buffer d'entr\u00e9e\n        // On ignore tous les caract\u00e8res jusqu'\u00e0 la prochaine fin de ligne '\\n'.\n        // C'est la mani\u00e8re idiomatique et s\u00e9curitaire de le faire.\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    }\n\n    std::cout &lt;&lt; \"Vous avez \" &lt;&lt; age &lt;&lt; \" ans.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Attention aux Nombres Magiques</p> <p>Vous verrez parfois <code>std::cin.ignore(10000, '\\n');</code>. C'est une mauvaise pratique. On suppose arbitrairement que l'utilisateur ne tapera pas plus de 10 000 caract\u00e8res invalides. </p> <p>La m\u00e9thode correcte, <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');</code>, est la fa\u00e7on C++ standard de dire \"ignorer autant de caract\u00e8res que n\u00e9cessaire\". Elle ne repose sur aucune supposition.</p>"},{"location":"notes/semaine_1_1/","title":"Types de Donn\u00e9es","text":"<p>Voici la liste exhaustive des types fondamentaux \u00e0 utiliser en C++.</p>"},{"location":"notes/semaine_1_1/#1-types-entiers-et-logiques","title":"1. Types Entiers et Logiques","text":"<p>Utilis\u00e9s pour compter, indexer ou g\u00e9rer des \u00e9tats.</p> Type Taille Description Plage de Valeurs (Min / Max) <code>bool</code> 1 octet Logique pure <code>true</code> (1) ou <code>false</code> (0) <code>int</code> 4 octets Entier standard (Sign\u00e9) -2 147 483 648 \u00e0 +2 147 483 647 <code>unsigned int</code> 4 octets Entier positif 0 \u00e0 4 294 967 295 <code>long long</code> 8 octets Grand entier (Sign\u00e9) -9 Quintillions \u00e0 +9 Quintillions <code>unsigned long long</code> 8 octets Grand entier positif 0 \u00e0 18 Quintillions (approx)"},{"location":"notes/semaine_1_1/#2-types-de-caracteres-et-octets","title":"2. Types de Caract\u00e8res et Octets","text":"<p>Tous ces types font 1 octet (8 bits), mais leur usage est diff\u00e9rent.</p> Type Sign\u00e9 ? Usage Recommand\u00e9 Plage de Valeurs <code>char</code> Variable* Texte ASCII standard. (Lettres simples). -128 \u00e0 127 OU 0 \u00e0 255 <code>signed char</code> \u2705 Oui Petit entier. Pour \u00e9conomiser la m\u00e9moire. -128 \u00e0 127 <code>unsigned char</code> \u274c Non Compatible binaire. Valeurs num\u00e9riques 0-255. 0 \u00e0 255 <code>char8_t</code> \u274c Non Texte UTF-8 (C++20). Cha\u00eenes <code>u8\"...\"</code>. 0 \u00e0 255 <code>std::byte</code> N/A Donn\u00e9es brutes. Pas de maths possibles. Bits (0x00 \u00e0 0xFF) <p>* Le type <code>char</code> peut \u00eatre sign\u00e9 ou non selon le syst\u00e8me d'exploitation. Ne l'utilisez pas pour des calculs.</p>"},{"location":"notes/semaine_1_1/#3-types-a-virgule-flottante","title":"3. Types \u00e0 Virgule Flottante","text":"<p>Utilis\u00e9s pour les nombres \u00e0 d\u00e9cimales (r\u00e9els).</p> Type Taille Pr\u00e9cision Plage de Valeurs <code>double</code> 8 octets Standard (~15 chiffres) \u00b1 2.23e-308 \u00e0 \u00b1 1.80e308 <code>float</code> 4 octets Faible (~7 chiffres) \u00b1 1.18e-38 \u00e0 \u00b1 3.4e38"},{"location":"notes/semaine_1_1/#4-initialisation-des-variables","title":"4. Initialisation des Variables","text":"<p>En C++ moderne (C++20), privil\u00e9giez l'initialisation avec des accolades <code>{}</code> pour \u00e9viter les conversions dangereuses.</p> <p>Syntaxe : <code>Type nom { valeur };</code></p> Exemple Correct Pourquoi ? <code>int age { 25 };</code> Initialise <code>age</code> \u00e0 25. <code>double prix { 19.99 };</code> Initialise <code>prix</code> \u00e0 19.99. <code>unsigned int id { 0 };</code> Initialise <code>id</code> \u00e0 0. <code>std::vector&lt;int&gt; v {};</code> Initialise un tableau vide. <p>Protection contre les erreurs : L'initialisation <code>{}</code> emp\u00eache de mettre accidentellement un nombre \u00e0 virgule dans un entier.</p> <pre><code>int a = 3.9;  // \u26a0\ufe0f DANGEREUX : Compile, mais 'a' vaut 3 (perte de 0.9).\nint b { 3.9 }; // \ud83d\uded1 ERREUR : Le compilateur refuse de perdre des donn\u00e9es.\n</code></pre>"},{"location":"notes/semaine_1_1/#manipulation-des-chaines-de-caracteres-strings","title":"Manipulation des Cha\u00eenes de Caract\u00e8res (Strings)","text":"<p>En C++, le texte ne se g\u00e8re pas avec des tableaux de <code>char</code> (trop dangereux), mais avec la classe standard <code>std::string</code>.</p>"},{"location":"notes/semaine_1_1/#1-la-classe-stdstring-le-standard","title":"1. La Classe <code>std::string</code> (Le Standard)","text":"<p>Pour utiliser les cha\u00eenes, vous devez inclure <code>&lt;string&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt; // Indispensable\n\nint main() {\n    // 1. D\u00e9claration et Initialisation\n    std::string nom { \"Mario\" };\n    std::string salutation { \"Bonjour\" };\n\n    // 2. Concat\u00e9nation (Coller des morceaux)\n    // On utilise simplement le signe '+'\n    std::string message = salutation + \" \" + nom + \" !\"; \n    // R\u00e9sultat : \"Bonjour Mario !\"\n\n    // 3. Acc\u00e8s aux lettres\n    char premiereLettre = nom[0]; // 'M'\n    nom[0] = 'W'; // Mario devient Wario\n}\n</code></pre>"},{"location":"notes/semaine_1_1/#2-operations-courantes","title":"2. Op\u00e9rations Courantes","text":"<p>Voici les m\u00e9thodes que vous utiliserez dans 90% des cas avec <code>std::string</code>.</p> Op\u00e9ration M\u00e9thode Exemple R\u00e9sultat Longueur <code>.size()</code> ou <code>.length()</code> <code>nom.size()</code> <code>5</code> (nombre d'octets) Vide ? <code>.empty()</code> <code>nom.empty()</code> <code>false</code> (si contient du texte) Vider <code>.clear()</code> <code>nom.clear()</code> La cha\u00eene devient vide <code>\"\"</code> Ajouter <code>+=</code> ou <code>.append()</code> <code>nom += \" Bros\"</code> <code>\"Mario Bros\"</code> Comparer <code>==</code> ou <code>!=</code> <code>nom == \"Luigi\"</code> <code>false</code> Trouver <code>.find(\"texte\")</code> <code>msg.find(\"jour\")</code> Retourne l'index (position) ou <code>std::string::npos</code> si absent. Sous-cha\u00eene <code>.substr(pos, len)</code> <code>msg.substr(0, 3)</code> Extrait une partie du texte (ex: les 3 premi\u00e8res lettres)."},{"location":"notes/semaine_1_1/#le-casse-tete-des-accents","title":"\u26a0\ufe0f Le Casse-t\u00eate des Accents","text":"<p>G\u00e9rer les accents en C++ est notoirement complexe (un vrai \"bordel\") car le type <code>std::string</code> a \u00e9t\u00e9 con\u00e7u \u00e0 une \u00e9poque o\u00f9 l'informatique ne parlait qu'anglais. Pour C++, une cha\u00eene n'est pas une liste de lettres, c'est une liste d'octets (des nombres).</p> <p>Le probl\u00e8me survient avec l'encodage moderne (UTF-8) : * Une lettre simple (<code>a</code>) p\u00e8se 1 octet. * Une lettre accentu\u00e9e (<code>\u00e9</code>) p\u00e8se 2 octets (voire plus).</p> <p>Cons\u00e9quence : Toutes vos intuitions sont fausses. Si vous prenez le mot <code>\"\u00e9t\u00e9\"</code>, vous voyez 3 lettres. Mais C++ voit 5 octets (2 pour le \u00e9, 1 pour le t, 2 pour le \u00e9). R\u00e9sultat : <code>.size()</code> renvoie 5 au lieu de 3, et si vous essayez d'acc\u00e9der \u00e0 la deuxi\u00e8me lettre via <code>mot[1]</code>, vous tombez au milieu du premier '\u00e9', ce qui produit un caract\u00e8re bugg\u00e9 (corrompu).</p>"},{"location":"notes/semaine_1_1/#stdwstring-standard-ou-pas","title":"std::wstring : Standard ou pas ?","text":"<p>R\u00e9ponse courte : OUI. <code>std::wstring</code> est un type officiel du langage C++. Il est disponible partout (Windows, Mac, Linux, Android) via <code>#include &lt;string&gt;</code>.</p>"},{"location":"notes/semaine_1_1/#le-grand-debat-faut-il-lutiliser","title":"Le Grand D\u00e9bat : \"Faut-il l'utiliser ?\"","text":"<p>Bien que standard, ce type divise la communaut\u00e9 des d\u00e9veloppeurs pour une raison technique pr\u00e9cise.</p>"},{"location":"notes/semaine_1_1/#1-le-probleme-de-portabilite","title":"1. Le Probl\u00e8me de Portabilit\u00e9","text":"<p>Le type <code>char</code> fait toujours 1 octet. Mais le type <code>wchar_t</code> (utilis\u00e9 par wstring) change de taille selon l'ordinateur !</p> Syst\u00e8me Taille de <code>wchar_t</code> Cons\u00e9quence Windows 2 octets Utilise l'encodage UTF-16 (comme Java ou C#). Linux / macOS 4 octets Utilise l'encodage UTF-32 (Universel). <p>Pourquoi est-ce g\u00eanant ? Si vous \u00e9crivez un fichier binaire avec des <code>wstring</code> sur Windows et que vous l'envoyez \u00e0 un ami sous Linux, il ne pourra pas le relire correctement car les lettres n'ont pas la m\u00eame taille en m\u00e9moire.</p>"},{"location":"notes/semaine_1_1/#2-le-verdict-quand-lutiliser","title":"2. Le Verdict : Quand l'utiliser ?","text":"Cas d'usage Verdict Pourquoi ? Projets \u00c9tudiants / Apprentissage \u2705 RECOMMAND\u00c9 C'est le moyen le plus simple de manipuler des accents sans librairie externe. D\u00e9veloppement Windows natif \u2705 STANDARD Toute l'API Windows fonctionne avec des <code>wstring</code>. C'est la norme chez Microsoft. Logiciel Web / R\u00e9seau \u274c D\u00c9CONSEILL\u00c9 Le web parle UTF-8 (<code>std::string</code>). Convertir sans cesse est lourd. Biblioth\u00e8ques portables \u274c D\u00c9CONSEILL\u00c9 \u00c0 cause de la diff\u00e9rence de taille (2 vs 4 octets), on pr\u00e9f\u00e8re <code>std::string</code> ou <code>char32_t</code>. <p>En r\u00e9sum\u00e9</p> <p>Pour vos besoins actuels (g\u00e9rer des cha\u00eenes simplement, avoir le bon nombre de lettres, afficher des accents), <code>std::wstring</code> est une solution valid\u00e9e et standard.</p> <p>Sachez juste que si un jour vous cr\u00e9ez le \"nouveau Google\", vous passerez probablement \u00e0 une gestion plus stricte avec UTF-8.</p>"},{"location":"notes/semaine_1_1/#3-le-hack-pour-gerer-les-accents-avec-une-bibliotheque","title":"3. Le \"hack\" pour g\u00e9rer les accents, avec une biblioth\u00e8que","text":"<p>Il existe des biblioth\u00e8ques pour g\u00e9rer l'utf8 qu'on peut ajouter au programme. Ceci \u00e9tant dit, n'oubliez pas que plusieurs logiciels ont encore du mal \u00e0 g\u00e9rer l'affichage  de symboles qui ne sont pas strictement \"natif anglais\" <pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include \"utf8.h\" // Librairie externe l\u00e9g\u00e8re\n\nint main() {\n    std::string texte = u8\"No\u00ebl\"; // Stockage standard (5 octets)\n\n    // 1. Compter les lettres (Distance)\n    auto distance = utf8::distance(texte.begin(), texte.end());\n    std::cout &lt;&lt; \"Lettres : \" &lt;&lt; distance &lt;&lt; \"\\n\"; // Affiche 4\n\n    // 2. Ajouter du texte (Append) - S\u00fbr car std::string g\u00e8re les octets\n    texte += u8\" en \u00e9t\u00e9\"; \n\n    return 0;\n}    \n</code></pre></p>"},{"location":"notes/semaine_1_1_2/","title":"4. Les Tableaux Bruts (Static Arrays)","text":"<p>C'est la forme la plus primitive de stockage. Un tableau brut est une suite de cases m\u00e9moire coll\u00e9es les unes aux autres.</p>"},{"location":"notes/semaine_1_1_2/#declaration-et-memoire","title":"D\u00e9claration et M\u00e9moire","text":"<p>Il faut imp\u00e9rativement conna\u00eetre la taille \u00e0 la compilation. Une fois cr\u00e9\u00e9, le tableau ne peut jamais changer de taille.</p> <pre><code>// Syntaxe : Type nom[Taille];\n\nint scores[5]; // R\u00e9serve 5 entiers (valeurs al\u00e9atoires si non initialis\u00e9 !)\n</code></pre>"},{"location":"notes/semaine_1_1_2/#initialisation","title":"Initialisation","text":"<p>On utilise les accolades <code>{}</code>.</p> Syntaxe R\u00e9sultat <code>int t[3] { 10, 20, 30 };</code> Tableau rempli : <code>[10, 20, 30]</code> <code>int t[5] { 10, 20 };</code> Reste rempli de z\u00e9ros : <code>[10, 20, 0, 0, 0]</code> <code>int t[10] {};</code> Tout \u00e0 z\u00e9ro : <code>[0, 0, ... 0]</code> (Recommand\u00e9) <code>int t[] { 1, 2, 3 };</code> Taille auto-d\u00e9duite (ici 3 cases)."},{"location":"notes/semaine_1_1_2/#acces-et-danger","title":"Acc\u00e8s et Danger \ud83d\udc80","text":"<p>On acc\u00e8de aux \u00e9l\u00e9ments via l'index [i] (commence \u00e0 0). <pre><code>scores[0] = 100; // Premi\u00e8re case\nscores[4] = 50;  // Derni\u00e8re case (pour taille 5)\n</code></pre></p> <p>Pas de garde-fou ! C++ ne v\u00e9rifie pas si vous d\u00e9passez le tableau.</p> <pre><code>int t[3] {1, 2, 3};\nt[100] = 99; // \ud83d\udca5 \u00c9crit n'importe o\u00f9 dans la RAM.\n             // Peut faire crasher le programme ou corrompre d'autres variables.\n</code></pre>"},{"location":"notes/semaine_1_1_2/#tableaux-bruts-et-fonctions","title":"Tableaux Bruts et Fonctions","text":"<p>C'est ici que \u00e7a se corse. En C++, on ne peut pas passer un tableau brut \"en entier\" \u00e0 une fonction comme on passerait un entier.</p>"},{"location":"notes/semaine_1_1_2/#le-piege-du-decay-degenerescence","title":"Le Pi\u00e8ge du \"Decay\" (D\u00e9g\u00e9n\u00e9rescence)","text":"<p>Quand vous passez un tableau \u00e0 une fonction, il \"perd\" son identit\u00e9 de tableau et se transforme en simple adresse m\u00e9moire (pointeur) vers la premi\u00e8re case.</p> <p>Cons\u00e9quence grave</p> <p>La fonction ne conna\u00eet pas la taille du tableau ! Le lien avec la taille d'origine est perdu. La fonction re\u00e7oit juste l'adresse du d\u00e9but, mais elle ne sait pas o\u00f9 \u00e7a s'arr\u00eate.</p>"},{"location":"notes/semaine_1_1_2/#la-bonne-facon-de-faire","title":"La Bonne Fa\u00e7on de Faire","text":"<p>Pour compenser cette perte d'information, vous devez toujours envoyer la taille du tableau manuellement dans un deuxi\u00e8me param\u00e8tre.</p> <pre><code>// \u274c MAUVAIS : La fonction ne sait pas quand s'arr\u00eater\nvoid afficher(int tab[]) { \n    // Impossible de savoir combien d'\u00e9l\u00e9ments il y a ici !\n}\n\n// \u2705 BON : On passe le tableau ET sa taille\nvoid afficher(int tab[], int taille) {\n    for (int i = 0; i &lt; taille; i++) {\n        std::cout &lt;&lt; tab[i] &lt;&lt; \" \";\n    }\n}\n\nint main() {\n    int mesNotes[4] { 10, 15, 20, 12 };\n\n    // Appel : On donne le tableau et le nombre 4\n    afficher(mesNotes, 4); \n}\n</code></pre>"},{"location":"notes/semaine_1_1_2/#problematique-au-niveau-de-la-taille","title":"Probl\u00e9matique au niveau de la taille","text":"<p>La probl\u00e9matique se situe au niveau du \"4\" comment faire pour trouver la taille du tableau.  </p>"},{"location":"notes/semaine_1_1_2/#comment-trouver-la-taille-automatiquement-c17-c20","title":"Comment trouver la taille automatiquement (C++17 / C++20)","text":"<p>Plus besoin de compter \u00e0 la main ou de faire des divisions de <code>sizeof</code>. Il faut inclure <code>&lt;iterator&gt;</code> (ou <code>&lt;vector&gt;</code>/<code>&lt;array&gt;</code>).</p> Commande Version Description <code>std::size(tab)</code> C++17 Retourne la taille en non-sign\u00e9 (<code>unsigned</code>). <code>std::ssize(tab)</code> C++20 Retourne la taille en sign\u00e9 (<code>signed</code>). Recommand\u00e9 pour les boucles avec <code>int i</code>."},{"location":"notes/semaine_1_1_2/#determiner-la-taille-dun-tableau-localement","title":"D\u00e9terminer la taille d'un tableau (localement)","text":"<p>La m\u00e9thode C++20 recommand\u00e9e est <code>std::ssize()</code> (de la biblioth\u00e8que <code>&lt;iterator&gt;</code>).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nint main() {\n    int notes_cours[] {80, 85, 90, 75, 88};\n    int taille {std::ssize(notes_cours)}; \n    std::cout &lt;&lt; \"La taille du tableau est : \" &lt;&lt; taille &lt;&lt; std::endl; // Affiche 5\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_1_2/#quel-type-utiliser-pour-la-taille-analyse","title":"Quel type utiliser pour la taille ? (Analyse)","text":"<p>Le choix du type pour la <code>taille</code> est un compromis entre simplicit\u00e9, s\u00e9curit\u00e9 et portabilit\u00e9. Le fichier d'exemple ci-dessous (que vous pouvez t\u00e9l\u00e9charger et compiler) d\u00e9montre plusieurs approches.</p> Fichier d'exemple : <code>exemple_types_taille.cpp</code> <pre><code>/**\n * @file main.cpp\n * @brief Fichier d'exemple pour d\u00e9montrer les diff\u00e9rentes mani\u00e8res de passer la taille\n *        d'un tableau \u00e0 une fonction en C++, en soulignant les avantages et les risques\n *        de chaque approche.\n */\n\n#include &lt;iostream&gt;\n#include &lt;iterator&gt; // Pour std::ssize\n#include &lt;cstddef&gt;  // Pour std::ptrdiff_t\n\n\n\n/**\n * @brief APPROCHE 1 : Utilise 'int' pour la taille.\n * @note Cette version est **risqu\u00e9e** pour des applications g\u00e9n\u00e9rales. Un `int` (32 bits)\n *       est trop petit pour contenir la taille d'un tr\u00e8s grand tableau, menant \u00e0 des bogues.\n *       Pour des exercices simples, c'est souvent acceptable.\n */\nvoid afficher_moyenne_risque(const int notes[], int taille) {\n    std::cout &lt;&lt; \"[int] Appel a la fonction risquee...\" &lt;&lt; std::endl;\n}\n\n\n/**\n * @brief APPROCHE 2 : Utilise 'long long' pour la taille.\n * @note L'utilisation de `long long` est un choix simple et s\u00fbr sur la plupart des \n *       syst\u00e8mes 64-bit, car il est garanti d'\u00eatre assez grand.\n */\nvoid afficher_moyenne_long(const int notes[], long long taille) {\n    if (taille &lt;= 0) return;\n    double somme {0.0};\n    for (long long i {0}; i &lt; taille; ++i) { \n        somme += notes[i];\n    }\n    std::cout &lt;&lt; \"[long long] La moyenne est : \" &lt;&lt; somme / taille &lt;&lt; std::endl;\n}\n\n\n/**\n * @brief APPROCHE 3 : Utilise 'std::ptrdiff_t' pour la taille.\n * @note Cette version est la plus **techniquement correcte et portable**. `std::ptrdiff_t` est le \n *       type sign\u00e9 que `std::ssize` retourne. Il est garanti d'\u00eatre assez grand\n *       sur n'importe quelle plateforme.\n */\nvoid afficher_moyenne_semi_pro(const int notes[], std::ptrdiff_t taille) {\n    std::cout &lt;&lt; \"[ptrdiff_t] Appel a la fonction semi-pro...\" &lt;&lt; std::endl;\n}\n\n/**\n * @brief APPROCHE 4 : Utilise un template de fonction (C++20).\n * @note L'utilisation de `auto` dans un param\u00e8tre est une fonctionnalit\u00e9 C++20\n *       qui cr\u00e9e un \"template\". C'est tr\u00e8s flexible, mais moins explicite.\n */\nvoid afficher_moyenne_moderne(const int notes[], auto taille)\n{\n    std::cout &lt;&lt; \"[auto] Appel moderne qui redirige vers la version 'long long'.\" &lt;&lt; std::endl;\n    afficher_moyenne_long(notes, taille);\n}\n\nint main() {\n    int notes_cours[] {80, 85, 90, 75, 88};\n\n    // On utilise std::ssize (C++20) pour obtenir la taille de mani\u00e8re s\u00fbre.\n    // std::ssize retourne un type sign\u00e9 (std::ptrdiff_t).\n    auto taille_notes { std::ssize(notes_cours) };\n\n    std::cout &lt;&lt; \"--- Affichage des moyennes ---\" &lt;&lt; std::endl;\n\n    // Appel \u00e0 la version `long long`. C'est un bon compromis entre simplicit\u00e9 et s\u00e9curit\u00e9.\n    afficher_moyenne_long(notes_cours, taille_notes);\n\n    // Appel \u00e0 la version C++20 avec `auto`.\n    afficher_moyenne_moderne(notes_cours, taille_notes);\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_1_2/#le-bordel-quoi","title":"Le bordel quoi !?","text":"<p>En effet. Ceci \u00e9tant dit !</p> <p>Il existe une solution qui modernise le c++ et qui va nous \u00eatre utile avec plein d'autres cas. On utilise std::span qui permet de conserver la taille du tableau au travers du passage de param\u00e8tre. La variable contient \"grosso-modo\" la taille et le pointeur de d\u00e9but du tableau.</p> <p>C'est un pointeur \"gras\" </p> <pre><code>// Repr\u00e9sentation mentale simplifi\u00e9e\ntemplate &lt;typename T&gt;\nstruct Span {\n    T* pointeur;   // L'adresse du d\u00e9but des donn\u00e9es (8 octets sur 64-bit)\n    size_t taille; // Le nombre d'\u00e9l\u00e9ments (8 octets sur 64-bit)\n};\n</code></pre> <p>Avantage, le span peut \u00eatre utilis\u00e9 avec des tableaux standards vanille, des array de la biblioth\u00e8que standard et des vectors</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;span&gt;   // \ud83d\udc48 Obligatoire (C++20)\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\n// 1. La fonction prend un \"span\" (une vue)\n// const int : on lit seulement (lecture seule)\nvoid afficher(std::span&lt;const int&gt; donnees) {\n    std::cout &lt;&lt; \"[ \";\n    // Le span conna\u00eet sa taille et permet le foreach !\n    for (int valeur : donnees) {\n        std::cout &lt;&lt; valeur &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"] (Taille: \" &lt;&lt; donnees.size() &lt;&lt; \")\\n\";\n}\n\nint main() {\n    // Cas A : Tableau Brut (C-Style)\n    int tabC[] { 1, 2, 3 };\n\n    // Cas B : std::vector (Dynamique)\n    std::vector&lt;int&gt; vec { 10, 20, 30, 40 };\n\n    // Cas C : std::array (Fixe moderne)\n    std::array&lt;int, 2&gt; arr { 99, 100 };\n\n    // \u2728 MAGIE : La m\u00eame fonction accepte TOUT !\n    afficher(tabC); // D\u00e9duit automatiquement la taille (3)\n    afficher(vec);  // Convertit automatiquement\n    afficher(arr);  // Convertit automatiquement\n\n    return 0;\n}\n</code></pre> <p>Conclusion Finale : La R\u00e8gle d'Or (C++20)</p> <ol> <li> <p>Pour apprendre (Exercices simples) :      Passer le tableau et sa taille s\u00e9par\u00e9ment (<code>int* tab, int taille</code>) reste une bonne m\u00e9thode p\u00e9dagogique pour comprendre la m\u00e9moire.</p> </li> <li> <p>Pour le \"Vrai Monde\" (Professionnel) :     Utilisez <code>std::span</code>. C'est le standard moderne qui remplace toutes les anciennes m\u00e9thodes.</p> <ul> <li>\u274c Plus besoin de <code>void f(int* t, int size)</code></li> <li>\u274c Plus besoin de <code>void f(const std::vector&lt;int&gt;&amp; v)</code></li> <li>\u2705 Utilisez <code>void f(std::span&lt;int&gt; data)</code></li> </ul> </li> </ol>"},{"location":"notes/semaine_1_2/","title":"Entr\u00e9es Utilisateur avec <code>std::cin</code>","text":"<p>Cette section explique comment r\u00e9cup\u00e9rer des informations de l'utilisateur via la console en utilisant la biblioth\u00e8que <code>&lt;iostream&gt;</code>.</p>"},{"location":"notes/semaine_1_2/#1-les-bases-flux-et-buffer","title":"1. Les Bases : Flux et Buffer","text":"<p>En C++, les entr\u00e9es clavier ne vont pas directement dans vos variables. Elles passent par un flux d'entr\u00e9e (<code>std::cin</code>) et une zone d'attente appel\u00e9e le Buffer.</p> <ul> <li><code>std::cin</code> : Le flux qui lit le clavier.</li> <li>Buffer : Une salle d'attente o\u00f9 les caract\u00e8res s'empilent quand vous tapez.</li> <li><code>std::endl</code> : Pour l'affichage (<code>cout</code>), cela fait un retour \u00e0 la ligne (<code>\\n</code>) et force l'affichage imm\u00e9diat.</li> </ul>"},{"location":"notes/semaine_1_2/#2-les-deux-facons-de-lire","title":"2. Les Deux Fa\u00e7ons de Lire","text":"<p>Il existe deux outils principaux selon ce que vous voulez lire.</p>"},{"location":"notes/semaine_1_2/#a-lire-un-mot-ou-un-nombre","title":"A. Lire un mot ou un nombre (<code>&gt;&gt;</code>)","text":"<p>L'op\u00e9rateur d'extraction <code>&gt;&gt;</code> lit des donn\u00e9es jusqu'au premier \"espace blanc\" (Espace, Tabulation, ou Entr\u00e9e).</p> <pre><code>int age;\nstd::cin &gt;&gt; age; \n// Si je tape \"25\" + Entr\u00e9e :\n// -&gt; '25' va dans la variable.\n// -&gt; '\\n' (Entr\u00e9e) RESTE dans le buffer.\n</code></pre>"},{"location":"notes/semaine_1_2/#b-lire-une-ligne-complete-stdgetline","title":"B. Lire une ligne compl\u00e8te (<code>std::getline</code>)","text":"<p>Cette fonction lit tout jusqu'au retour \u00e0 la ligne (n). Elle est indispensable pour lire des phrases avec des espaces.  </p> <pre><code>std::string nom;\nstd::getline(std::cin, nom);\n// Elle consomme le texte ET le '\\n', puis jette le '\\n'.\n// Le buffer est propre apr\u00e8s son passage.\n</code></pre>"},{"location":"notes/semaine_1_2/#3-le-piege-classique-melanger-et-getline","title":"3. Le Pi\u00e8ge Classique : M\u00e9langer <code>&gt;&gt;</code> et <code>getline</code> \u26a0\ufe0f","text":"<p>C'est l'erreur n\u00b01 des d\u00e9butants en C++.</p>"},{"location":"notes/semaine_1_2/#le-scenario","title":"Le Sc\u00e9nario","text":"<ol> <li>Vous demandez un \u00e2ge avec <code>std::cin &gt;&gt; age</code>.</li> <li>L'utilisateur tape <code>25</code> et appuie sur <code>Entr\u00e9e</code>.</li> <li><code>cin</code> extrait le nombre <code>25</code>.</li> <li>\ud83d\uded1 Probl\u00e8me : Le caract\u00e8re de saut de ligne <code>\\n</code> (correspondant \u00e0 la touche Entr\u00e9e) reste dans le buffer.</li> <li>Vous appelez <code>std::getline</code> pour demander le nom.</li> <li><code>getline</code> regarde le buffer, voit le <code>\\n</code> qui tra\u00eene imm\u00e9diatement, pense que l'utilisateur a entr\u00e9 une ligne vide, et s'arr\u00eate.</li> </ol> <p>R\u00e9sultat : Le programme \"saute\" la demande du nom et ne vous laisse rien \u00e9crire.</p> <p>Exemple du Code Probl\u00e9matique</p> <pre><code>int age;\nstd::string nom;\n\nstd::cout &lt;&lt; \"Age : \";\nstd::cin &gt;&gt; age; \n// L'utilisateur tape \"25\" + \"Entr\u00e9e\". \n// Le '\\n' reste en attente dans la m\u00e9moire.\n\nstd::cout &lt;&lt; \"Nom : \";\n// \u274c BUG : getline lit le '\\n' restant et s'arr\u00eate tout de suite.\nstd::getline(std::cin, nom); \n</code></pre>"},{"location":"notes/semaine_1_2/#la-solution-nettoyer-le-buffer","title":"La Solution : Nettoyer le Buffer","text":"<p>Pour corriger cela, il faut ignorer le reste de la ligne (le <code>\\n</code> restant) apr\u00e8s chaque <code>cin &gt;&gt;</code> si vous comptez utiliser <code>getline</code> ensuite.</p> <p>La Correction</p> <p>Ajoutez cette ligne magique entre les deux lectures :</p> <pre><code>#include &lt;limits&gt; // N\u00e9cessaire pour numeric_limits\n\n// ...\nstd::cin &gt;&gt; age;\n\n// \ud83e\uddf9 NETTOYAGE : On ignore tout jusqu'au prochain retour \u00e0 la ligne\nstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\nstd::cout &lt;&lt; \"Nom : \";\nstd::getline(std::cin, nom); // \u2705 Fonctionne parfaitement\n</code></pre> <p>Pourquoi pas juste <code>std::cin.ignore()</code> ?</p> <p><code>std::cin.ignore()</code> tout seul n'ignore qu'un seul caract\u00e8re.</p> <p>Si l'utilisateur a tap\u00e9 <code>25 abc</code> puis <code>Entr\u00e9e</code>, il restera encore <code>bc</code> et <code>\\n</code> dans le buffer.</p> <p>La version avec <code>numeric_limits</code> est la version \"blind\u00e9e\" : elle demande d'ignorer le nombre maximum de caract\u00e8res possible jusqu'\u00e0 trouver un retour \u00e0 la ligne. C'est la seule fa\u00e7on de garantir un buffer vide.</p>"},{"location":"notes/semaine_1_2/#4-gestion-des-erreurs-de-saisie","title":"4. Gestion des Erreurs de Saisie","text":"<p>Que se passe-t-il si l'utilisateur fait n'importe quoi alors que vous attendez un nombre ?</p>"},{"location":"notes/semaine_1_2/#cas-a-lecture-partielle-45abc","title":"Cas A : Lecture Partielle (<code>45abc</code>)","text":"<p>Si on demande un <code>int</code> et que l'utilisateur tape <code>45abc</code> :</p> <ol> <li><code>cin</code> lit <code>45</code> (\u2705 Succ\u00e8s).</li> <li><code>cin</code> s'arr\u00eate au <code>a</code> (car ce n'est pas un chiffre).</li> <li>R\u00e9sultat : La variable vaut <code>45</code>.</li> <li>\u26a0\ufe0f Probl\u00e8me : La cha\u00eene <code>abc</code> reste dans le buffer pour la prochaine lecture. Cela causera probablement une erreur au prochain <code>cin</code>.</li> </ol>"},{"location":"notes/semaine_1_2/#cas-b-echec-total-abc45","title":"Cas B : \u00c9chec Total (<code>abc45</code>)","text":"<p>Si on demande un <code>int</code> et que l'utilisateur tape <code>abc45</code> :</p> <ol> <li><code>cin</code> voit <code>a</code> tout de suite.</li> <li>Il se met imm\u00e9diatement en mode Erreur (le drapeau <code>failbit</code> s'active).</li> <li>R\u00e9sultat : La variable vaut 0 (ou reste inchang\u00e9e).</li> <li>\ud83d\uded1 Danger : Tant que <code>cin</code> est en erreur (\"fail state\"), il refusera de lire quoi que ce soit d'autre. Il est \"verrouill\u00e9\".</li> </ol>"},{"location":"notes/semaine_1_2/#la-solution-robuste-pattern-a-retenir","title":"La Solution Robuste (Pattern \u00e0 retenir)","text":"<p>Pour un programme solide, on utilise une boucle <code>while</code> qui v\u00e9rifie l'\u00e9tat de <code>cin</code> apr\u00e8s chaque tentative.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main() {\n    int age = 0;\n\n    std::cout &lt;&lt; \"Entrez votre age : \";\n\n    // 1. La boucle g\u00e8re L'\u00c9CHEC (Type incorrect, ex: \"abc\")\n    while (!(std::cin &gt;&gt; age)) { \n        std::cout &lt;&lt; \"Erreur, ce n'est pas un nombre. Recommencez : \";\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    }\n\n    // 2. IMPORTANT : On g\u00e8re le SUCC\u00c8S (Nettoyage final)\n    // On vide le buffer pour enlever le '\\n' restant ou les d\u00e9chets (ex: \"25abc\")\n    // afin que la suite du programme (ex: un futur getline) fonctionne.\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::cout &lt;&lt; \"Age valide : \" &lt;&lt; age &lt;&lt; \"\\n\";\n\n    // Ici, le buffer est propre, pr\u00eat pour un getline !\n}\n</code></pre>"},{"location":"notes/semaine_1_2/#resume-des-commandes-de-nettoyage","title":"R\u00e9sum\u00e9 des Commandes de Nettoyage","text":"<p>Ces deux commandes fonctionnent souvent en duo dans une gestion d'erreur robuste.</p> Commande R\u00f4le <code>std::cin.clear()</code> R\u00e9parer. R\u00e9initialise les indicateurs d'erreur (comme <code>failbit</code>) pour sortir <code>cin</code> de son \u00e9tat de blocage et lui permettre de relire. <code>std::cin.ignore(MAX, '\\n')</code> Vider. Jette tout ce qui tra\u00eene encore dans le buffer (la saisie fautive + le retour \u00e0 la ligne) pour repartir sur des bases saines. <p>Note</p> <p>Dans ce tableau, <code>MAX</code> est un raccourci pour : <code>std::numeric_limits&lt;std::streamsize&gt;::max()</code>.</p>"},{"location":"notes/semaine_1_3/","title":"Les 3 Fa\u00e7ons de Passer des Param\u00e8tres","text":"<p>En C++, il y a trois mani\u00e8res de transmettre une variable \u00e0 une fonction. Choisir la bonne m\u00e9thode est essentiel pour la performance et la s\u00e9curit\u00e9 de votre code.</p>"},{"location":"notes/semaine_1_3/#1-passage-par-copie-pass-by-value","title":"1. Passage par Copie (Pass-by-Value)","text":"<p>\"Je te donne une photocopie.\"</p> <p>C'est le comportement par d\u00e9faut pour les types simples (<code>int</code>, <code>char</code>, <code>bool</code>, <code>float</code>).</p> <ul> <li>M\u00e9canisme : La fonction cr\u00e9e une nouvelle variable et copie la valeur de l'originale dedans.</li> <li>Cons\u00e9quence : Si la fonction modifie la variable, l'originale ne change pas.</li> <li>Co\u00fbt : Rapide pour les petits nombres, mais tr\u00e8s lent pour les gros objets (comme une image ou un long texte) car il faut tout dupliquer octet par octet.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nvoid copie(int x) {\n    x = 1000; // Modifie uniquement la photocopie locale\n    std::cout &lt;&lt; \"Dans la fonction : \" &lt;&lt; x &lt;&lt; \"\\n\";\n}\n\nint main() {\n    int a = 10;\n    copie(a);\n    std::cout &lt;&lt; \"Dans le main : \" &lt;&lt; a &lt;&lt; \"\\n\"; // Affiche 10 (intact)\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#2-passage-par-reference-pass-by-reference","title":"2. Passage par R\u00e9f\u00e9rence (Pass-by-Reference)","text":"<p>\"Je te donne acc\u00e8s \u00e0 mon fichier Google Doc original.\"</p> <p>On utilise le symbole <code>&amp;</code>. La fonction ne cr\u00e9e aucune nouvelle variable. Elle travaille directement sur la m\u00e9moire de l'original.</p>"},{"location":"notes/semaine_1_3/#a-reference-modifiable-type","title":"A. R\u00e9f\u00e9rence Modifiable (<code>Type&amp;</code>)","text":"<p>Utilis\u00e9 quand la fonction DOIT modifier l'original.</p> <pre><code>void modifier(int&amp; x) {\n    x = 1000; // Modifie la VRAIE variable du main\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#b-reference-constante-const-type-le-standard","title":"B. R\u00e9f\u00e9rence Constante (<code>const Type&amp;</code>) \ud83c\udf1f LE STANDARD","text":"<p>C'est la m\u00e9thode reine du C++ pour les objets complexes (<code>std::string</code>, <code>std::vector</code>...). Elle combine le meilleur des deux mondes :</p> <ol> <li>Vitesse de la r\u00e9f\u00e9rence (pas de copie).</li> <li>S\u00e9curit\u00e9 de la copie (interdiction de modifier l'original).</li> </ol> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// \"const\" + \"&amp;\" = Je regarde l'original, mais je n'ai pas le droit de toucher\nvoid afficher(const std::string&amp; texte) {\n    std::cout &lt;&lt; texte;\n\n    // \ud83d\uded1 ERREUR DE COMPILATION : \n    // texte = \"Salut\"; // Interdit ! On est en lecture seule.\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#3-passage-par-pointeur-pass-by-pointer","title":"3. Passage par Pointeur (Pass-by-Pointer)","text":"<p>\"Je te donne l'adresse GPS de ma maison.\"</p> <p>C'est l'anc\u00eatre de la r\u00e9f\u00e9rence, h\u00e9rit\u00e9 du langage C. On utilise le symbole <code>*</code> pour d\u00e9clarer le pointeur et <code>&amp;</code> pour r\u00e9cup\u00e9rer l'adresse d'une variable.</p> <ul> <li>M\u00e9canisme : La fonction re\u00e7oit l'adresse m\u00e9moire (un nombre hexad\u00e9cimal) de la variable, pas la variable elle-m\u00eame.</li> <li>Syntaxe : C'est plus lourd \u00e0 utiliser. Il faut \"d\u00e9r\u00e9f\u00e9rencer\" le pointeur avec l'\u00e9toile <code>*</code> pour acc\u00e9der \u00e0 la valeur stock\u00e9e \u00e0 cette adresse.</li> <li>La Diff\u00e9rence Cl\u00e9 : Un pointeur peut \u00eatre vide (<code>nullptr</code>). Une r\u00e9f\u00e9rence, elle, doit toujours \u00eatre li\u00e9e \u00e0 une variable existante.</li> </ul> <pre><code>// La fonction attend une adresse (int*)\nvoid remiseAZero(int* ptr) {\n    // S\u00e9curit\u00e9 : on v\u00e9rifie que l'adresse existe (n'est pas nulle)\n    if (ptr != nullptr) { \n        *ptr = 0; // On va \u00e0 l'adresse point\u00e9e et on \u00e9crit 0\n    }\n}\n\nint main() {\n    int note = 20;\n\n    // Appel : On envoie l'adresse de 'note' avec '&amp;'\n    remiseAZero(&amp;note); \n}\n</code></pre> <p>## 4. Le Grand R\u00e9capitulatif</p> <p>Voici le tableau de synth\u00e8se pour savoir quelle m\u00e9thode utiliser en un coup d'\u0153il.</p> M\u00e9thode Syntaxe (D\u00e9claration) Syntaxe (Appel) Modifie Original ? Peut \u00eatre Null ? Usage Recommand\u00e9 Copie <code>void f(int a)</code> <code>f(a)</code> \u274c Non \u274c Non Petits types simples (<code>int</code>, <code>bool</code>, <code>char</code>). R\u00e9f\u00e9rence <code>void f(int&amp; a)</code> <code>f(a)</code> \u2705 Oui \u274c Non Quand la fonction doit modifier la variable. R\u00e9f. Const <code>void f(const int&amp; a)</code> <code>f(a)</code> \u274c Non \u274c Non Standard pour les objets (<code>string</code>, <code>vector</code>) en lecture seule. Pointeur <code>void f(int* a)</code> <code>f(&amp;a)</code> \u2705 Oui \u2705 Oui Donn\u00e9es optionnelles ou h\u00e9ritage du C. <p>## 5. Guide de D\u00e9cision : Quoi utiliser quand ?</p> <p>C'est la question la plus importante. Suivez cet algorithme mental pour choisir le bon type de param\u00e8tre.</p> <p>L'Algorithme de Choix</p> <ol> <li> <p>La variable est-elle \"petite\" ? (<code>int</code>, <code>double</code>, <code>char</code>, <code>bool</code>)     \ud83d\udc49 Utilisez la COPIE. (Ex: <code>void setAge(int age)</code>)     C'est plus simple et le processeur g\u00e8re \u00e7a tr\u00e8s vite.</p> </li> <li> <p>La variable est \"grosse\" (<code>string</code>, <code>vector</code>) et je veux juste la lire ?     \ud83d\udc49 Utilisez la R\u00c9F\u00c9RENCE CONSTANTE. (Ex: <code>void afficher(const std::string&amp; nom)</code>)     C'est rapide (z\u00e9ro copie) et s\u00fbr.</p> </li> <li> <p>La fonction doit-elle modifier l'original ?     \ud83d\udc49 Utilisez la R\u00c9F\u00c9RENCE. (Ex: <code>void monterNiveau(Joueur&amp; j)</code>)</p> </li> <li> <p>La donn\u00e9e est-elle optionnelle (peut ne pas exister) ?     \ud83d\udc49 Utilisez le POINTEUR. (Ex: <code>void cibler(Ennemi* cible)</code>)     Cela permet de passer <code>nullptr</code> pour dire \"rien\".</p> </li> </ol>"},{"location":"notes/semaine_1_3/#6-le-cas-special-des-tableaux-c","title":"6. Le Cas Sp\u00e9cial des Tableaux C","text":"<p>Attention : Les tableaux de style C (<code>int tab[]</code>) sont des tra\u00eetres !</p> <p>Le Pi\u00e8ge du Decay (D\u00e9g\u00e9n\u00e9rescence)</p> <p>M\u00eame si vous ne mettez pas de <code>&amp;</code>, un tableau C pass\u00e9 \u00e0 une fonction se comporte toujours comme un pointeur. Il n'est jamais copi\u00e9.</p> <p>Cela signifie que la fonction peut modifier votre tableau original sans pr\u00e9venir.</p> <pre><code>// Ceci modifie le VRAI tableau, m\u00eame sans '&amp;' !\nvoid hack(int tab[]) { \n    tab[0] = 0; // Le tableau du main est modifi\u00e9\n}\n</code></pre> <p>Note : La Solution Moderne</p> <p>C'est pour cela qu'en C++ moderne, on pr\u00e9f\u00e8re <code>std::vector</code> ou <code>std::span</code> qui sont plus s\u00fbrs.</p>"},{"location":"notes/semaine_1_3/#exemple-des-pointeurs-vu-en-classe","title":"Exemple des pointeurs vu en classe.","text":"<pre><code>#include &lt;iostream&gt; //instruction de pr\u00e9compilation\n\nvoid fonction_quelconque(int* le_pointeur_de_int) { //j'ai oubli\u00e9 de dire qu'en c++ c'est la casse \"serpent\"\n    std::cout &lt;&lt; \" entr\u00e9e de fonction \" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" adresse o\u00f9 pointe le pointeur : \" &lt;&lt; le_pointeur_de_int &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" la valeur par d\u00e9r\u00e9f\u00e9rencement : \" &lt;&lt; *le_pointeur_de_int &lt;&lt; std::endl;\n    // d\u00e9r\u00e9f\u00e9rencer -&gt; enlever la r\u00e9f\u00e9rence et tomber sur le type en dessous, int dans notre cas\n\n    //modification de la valeur\n    *le_pointeur_de_int *= 2; //x2 la valeur\n    std::cout &lt;&lt; \" Fin de fonction \" &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\nint main() {\n    int a { 10 };\n    std::cout &lt;&lt; \"adresse de a \" &lt;&lt; &amp;a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a\n\n    std::cout &lt;&lt; \"valeur de a avant l'appel de fonction \" &lt;&lt; a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a\n    fonction_quelconque(&amp;a); //appel de la fonction avec l'adresse de a\n    std::cout &lt;&lt; \"valeur de a apr\u00e8s l'appel de fonction \" &lt;&lt; a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a\n\n    //preuve que la fonction re\u00e7oit un pointeur\n    int* a_ptr = &amp;a; //d\u00e9claration d'un pointeur sur l'adresse de la variable a\n    fonction_quelconque(a_ptr);\n}\n</code></pre>"},{"location":"notes/semaine_1_4/","title":"Guide de Compilation en C++20","text":"<p>Ce document explique comment transformer votre code source (<code>.cpp</code>, <code>.hpp</code>) en un programme ex\u00e9cutable \u00e0 l'aide du compilateur <code>g++</code> et du standard C++20.</p>"},{"location":"notes/semaine_1_4/#1-quest-ce-que-la-compilation","title":"1. Qu'est-ce que la Compilation ?","text":"<p>La compilation est le processus qui traduit votre code C++, lisible par un humain, en code machine, compr\u00e9hensible par l'ordinateur. L'outil qui r\u00e9alise cette traduction est appel\u00e9 un compilateur. Dans ce cours, nous utiliserons <code>g++</code>, le compilateur C++ du projet GNU, l'un des plus populaires.</p> <p></p>"},{"location":"notes/semaine_1_4/#2-la-commande-de-compilation-essentielle","title":"2. La Commande de Compilation Essentielle","text":"<p>Pour compiler, vous ouvrirez un terminal (ou une console) et taperez une commande qui ressemble \u00e0 ceci :</p> <pre><code>g++ [options] -o [nom_executable] [vos_fichiers.cpp]\n</code></pre> <p>D\u00e9taillons chaque partie :</p> <ul> <li><code>g++</code> : C'est l'appel au compilateur lui-m\u00eame.</li> <li><code>[options]</code> : Ce sont des \"drapeaux\" (flags) qui modifient le comportement du compilateur. Les deux plus importants pour nous sont :<ul> <li><code>-std=c++20</code> : C'est le drapeau crucial qui dit \u00e0 <code>g++</code> d'utiliser le standard C++20. Sans cela, les fonctionnalit\u00e9s modernes du langage ne seront pas disponibles.</li> <li><code>-Wall</code> : (Abr\u00e9viation de \"Warnings All\") C'est une option tr\u00e8s fortement recommand\u00e9e qui active presque tous les avertissements (<code>warnings</code>). Le compilateur vous signalera des erreurs potentielles dans votre code, m\u00eame si elles ne l'emp\u00eachent pas de compiler. C'est un filet de s\u00e9curit\u00e9 indispensable.</li> </ul> </li> <li><code>-o [nom_executable]</code> : L'option <code>-o</code> (pour \"output\") vous permet de nommer votre programme final. Si vous l'omettez, le fichier de sortie s'appellera <code>a.out</code> (sur Linux/macOS) ou <code>a.exe</code> (sur Windows).</li> <li><code>[vos_fichiers.cpp]</code> : C'est la liste de tous vos fichiers <code>.cpp</code>, s\u00e9par\u00e9s par des espaces. Vous n'avez pas besoin d'inclure les fichiers <code>.hpp</code>, car ils sont g\u00e9r\u00e9s via les directives <code>#include</code> dans vos fichiers <code>.cpp</code>.</li> </ul>"},{"location":"notes/semaine_1_4/#3-exemples-concrets","title":"3. Exemples Concrets","text":""},{"location":"notes/semaine_1_4/#cas-1-un-projet-avec-un-seul-fichier","title":"Cas 1 : Un Projet avec un Seul Fichier","text":"<p>Imaginons que vous avez un seul fichier <code>main.cpp</code>.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp\n</code></pre> -   Ceci cr\u00e9era un ex\u00e9cutable nomm\u00e9 <code>mon_programme</code>.</p>"},{"location":"notes/semaine_1_4/#cas-2-un-projet-avec-plusieurs-fichiers","title":"Cas 2 : Un Projet avec Plusieurs Fichiers","text":"<p>Reprenons notre exemple <code>Commande</code>. Nous avons trois fichiers <code>.cpp</code> \u00e0 compiler ensemble.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o exemple main.cpp Commande.cpp ServiceConnexion.cpp\n</code></pre> -   <code>g++</code> va compiler chaque fichier <code>.cpp</code> et les lier (\"link\") ensemble pour cr\u00e9er un seul ex\u00e9cutable nomm\u00e9 <code>exemple</code>.</p>"},{"location":"notes/semaine_1_4/#4-executer-votre-programme","title":"4. Ex\u00e9cuter votre Programme","text":"<p>Une fois la compilation r\u00e9ussie (si la commande ne retourne aucune erreur), un nouveau fichier ex\u00e9cutable appara\u00eetra dans votre dossier.</p> <p>Pour l'ex\u00e9cuter dans le terminal :</p> <ul> <li> <p>Sur Linux ou macOS : <pre><code>./nom_executable \n</code></pre>     (Le <code>./</code> signifie \"dans le dossier actuel\")</p> </li> <li> <p>Sur Windows (cmd ou PowerShell) : <pre><code>.\\nom_executable.exe\n</code></pre></p> </li> </ul>"},{"location":"notes/semaine_1_4/#5-ca-ne-compile-pas-gerer-les-erreurs","title":"5. \"\u00c7a ne compile pas !\" - G\u00e9rer les Erreurs","text":"<p>Il est normal d'avoir des erreurs de compilation. L'art de la programmation est de savoir les lire.</p> <p>Les erreurs les plus courantes au d\u00e9but : -   Oubli d'un point-virgule (<code>;</code>) \u00e0 la fin d'une ligne. -   Faute de frappe dans un nom de variable ou de fonction. -   Accolade (<code>{</code> ou <code>}</code>) manquante. -   Oubli d'inclure un en-t\u00eate (ex: <code>#include &lt;string&gt;</code> pour utiliser <code>std::string</code>).</p> <p>Lisez attentivement les messages d'erreur. <code>g++</code> vous donnera g\u00e9n\u00e9ralement le nom du fichier et le num\u00e9ro de la ligne o\u00f9 l'erreur a \u00e9t\u00e9 d\u00e9tect\u00e9e.</p> <p>Exemple de message d'erreur : <pre><code>main.cpp: In function 'int main()':\nmain.cpp:5:3: error: expected ';' before 'return'\n   return 0;\n   ^~~~~~\n</code></pre> Le compilateur nous dit qu'\u00e0 la ligne 5 du fichier <code>main.cpp</code>, il s'attendait \u00e0 un point-virgule avant le mot-cl\u00e9 <code>return</code>.</p> <p>```</p>"}]}