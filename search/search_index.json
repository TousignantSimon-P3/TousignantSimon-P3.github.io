{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Programmation 3 (420-4A6-VI) - Hiver 2026","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Vous trouverez ici les notes et exercices du cours. J'ajouterai du nouveau contenu continuellement.  </p> <p>Pr\u00e9alable \u00e0 ce cours : 420-2A6-VI : Programmation 2  </p> <p>Ce cours est pr\u00e9alable \u00e0 : 420-5B5-VI Projet int\u00e9grateur 1 Cheminement complet: https://informatique.apical.xyz/ </p>"},{"location":"#environnement-de-travail","title":"Environnement de travail","text":"<p>Pour le cours vous avez deux logiciels \u00e0 installer:  </p> <ul> <li>WSL (Windows subsystem for linux)  </li> <li>Un \u00e9diteur de texte \u00e9volu\u00e9 tel notepad++ (recommand\u00e9)  </li> <li>Codeblock  </li> <li>Git  </li> </ul>"},{"location":"#wsl","title":"WSL","text":"<p>Vous devez installer git et build-essential dans l'environnement linux. Les paquets tels que, mais non limit\u00e9s \u00e0, gemini, claude, chatgpt sont proscrit. </p>"},{"location":"#notepad-ou-autre-editeur-compatible","title":"Notepad++ (ou autre \u00e9diteur compatible)","text":"<p>Parfois git vous demande de faire l'\u00e9ditions de fichiers tel que les commentaires pour les soumissions. (git commit). Il arrive \u00e9galement que des conflits soient pr\u00e9sent. Le logiciels permet de mieux travailler dans ces situations plus complexe.  </p>"},{"location":"#git","title":"Git","text":"<p>Installation normale, portez attention \u00e0 l'\u00e9diteur par d\u00e9faut. Autrement, vous allez vous retrouver avec vim pour \u00e9diter vos fichiers  </p> <p>Votre identit\u00e9 : dans WSL vous \u00eates dans un environnement \"nouveau\" donc git va vous demander votre identit\u00e9. Utilisez votre courriel coll\u00e8ge comme configuration de courriel globale : @etudiant.cegepvicto.ca Pour votre nom vous pouvez r\u00e9utiliser votre num\u00e9ro de DA  </p> <pre><code>*** Please tell me who you are.  \n\nRun  \n\n  git config --global user.email \"[DA]@etudiant.cegepvicto.ca\"  \n  git config --global user.name \"Votre nom\"  \n\nto set your account's default identity.  \nOmit --global to set the identity only in this repository.  \n</code></pre>"},{"location":"#regles-de-classes-et-explications","title":"R\u00e8gles de classes et explications :","text":"<p>Petit rappel des r\u00e8gles au niveau de la P.D.E.A </p>"},{"location":"#conditions-pedagogiques-particulieres","title":"Conditions p\u00e9dagogiques particuli\u00e8res","text":"<p>Utilisation de g\u00e9n\u00e9rateur automatique :  </p> <p>Dans le cadre des activit\u00e9s acad\u00e9miques du cours, l'utilisation de g\u00e9n\u00e9rateurs de code automatiques, d'assistants d'IA tels que ChatGPT, Copilot ou tout autre outil similaire permettant la cr\u00e9ation automatique de contenu, la g\u00e9n\u00e9ration de code ou l\u2019assistance \u00e0 la r\u00e9solution d'exercices, est formellement interdite. Toute utilisation de ces outils durant un cours entra\u00eenera l'exclusion imm\u00e9diate de l'\u00e9l\u00e8ve de la p\u00e9riode concern\u00e9e.  </p>"},{"location":"#utilisation-des-cellulaires-ou-dappareils-mobiles-en-classe","title":"Utilisation des cellulaires ou d'appareils mobiles en classe","text":"<p>Toute utilisation d'appareil mobile tel que cellulaire, tablette ou console de jeux mobile est proscrite pendant le bloc horaire \u00e0 l'int\u00e9rieur du local. (Pr\u00e9cision : pauses incluses.) L'utilisation de tels appareils doit imp\u00e9rativement se faire hors du local afin de favoriser le climat d'apprentissage.  </p> <p>Les manquements aux articles pr\u00e9c\u00e9dents seront consign\u00e9s. Apr\u00e8s trois (3) exclusions, des d\u00e9marches administratives seront entreprises avec l'API afin de d\u00e9terminer les modalit\u00e9s de cheminement.  </p>"},{"location":"#environnement-numerique-dapprentissage-plateforme","title":"Environnement num\u00e9rique d\u2019apprentissage (plateforme)","text":"<ul> <li>Team  </li> <li>Github  </li> <li>Github classroom  </li> </ul> <p>L'\u00e9l\u00e8ve a la responsabilit\u00e9 d'avoir un compte github avec un nom d'utilisateur r\u00e9pondant \u00e0 la norme suivante :  </p> <p>cgpvicto-[son num\u00e9ro de DA]  </p> <p>exemple : cgpvicto-9999999  </p> <p>Une fois le compte github cr\u00e9\u00e9. On doit rejoindre le github classroom correspondant \u00e0 son groupe, proc\u00e9dure qui sera donn\u00e9e en classe lors des premi\u00e8res semaines  </p>"},{"location":"conventions/","title":"Normes et Conventions de Code C++","text":"<p>Standard du Cours</p> <p>Ce cours utilise officiellement le standard C++20. Tous les exemples et exercices doivent \u00eatre compil\u00e9s avec un compilateur compatible.  </p> <p>Ce document d\u00e9finit les standards de programmation attendus pour tous les travaux pratiques et examens. L'objectif est de produire un code lisible, maintenable et proche des standards industriels modernes.  </p>"},{"location":"conventions/#1-structure-du-code-et-nommage","title":"1. Structure du Code et Nommage","text":""},{"location":"conventions/#11-nommage-naming-convention","title":"1.1. Nommage (Naming Convention)","text":"<p>Nous adoptons le style de la Biblioth\u00e8que Standard C++ (STL).  </p> \u00c9l\u00e9ment Format Exemple Variables Locales <code>snake_case</code> <code>nombre_etudiants</code>, <code>index_courant</code> Attributs Membres (priv\u00e9s) <code>snake_case_</code> <code>nombre_etudiants_</code>, <code>index_courant_</code> Fonctions <code>snake_case</code> <code>calculer_moyenne()</code>, <code>sauvegarder_fichier()</code> Classes / Structs <code>PascalCase</code> <code>Etudiant</code>, <code>GestionnaireFichier</code> Constantes <code>SCREAMING_SNAKE</code> <code>MAX_BUFFER_SIZE</code>, <code>PI</code>"},{"location":"conventions/#12-encapsulation-et-accesseurs","title":"1.2. Encapsulation et Accesseurs","text":"<p>Les attributs membres des classes et structures doivent \u00eatre d\u00e9clar\u00e9s <code>private</code> ou <code>protected</code> et accessibles via des m\u00e9thodes accesseurs (getters/setters). L'utilisation de variables membres publiques est fortement d\u00e9conseill\u00e9e afin de respecter les principes d'encapsulation. Si, dans des cas exceptionnels, une variable membre publique est n\u00e9cessaire, elle ne doit pas utiliser le suffixe <code>_</code>.  </p>"},{"location":"conventions/#13-initialisation-uniforme-avec-les-accolades","title":"1.3. Initialisation Uniforme avec les Accolades <code>{}</code>","text":"<p>R\u00e8gle : Pour initialiser toute variable, utilisez toujours la syntaxe avec accolades <code>{}</code> (Uniform Initialization).  </p> <p>Pourquoi ? - S\u00e9curit\u00e9 : Emp\u00eache les conversions de type risqu\u00e9es (ex: <code>int x {5.5};</code> g\u00e9n\u00e8re une erreur de compilation). - Uniformit\u00e9 : La m\u00eame syntaxe fonctionne pour tout (variables simples, tableaux, objets). - Garantie Z\u00e9ro : Une initialisation avec des accolades vides (<code>int x {};</code>) garantit que la variable vaut z\u00e9ro (ou son \u00e9quivalent), pr\u00e9venant les bogues de variables non-initialis\u00e9es.  </p>"},{"location":"conventions/#2-structure-et-complexite","title":"2. Structure et Complexit\u00e9","text":""},{"location":"conventions/#21-regle-des-3-niveaux","title":"2.1. R\u00e8gle des 3 niveaux","text":"<p>L'imbrication (nesting) ne doit jamais d\u00e9passer 3 niveaux de profondeur.  </p>"},{"location":"conventions/#22-clause-de-garde-guard-clause","title":"2.2. Clause de Garde (Guard Clause)","text":"<p>Privil\u00e9giez toujours le retour anticip\u00e9 (Early Return) pour r\u00e9duire la complexit\u00e9.  </p>"},{"location":"conventions/#3-bonnes-pratiques-fichiers-et-performance","title":"3. Bonnes pratiques : Fichiers et Performance","text":""},{"location":"conventions/#31-organisation-une-classe-par-fichier","title":"3.1. Organisation : Une Classe par Fichier","text":"<p>Chaque <code>class</code> ou <code>struct</code> doit \u00eatre d\u00e9finie dans son propre couple de fichiers (<code>.hpp</code> et <code>.cpp</code>).  </p>"},{"location":"conventions/#32-fichiers-den-tete-et-pragma-once","title":"3.2. Fichiers d'en-t\u00eate et <code>#pragma once</code>","text":"<p>Tout fichier <code>.hpp</code> doit commencer imp\u00e9rativement par <code>#pragma once</code>.  </p>"},{"location":"conventions/#33-le-const-et-le-passage-par-reference","title":"3.3. Le <code>const</code> et le passage par r\u00e9f\u00e9rence","text":"<p>Pour les types complexes (<code>string</code>, <code>vector</code>, etc.), utilisez <code>const type&amp;</code> en param\u00e8tre pour \u00e9viter des copies inutiles.  </p>"},{"location":"conventions/#4-documentation-du-code-doxygen","title":"4. Documentation du Code (Doxygen)","text":"<p>Le standard pour la documentation du code est Doxygen. Une documentation claire et compl\u00e8te est exig\u00e9e pour toutes les classes et fonctions publiques. La documentation doit toujours se trouver dans les fichiers d'en-t\u00eate (<code>.hpp</code>).  </p>"},{"location":"conventions/#41-documentation-des-classes-et-structs","title":"4.1. Documentation des Classes et Structs","text":"<p>Toute d\u00e9claration de <code>class</code> ou <code>struct</code> doit \u00eatre pr\u00e9c\u00e9d\u00e9e d'un bloc de commentaire Doxygen <code>/** ... */</code>. Ce bloc doit contenir au minimum la directive <code>@brief</code> pour d\u00e9crire succinctement le r\u00f4le de la classe.  </p> <pre><code>/**  \n * @brief Repr\u00e9sente un \u00e9tudiant avec son nom et sa moyenne.  \n *  \n * Cette structure stocke les informations de base d'un \u00e9tudiant  \n * et peut \u00eatre utilis\u00e9e pour des calculs statistiques simples.  \n */  \nstruct Etudiant {  \n    std::string nom {};  \n    double moyenne {};  \n};  \n</code></pre>"},{"location":"conventions/#42-documentation-des-fonctions-et-methodes","title":"4.2. Documentation des Fonctions et M\u00e9thodes","text":"<p>Chaque fonction ou m\u00e9thode publique doit \u00eatre document\u00e9e avec un bloc <code>/** ... */</code> ou <code>///</code>. Le bloc doit inclure les directives suivantes, si applicables :  </p> Directive Description <code>@brief</code> Un r\u00e9sum\u00e9 concis d'une seule ligne sur ce que fait la fonction. <code>@param</code> D\u00e9crit un param\u00e8tre. Doit inclure la direction (<code>[in]</code>, <code>[out]</code>, <code>[in,out]</code>). <code>@return</code> D\u00e9crit la valeur de retour de la fonction. <code>@throws</code> D\u00e9crit une exception qui peut \u00eatre lev\u00e9e par la fonction."},{"location":"conventions/#directive-param-en-detail","title":"Directive <code>@param</code> en d\u00e9tail","text":"<p>La direction du param\u00e8tre est cruciale pour comprendre le comportement de la fonction sans lire son code source.  </p> <ul> <li><code>[in]</code>: Le param\u00e8tre est lu par la fonction mais n'est pas modifi\u00e9. C'est le cas le plus courant (ex: <code>T</code>, <code>const T&amp;</code>).  </li> <li><code>[out]</code>: Le param\u00e8tre est utilis\u00e9 pour retourner une valeur. La fonction y \u00e9crit un r\u00e9sultat. La valeur initiale du param\u00e8tre n'est pas importante (ex: <code>T&amp;</code>).  </li> <li><code>[in,out]</code>: Le param\u00e8tre est lu puis modifi\u00e9 par la fonction. Sa valeur initiale est importante (ex: <code>T&amp;</code>).  </li> </ul>"},{"location":"conventions/#43-exemple-complet","title":"4.3. Exemple Complet","text":"<p>Voici un exemple d'une fonction correctement document\u00e9e qui illustre l'utilisation des diff\u00e9rentes directives.  </p>"},{"location":"conventions/#brief-calcule-les-statistiques-dune-liste-detudiants-cette-fonction-prend-une-liste-detudiants-calcule-la-moyenne-generale-du-groupe-et-identifie-letudiant-avec-la-meilleure-note-paramin-etudiants-la-liste-des-etudiants-a-analyser-ne-sera-pas-modifiee-paramout-moyenne_generale-la-moyenne-de-tous-les-etudiants-sera-stockee-dans-cette-variable-paramout-meilleur_etudiant-le-nom-de-letudiant-avec-la-meilleure-note-sera-stocke-ici-paraminout-compteur_appels-le-nombre-de-fois-que-la-fonction-a-ete-appelee-sera-incremente-return-true-si-le-calcul-a-reussi-false-si-la-liste-detudiants-etait-vide-throws-stdinvalid_argument-si-le-compteur-dappels-est-negatif-au-depart-bool-calculer_statistiques-const-stdvectoretudiant-etudiants-double-moyenne_generale-stdstring-meilleur_etudiant-int-compteur_appels","title":"<pre><code>/**  \n * @brief Calcule les statistiques d'une liste d'\u00e9tudiants.  \n *  \n * Cette fonction prend une liste d'\u00e9tudiants, calcule la moyenne g\u00e9n\u00e9rale du groupe  \n * et identifie l'\u00e9tudiant avec la meilleure note.  \n *  \n * @param[in]  etudiants          La liste des \u00e9tudiants \u00e0 analyser. Ne sera pas modifi\u00e9e.  \n * @param[out] moyenne_generale   La moyenne de tous les \u00e9tudiants sera stock\u00e9e dans cette variable.  \n * @param[out] meilleur_etudiant  Le nom de l'\u00e9tudiant avec la meilleure note sera stock\u00e9 ici.  \n * @param[in,out] compteur_appels Le nombre de fois que la fonction a \u00e9t\u00e9 appel\u00e9e. Sera incr\u00e9ment\u00e9.  \n *  \n * @return `true` si le calcul a r\u00e9ussi, `false` si la liste d'\u00e9tudiants \u00e9tait vide.  \n *  \n * @throws std::invalid_argument si le compteur d'appels est n\u00e9gatif au d\u00e9part.  \n */  \nbool calculer_statistiques(  \n    const std::vector&lt;Etudiant&gt;&amp; etudiants,  \n    double&amp; moyenne_generale,  \n    std::string&amp; meilleur_etudiant,  \n    int&amp; compteur_appels  \n);  \n</code></pre>","text":""},{"location":"conventions/#5-exemple-complet-dapplication","title":"5. Exemple Complet d'Application","text":"<p>T\u00e9l\u00e9charger l'exemple complet (ZIP) </p> <p>Voici un exemple concret qui rassemble tous les standards.  </p>"},{"location":"conventions/#51-structure-des-fichiers","title":"5.1. Structure des fichiers","text":"<pre><code>/exemple_commande  \n|-- Article.hpp  \n|-- Commande.cpp  \n|-- Commande.hpp  \n|-- main.cpp  \n|-- ServiceConnexion.cpp  \n`-- ServiceConnexion.hpp  \n</code></pre>"},{"location":"conventions/#52-fichiers-den-tete-et-source","title":"5.2. Fichiers d'en-t\u00eate et Source","text":"Fichier : <code>main.cpp</code> <pre><code>#include &lt;iostream&gt;  \n#include \"Commande.hpp\"  \n\nint main() {  \n    ServiceConnexion service_connexion {};  \n    Article article_disponible {\"Stylo\", 10};  \n    Article article_indisponible {\"Cahier\", 0};  \n\n    std::cout &lt;&lt; \"--- Debut des tests de scenarios ---\\\\n\" &lt;&lt; std::endl;  \n\n    // Sc\u00e9nario 1 : Commande valide  \n    Commande cmd_valide {101};  \n    cmd_valide.ajouter_article(article_disponible);  \n    cmd_valide.traiter_commande(service_connexion);  \n\n    // Sc\u00e9nario 2 : Article en rupture de stock  \n    Commande cmd_stock_epuise {102};  \n    cmd_stock_epuise.ajouter_article(article_disponible);  \n    cmd_stock_epuise.ajouter_article(article_indisponible);  \n    cmd_stock_epuise.traiter_commande(service_connexion);  \n\n    // Sc\u00e9nario 3 : Commande invalide (vide)  \n    Commande cmd_vide {103};  \n    cmd_vide.traiter_commande(service_connexion);  \n\n    std::cout &lt;&lt; \"\\n--- Fin des tests ---\\\\n\";  \n\n    return 0;  \n}  \n</code></pre> <p>(Le code des autres fichiers <code>Article.hpp</code>, <code>Commande.hpp</code>, etc. est omis pour la lisibilit\u00e9, mais est inclus dans le ZIP t\u00e9l\u00e9chargeable.) </p>"},{"location":"conventions/#53-compilation-et-resultat","title":"5.3. Compilation et R\u00e9sultat","text":"<p>Pour compiler et ex\u00e9cuter cet exemple : <pre><code>g++ -std=c++20 -Wall -o exemple_commande/exemple exemple_commande/main.cpp exemple_commande/Commande.cpp exemple_commande/ServiceConnexion.cpp  \n./exemple_commande/exemple  \n</code></pre></p> <p>Le r\u00e9sultat attendu est : <pre><code>--- Debut des tests de scenarios ---  \n\nSUCCES : La commande 101 a ete envoyee.  \nERREUR (Cmd 102): Un ou plusieurs articles en rupture de stock.  \nERREUR (Cmd 103): Commande invalide ou vide.  \n\n--- Fin des tests ---  \n</code></pre></p>"},{"location":"horaire/","title":"Horaire du cours","text":"<p>Planification de la session Hiver 2026.  </p> <p>Remarque importante</p> <p>Les dates de remises sont indiqu\u00e9es par le drapeau \ud83d\udea9. Assurez-vous de v\u00e9rifier cette colonne r\u00e9guli\u00e8rement.  </p>"},{"location":"horaire/#partie-1-avant-la-relache","title":"Partie 1 : Avant la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 1 Cours 01 19-01-2026 08:15 Pr\u00e9sentation du plan de cours Cours 02 21-01-2026 13:15 Semaine 2 Cours 03 26-01-2026 08:15 Cours 04 29-01-2026 13:15 Semaine 3 Cours 05 02-02-2026 08:15 Cours 06 05-02-2026 13:15 Semaine 4 Cours 07 09-02-2026 08:15 Cours 08 12-02-2026 13:15 Semaine 5 Cours 09 16-02-2026 08:15 Cours 10 19-02-2026 13:15 Semaine 6 Cours 11 23-02-2026 08:15 Cours 12 26-02-2026 13:15 {: .horaire } <p>\ud83c\udf34 SEMAINE DE REL\u00c2CHE : Du 2 au 6 mars 2026</p> <p>Aucun cours. </p>"},{"location":"horaire/#partie-2-apres-la-relache","title":"Partie 2 : Apr\u00e8s la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 7 Cours 13 09-03-2026 08:15 Cours 14 12-03-2026 13:15 Semaine 8 Cours 15 16-03-2026 08:15 Cours 16 19-03-2026 13:15 Semaine 9 Cours 17 23-03-2026 08:15 Cours 18 26-03-2026 13:15 Semaine 10 Cours 19 30-03-2026 08:15 Cours 20 02-04-2026 13:15 Prochaine rencontre dans 1 sem. Semaine 11 Cours 21 09-04-2026 13:15 Cours 22 13-04-2026 08:15 Semaine 12 Cours 23 16-04-2026 13:15 Cours 24 20-04-2026 08:15 Semaine 13 Cours 25 27-04-2026 08:15 Cours 26 30-04-2026 13:15 Semaine 14 Cours 27 04-05-2026 08:15 Cours 28 07-05-2026 13:15 Semaine 15 Cours 29 11-05-2026 08:15 Cours 30 14-05-2026 13:15 {: .horaire }"},{"location":"ressources/","title":"Ressources","text":""},{"location":"ressources/#documentation-officielle","title":"Documentation officielle","text":"<p>C# documentation officielle : https://learn.microsoft.com/fr-ca/dotnet/csharp/tour-of-csharp/ </p> <p>.Net 8.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-8.0 </p> <p>.Net 9.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-9.0 </p> <p>Tests unitaires MSTest : https://learn.microsoft.com/fr-ca/dotnet/core/testing/unit-testing-with-mstest </p> <p>Table ASCII : https://www.asciitable.com/ </p>"},{"location":"exercices/examen_formatif/","title":"Examen Formatif : Les Bases du C++ (Th\u00e9orie)","text":"<p>Cet examen est con\u00e7u pour \u00eatre r\u00e9alis\u00e9 sans ordinateur afin de valider votre compr\u00e9hension des concepts fondamentaux.  </p>"},{"location":"exercices/examen_formatif/#question-1-initialisation-de-variable-primitive","title":"Question 1 : Initialisation de variable primitive","text":"<p>\u00c9crivez la ligne de code permettant d'initialiser une variable de type <code>double</code> nomm\u00e9e <code>vitesse</code> \u00e0 la valeur <code>9.8</code> en utilisant exclusivement la syntaxe avec accolades (<code>{}</code>).  </p>"},{"location":"exercices/examen_formatif/#question-2-initialisation-de-struct-sur-la-pile-stack","title":"Question 2 : Initialisation de struct sur la PILE (Stack)","text":"<p>Soit la structure suivante : <pre><code>struct Position {  \n    int x;  \n    int y;  \n};  \n</code></pre> \u00c9crivez la ligne de code pour cr\u00e9er et initialiser une instance de cette structure nomm\u00e9e <code>pos</code> (sur la pile) avec les valeurs <code>x=10</code> et <code>y=20</code> en utilisant les accolades.  </p>"},{"location":"exercices/examen_formatif/#question-3-erreur-de-compilation-narrowing-conversion","title":"Question 3 : Erreur de compilation (Narrowing conversion)","text":"<p>Expliquez pr\u00e9cis\u00e9ment pourquoi le code suivant provoque une erreur de compilation en C++ : <pre><code>int nombre { 15.75 };  \n</code></pre> Que se passerait-il si nous avions utilis\u00e9 l'op\u00e9rateur <code>=</code> \u00e0 la place des accolades ?  </p>"},{"location":"exercices/examen_formatif/#question-4-initialisation-par-defaut","title":"Question 4 : Initialisation par d\u00e9faut","text":"<p>Quelle sera la valeur de la variable <code>compteur</code> apr\u00e8s l'ex\u00e9cution de cette ligne ? <pre><code>int compteur {};  \n</code></pre></p>"},{"location":"exercices/examen_formatif/#question-5-gestion-du-buffer-cin","title":"Question 5 : Gestion du Buffer (cin)","text":"<p>L'utilisateur tape <code>18</code> puis appuie sur <code>[Entr\u00e9e]</code>. <pre><code>int age;  \nstd::cin &gt;&gt; age;  \n</code></pre> D\u00e9crivez pr\u00e9cis\u00e9ment ce qui reste dans le \"buffer\" (la m\u00e9moire tampon) imm\u00e9diatement apr\u00e8s l'ex\u00e9cution de cette extraction.  </p>"},{"location":"exercices/examen_formatif/#question-6-passage-de-parametres-performance","title":"Question 6 : Passage de Param\u00e8tres (Performance)","text":"<p>Vous avez une structure <code>GrosseDonnee</code> (tr\u00e8s volumineuse). Vous devez l'envoyer \u00e0 une fonction qui va lire son contenu sans le modifier. \u00c9crivez la signature (le prototype) de la fonction <code>afficher</code> la plus performante possible pour \u00e9viter une copie inutile tout en garantissant la s\u00e9curit\u00e9 des donn\u00e9es.  </p>"},{"location":"exercices/examen_formatif/#question-7-pointers-trace-dexecution","title":"Question 7 : Pointers (Trace d'ex\u00e9cution)","text":"<p>Donnez la valeur de la variable <code>a</code> \u00e0 la fin de cette s\u00e9quence : <pre><code>int a = 5;  \nint* p = &amp;a;  \n*p = *p + 10;  \np = nullptr;  \n</code></pre> Valeur finale de a : _ </p>"},{"location":"exercices/examen_formatif/#question-8-tableaux-bruts-transfert","title":"Question 8 : Tableaux Bruts (Transfert)","text":"<p>Soit le tableau : <code>int scores[3] { 90, 80, 70 };</code> On veut passer ce tableau \u00e0 une fonction <code>analyser</code>. Sans utiliser <code>vector</code> ou <code>span</code>, \u00e9crivez l'appel de la fonction dans le <code>main</code> ET sa signature (d\u00e9claration).  </p>"},{"location":"exercices/examen_formatif/#question-9-c20-stdspan","title":"Question 9 : C++20 (std::span)","text":"<p>R\u00e9\u00e9crivez la signature de la fonction <code>analyser</code> de la question pr\u00e9c\u00e9dente en utilisant <code>std::span&lt;int&gt;</code> au lieu d'un pointeur brut et d'une taille.  </p>"},{"location":"exercices/examen_formatif/#question-10-references-modification","title":"Question 10 : R\u00e9f\u00e9rences (Modification)","text":"<p>\u00c9crivez une fonction nomm\u00e9e <code>reinitialiser</code> qui re\u00e7oit un entier par r\u00e9f\u00e9rence et met sa valeur \u00e0 <code>0</code>, de sorte que la variable originale pass\u00e9e en argument soit r\u00e9ellement modifi\u00e9e.  </p>"},{"location":"exercices/examen_formatif/#question-11-acces-memoire-syntaxe-fleche","title":"Question 11 : Acc\u00e8s M\u00e9moire (Syntaxe fl\u00e8che)","text":"<p>Soit le code suivant : <pre><code>Position* ptr = new Position { 5, 10 }; // On assume Position { int x; int y; }  \n</code></pre> \u00c9crivez la ligne de code pour changer la valeur de <code>y</code> \u00e0 <code>100</code> en utilisant uniquement le pointeur <code>ptr</code>.  </p>"},{"location":"exercices/examen_formatif/#question-12-organisation-des-fichiers-syntaxe-cpp","title":"Question 12 : Organisation des fichiers (Syntaxe CPP)","text":"<p>Vous avez d\u00e9clar\u00e9 une fonction membre <code>void afficher() const;</code> dans votre struct <code>Position</code> (fichier <code>.hpp</code>). \u00c9crivez l'en-t\u00eate de l'impl\u00e9mentation de cette fonction telle qu'elle devrait appara\u00eetre dans le fichier <code>.cpp</code>.  </p>"},{"location":"exercices/examen_formatif/#question-13-memoire-sur-le-tas-heap","title":"Question 13 : M\u00e9moire sur le Tas (Heap)","text":"<p>\u00c9crivez la ligne de code pour allouer dynamiquement un seul entier sur le TAS (Heap) avec la valeur initiale <code>500</code> et stocker son adresse dans un pointeur nomm\u00e9 <code>p_dynamique</code>.  </p>"},{"location":"exercices/examen_formatif/#question-14-danger-des-variables-locales","title":"Question 14 : Danger des variables locales","text":"<p>Pourquoi est-il interdit de retourner l'adresse d'une variable locale \u00e0 une fonction, comme dans l'exemple ci-dessous ? <pre><code>int* genererErreur() {  \n    int local = 10;  \n    return &amp;local;  \n}  \n</code></pre></p>"},{"location":"exercices/examen_formatif/#question-15-algorithme-et-taille-stdssize","title":"Question 15 : Algorithme et Taille (std::ssize)","text":"<p>\u00c9crivez une boucle <code>for</code> (style classique avec index <code>i</code>) qui parcourt un tableau <code>int notes[5]</code>. La boucle doit afficher chaque note. Utilisez la fonction <code>std::ssize(notes)</code> pour d\u00e9finir la limite de votre boucle.  </p>"},{"location":"exercices/examen_formatif/#question-16-liste-chainee-passage-par-reference-de-pointeur","title":"Question 16 : Liste cha\u00een\u00e9e (Passage par r\u00e9f\u00e9rence de pointeur)","text":"<p>Vous avez un pointeur <code>Noeud* premier;</code> qui pointe vers le d\u00e9but de votre liste. Vous voulez cr\u00e9er une fonction <code>ajouterDebut</code> qui va modifier ce pointeur pour qu'il pointe vers un nouveau n\u0153ud. Comment devez-vous d\u00e9clarer le param\u00e8tre dans <code>void ajouterDebut(....................)</code> pour que la modification du pointeur <code>premier</code> soit effective \u00e0 l'ext\u00e9rieur de la fonction ?  </p>"},{"location":"exercices/examen_formatif/#question-17-suppression-dans-une-liste-chainee","title":"Question 17 : Suppression dans une liste cha\u00een\u00e9e","text":"<p>Dans une fonction <code>retirer_index</code>, vous avez un pointeur <code>Noeud* curseur</code> qui pointe sur le n\u0153ud PR\u00c9C\u00c9DANT celui que vous voulez supprimer. Les n\u0153uds sont allou\u00e9s sur le TAS (Heap). \u00c9crivez les lignes de code n\u00e9cessaires pour : 1. Isoler le n\u0153ud \u00e0 supprimer dans un pointeur temporaire. 2. \"Court-circuiter\" le n\u0153ud \u00e0 supprimer dans la liste. 3. Lib\u00e9rer proprement la m\u00e9moire du n\u0153ud supprim\u00e9. (On assume que la liste continue apr\u00e8s le n\u0153ud supprim\u00e9).  </p>"},{"location":"exercices/examen_formatif/#question-18-modelisation-complexe-train-et-wagons","title":"Question 18 : Mod\u00e9lisation complexe (Train et Wagons)","text":"<p>On veut repr\u00e9senter un train. Un train poss\u00e8de une locomotive et une s\u00e9rie de wagons. - Chaque wagon contient deux conteneurs. - Chaque conteneur poss\u00e8de un entier (tonnes). - Les wagons sont reli\u00e9s entre eux comme une liste cha\u00een\u00e9e. - La locomotive ne peut attacher qu'un seul wagon.  </p> <p>D\u00e9finissez les structures n\u00e9cessaires pour repr\u00e9senter cette situation en utilisant des pointeurs l\u00e0 o\u00f9 c'est n\u00e9cessaire.  </p>"},{"location":"exercices/semaine_1_1_exercices/","title":"Exercices de la Semaine 1 : Les Bases","text":"<p>Ces exercices sont con\u00e7us pour pratiquer les concepts de base vus dans les notes de la semaine 1. Concentrez-vous sur la ma\u00eetrise de la compilation, de l'affichage, de la saisie et des fonctions simples.  </p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-1-affichage-et-saisie-simple","title":"Bloc 1 : Affichage et Saisie Simple","text":"<p>Exercice 1 : Bonjour le Monde - Objectif : Cr\u00e9er un programme C++ de base. - T\u00e2che : \u00c9crivez un programme qui affiche \"Bonjour le monde !\" dans la console et qui se termine en retournant <code>0</code>.  </p> <p>Exercice 2 : Fiche de Pr\u00e9sentation - Objectif : Manipuler <code>std::cout</code> avec plusieurs lignes. - T\u00e2che : \u00c9crivez un programme qui affiche votre nom, votre ville et votre \u00e2ge sur des lignes s\u00e9par\u00e9es.  </p> <p>Exercice 3 : D\u00e9claration de Variables - Objectif : Se familiariser avec l'initialisation uniforme. - T\u00e2che : D\u00e9clarez quatre variables en utilisant la syntaxe d'accolades <code>{}</code> : un <code>int</code>, un <code>double</code>, un <code>char</code>, et un <code>bool</code>. Assignez-leur des valeurs de votre choix et affichez chaque valeur avec une description.  </p> <p>Exercice 4 : Interaction Simple - Objectif : Utiliser <code>std::cin &gt;&gt;</code> avec <code>std::string</code> et <code>int</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur son pr\u00e9nom et son ann\u00e9e de naissance. Calculez (approximativement) son \u00e2ge et affichez un message comme <code>\"Bonjour [Pr\u00e9nom], vous avez environ [Age] ans.\"</code>.  </p> <p>Exercice 5 : Calcul d'Aire - Objectif : Utiliser des types <code>double</code> avec <code>std::cin</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur la largeur et la hauteur d'un rectangle. Calculez et affichez son aire.  </p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-2-gestion-du-buffer-et-erreurs-de-saisie","title":"Bloc 2 : Gestion du Buffer et Erreurs de Saisie","text":"<p>Exercice 6 : Le Pi\u00e8ge de <code>getline</code> - Objectif : R\u00e9soudre le conflit entre <code>std::cin &gt;&gt;</code> et <code>std::getline</code>. - T\u00e2che : 1. Demandez \u00e0 l'utilisateur son num\u00e9ro de porte (un <code>int</code>).   2. Demandez-lui ensuite son nom de rue complet (un <code>std::string</code> avec <code>getline</code>).   3. Observez que le programme ignore la saisie de la rue.   4. Corrigez le probl\u00e8me en nettoyant le buffer apr\u00e8s la lecture du nombre.  </p> <p>Exercice 7 : Gestion d'Erreur Simple - Objectif : Utiliser <code>std::cin.fail()</code> pour d\u00e9tecter une erreur. - T\u00e2che : Demandez \u00e0 l'utilisateur d'entrer un nombre. Si la saisie \u00e9choue (si l'utilisateur tape du texte), affichez \"Erreur : saisie invalide.\". Sinon, affichez \"Merci !\".  </p> <p>Exercice 8 : Boucle de Saisie Robuste - Objectif : Cr\u00e9er une boucle qui force une saisie num\u00e9rique valide. - T\u00e2che : Cr\u00e9ez une boucle <code>while</code> qui continue de demander \"Entrez votre age :\" jusqu'\u00e0 ce que l'utilisateur entre un nombre entier valide. Si l'utilisateur se trompe, le programme doit afficher une erreur et lui redemander.  </p> <p>Exercice 9 : Analyse d'Entr\u00e9e Mixte - Objectif : Comprendre comment <code>cin</code> g\u00e8re les lectures partielles. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur un nombre. L'utilisateur doit taper <code>45abc</code>.   2. Lisez la saisie dans une variable de type <code>int</code>.   3. Affichez l'entier que vous avez r\u00e9ussi \u00e0 lire.   4. Ensuite, lisez le reste du buffer dans une variable <code>std::string</code>.   5. Affichez la cha\u00eene de caract\u00e8res. Le r\u00e9sultat devrait vous montrer ce qui restait dans le buffer.  </p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-3-fonctions-et-tableaux-classique","title":"Bloc 3 : Fonctions et Tableaux (Classique)","text":"<p>Exercice 10 : Calculatrice Simple - Objectif : \u00c9crire et appeler des fonctions simples. - T\u00e2che : \u00c9crivez quatre fonctions : <code>addition(int a, int b)</code>, <code>soustraction(int a, int b)</code>, <code>multiplication(int a, int b)</code>, et <code>division(int a, int b)</code>. Chaque fonction doit retourner le r\u00e9sultat du calcul. Dans <code>main</code>, testez chaque fonction avec des valeurs de votre choix et affichez les r\u00e9sultats.  </p> <p>Exercice 11 : Passage par Copie - Objectif : Constater l'effet d'un passage par copie. - T\u00e2che :   1. \u00c9crivez une fonction <code>ajouter_vingt(int nombre)</code> qui re\u00e7oit un entier, lui ajoute 20, et n'a pas de <code>return</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {10}</code>.   3. Appelez <code>ajouter_vingt(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?  </p> <p>Exercice 12 : Passage par R\u00e9f\u00e9rence - Objectif : Utiliser une r\u00e9f\u00e9rence pour modifier une variable externe. - T\u00e2che :   1. \u00c9crivez une fonction <code>reinitialiser(int&amp; nombre)</code> qui change la valeur de l'entier re\u00e7u \u00e0 <code>0</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {123}</code>.   3. Appelez <code>reinitialiser(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?  </p> <p>Exercice 13 : Somme d'un Tableau (Style C) - Objectif : Passer un tableau \u00e0 une fonction (m\u00e9thode classique). - T\u00e2che : Cr\u00e9ez une fonction <code>calculer_somme(const int tableau[], int taille)</code> qui retourne la somme de tous les \u00e9l\u00e9ments d'un tableau. Dans <code>main</code>, initialisez un tableau (ex: <code>int tableau[] {10, 20, 30};</code>), trouvez sa taille avec <code>std::ssize</code>, et affichez la somme retourn\u00e9e par votre fonction.  </p> <p>Exercice 14 : Trouver le Maximum - Objectif : Parcourir un tableau dans une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>trouver_max(const int tableau[], int taille)</code> qui retourne la plus grande valeur d'un tableau. Testez-la dans <code>main</code>.  </p> <p>Exercice 15 : Inversion de Tableau - Objectif : Modifier un tableau via une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau sur place (le premier devient le dernier, etc.). Dans <code>main</code>, d\u00e9clarez un tableau comme <code>int tableau[] {1, 2, 3, 4, 5};</code>, affichez-le, appelez la fonction, puis affichez-le \u00e0 nouveau pour voir le changement.  </p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-4-c-moderne-stdspan-vector","title":"Bloc 4 : C++ Moderne (std::span &amp; Vector)","text":"<p>Exercice 16 : La R\u00e8gle d'Or (std::span) - Objectif :   Remplacer le couple <code>(tableau, taille)</code> par <code>std::span</code>. - T\u00e2che :   1. Reprenez votre fonction <code>calculer_somme</code> de l'exercice 13.   2. Changez sa signature pour qu'elle prenne un <code>std::span&lt;const int&gt;</code> au lieu d'un tableau et une taille.   3. Dans <code>main</code>, cr\u00e9ez un tableau brut (<code>int t[]...</code>).   4. Appelez la fonction. Remarquez que vous n'avez plus besoin de passer la taille manuellement !  </p> <p>Exercice 17 : Optimisation avec R\u00e9f\u00e9rence Constante -   Objectif : \u00c9viter les copies inutiles sur les gros objets. - T\u00e2che :   1. \u00c9crivez une fonction <code>afficher_message(std::string message)</code> (par copie).   2. Modifiez-la pour utiliser le passage par r\u00e9f\u00e9rence constante (<code>const std::string&amp;</code>).   3. Ajoutez un <code>cout</code> dans la fonction pour v\u00e9rifier que le message s'affiche bien. Question : \u00c0 l'utilisation dans le <code>main</code>, est-ce que le code d'appel change ? (R\u00e9ponse attendue : Non, c'est transparent, mais plus rapide).  </p> <p>Exercice 18 : Vecteur Dynamique et Span - Objectif :   Utiliser un tableau qui peut grandir (<code>vector</code>) avec une fonction moderne. - T\u00e2che :   1. Incluez <code>&lt;vector&gt;</code>.   2. Cr\u00e9ez un <code>std::vector&lt;int&gt;</code> vide.   3. Utilisez une boucle <code>while</code> pour demander des nombres \u00e0 l'utilisateur. Ajoutez-les au vecteur avec <code>.push_back()</code>. Arr\u00eatez quand il tape -1.   4. Appelez votre fonction <code>calculer_somme</code> (celle avec le <code>std::span</code> de l'exercice 16) en lui passant ce vecteur. Observation : Notez que le <code>span</code> accepte aussi bien le tableau brut (Ex 16) que le vecteur (Ex 18).  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/","title":"Exercices suppl\u00e9mentaire semaine 1","text":""},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-1-le-valideur-dacces-focus-cin-robuste-fonctions","title":"Exercice 1 : Le Valideur d'Acc\u00e8s (Focus: <code>cin</code> robuste, fonctions)","text":"<p>Objectif : Ma\u00eetriser la saisie num\u00e9rique s\u00e9curitaire et l'appel de fonction simple.  </p> <p>Description : 1.  \u00c9crivez une fonction <code>bool est_majeur(int age)</code> qui retourne <code>true</code> si l'\u00e2ge est de 18 ans ou plus, et <code>false</code> sinon. 2.  Dans votre fonction <code>main</code>, demandez \u00e0 l'utilisateur d'entrer son \u00e2ge. 3.  Votre <code>main</code> doit utiliser une boucle <code>while</code> (comme vu dans les notes) pour forcer l'utilisateur \u00e0 entrer un nombre entier valide. Si l'utilisateur tape du texte, le programme doit afficher une erreur et redemander l'\u00e2ge. 4.  Une fois qu'un \u00e2ge valide est entr\u00e9, appelez la fonction <code>est_majeur</code> et affichez un message clair \u00e0 l'utilisateur, par exemple : \"Acc\u00e8s autoris\u00e9\" ou \"Acc\u00e8s refus\u00e9\".  </p> <p>Concepts Pratiqu\u00e9s : - Boucle de saisie robuste (<code>while</code>, <code>cin.fail</code>, <code>cin.clear</code>, <code>cin.ignore</code>). - Fonctions avec <code>return</code>. - Passage par copie.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-2-le-modificateur-de-profil-focus-passage-par-reference","title":"Exercice 2 : Le Modificateur de Profil (Focus: Passage par r\u00e9f\u00e9rence)","text":"<p>Objectif : Comprendre la diff\u00e9rence fondamentale entre une fonction qui peut modifier une variable et une qui ne le peut pas.  </p> <p>Description : 1.  Dans <code>main</code>, d\u00e9clarez deux variables : <code>int score {1000};</code> et <code>int niveau {5};</code>. 2.  \u00c9crivez une fonction <code>void appliquer_bonus(int&amp; score_actuel)</code> qui prend un score par r\u00e9f\u00e9rence et lui ajoute 500 points. 3.  \u00c9crivez une fonction <code>void simuler_defaite(int score_copie)</code> qui prend un score par copie, lui enl\u00e8ve 200 points et affiche un message \"Simulation : le score tombe \u00e0 [nouveau score]\". 4.  Dans <code>main</code> :     -   Affichez le score et le niveau initiaux.     -   Appelez <code>simuler_defaite(score);</code>.     -   Affichez le score. (A-t-il chang\u00e9 ?)     -   Appelez <code>appliquer_bonus(score);</code>.     -   Affichez le score final. (A-t-il chang\u00e9 ?)  </p> <p>Concepts Pratiqu\u00e9s : - Distinction claire entre passage par copie et par r\u00e9f\u00e9rence (<code>&amp;</code>). - Modification de l'\u00e9tat d'une variable du <code>main</code> depuis une fonction.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-3-lanalyseur-de-notes-focus-tableaux-stdssize","title":"Exercice 3 : L'Analyseur de Notes (Focus: Tableaux, <code>std::ssize</code>)","text":"<p>Objectif : Manipuler des tableaux et les passer \u00e0 des fonctions pour analyse.  </p> <p>Description : Vous allez cr\u00e9er un petit programme d'analyse statistique pour un tableau de notes. 1.  Dans <code>main</code>, initialisez un tableau de notes : <code>int notes[] {88, 76, 95, 54, 83, 65, 77};</code>. 2.  Utilisez <code>std::ssize</code> pour obtenir la taille du tableau et la stocker dans une variable <code>taille</code>. 3.  Cr\u00e9ez une fonction <code>double calculer_moyenne(const int tableau[], int taille)</code> qui calcule et retourne la moyenne des notes. 4.  Cr\u00e9ez une fonction <code>int trouver_note_maximale(const int tableau[], int taille)</code> qui trouve et retourne la meilleure note. 5.  Dans <code>main</code>, appelez vos deux fonctions avec le tableau <code>notes</code> et sa <code>taille</code>. Affichez les r\u00e9sultats de mani\u00e8re format\u00e9e (ex: \"Moyenne: 78.2, Note maximale: 95\").  </p> <p>Concepts Pratiqu\u00e9s : - D\u00e9claration et initialisation de tableaux. - Utilisation de <code>std::ssize</code> (C++20). - Passage de tableaux (et de leur taille) \u00e0 des fonctions. - Parcours de tableau avec une boucle <code>for</code>.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-4-linverseur-de-sequence-focus-algorithmique-sur-tableau","title":"Exercice 4 : L'Inverseur de S\u00e9quence (Focus: Algorithmique sur tableau)","text":"<p>Objectif : Modifier un tableau \"en place\" via une fonction.  </p> <p>Description : Le but est d'inverser l'ordre des \u00e9l\u00e9ments d'un tableau. Par exemple, <code>{10, 20, 30, 40, 50}</code> doit devenir <code>{50, 40, 30, 20, 10}</code>. 1.  \u00c9crivez une fonction <code>void afficher_tableau(const int tableau[], int taille)</code> qui affiche simplement le contenu d'un tableau sur une ligne. 2.  \u00c9crivez une fonction <code>void inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau in-place (sans cr\u00e9er un deuxi\u00e8me tableau temporaire). 3.  Dans <code>main</code> :     -   D\u00e9clarez un tableau, par exemple <code>int sequence[] {10, 20, 30, 40, 50};</code>.     -   Affichez le tableau original en utilisant votre fonction <code>afficher_tableau</code>.     -   Appelez <code>inverser_tableau</code>.     -   Affichez le tableau \u00e0 nouveau pour prouver qu'il a bien \u00e9t\u00e9 invers\u00e9.  </p> <p>Indice : Pour inverser, il suffit d'\u00e9changer le premier \u00e9l\u00e9ment avec le dernier, le deuxi\u00e8me avec l'avant-dernier, et ainsi de suite, en s'arr\u00eatant au milieu du tableau.  </p> <p>Concepts Pratiqu\u00e9s : - Algorithme simple (\u00e9change de variables). - Modification en place d'un tableau pass\u00e9 \u00e0 une fonction. - Parcours de tableau.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-5-le-repertoire-telephonique-focus-combinaison-de-concepts","title":"Exercice 5 : Le R\u00e9pertoire T\u00e9l\u00e9phonique (Focus: Combinaison de concepts)","text":"<p>Objectif : Combiner la gestion de <code>string</code>, les tableaux et le nettoyage du buffer.  </p> <p>Description : Cr\u00e9ez un mini-r\u00e9pertoire qui peut stocker 3 noms et 3 num\u00e9ros de t\u00e9l\u00e9phone. 1.  Dans <code>main</code>, d\u00e9clarez deux tableaux statiques de taille 3 :     -   <code>std::string noms[3];</code>     -   <code>std::string telephones[3];</code> 2.  Cr\u00e9ez une boucle <code>for</code> qui s'ex\u00e9cute 3 fois. \u00c0 chaque tour, elle doit :     -   Demander \u00e0 l'utilisateur son \u00e2ge (juste pour cr\u00e9er le pi\u00e8ge de <code>cin</code> !).     -   Demander son nom complet (doit accepter les espaces).     -   Demander son num\u00e9ro de t\u00e9l\u00e9phone (peut \u00eatre stock\u00e9 dans une <code>string</code>).     -   Stocker le nom et le t\u00e9l\u00e9phone dans les tableaux.     -   Attention : Assurez-vous de bien g\u00e9rer le buffer de <code>cin</code> pour que la lecture du nom complet fonctionne apr\u00e8s celle de l'\u00e2ge ! 3.  Une fois les 3 contacts entr\u00e9s, \u00e9crivez une fonction <code>void afficher_repertoire(const std::string noms[], const std::string telephones[], int taille)</code> qui affiche joliment la liste des contacts. 4.  Appelez cette fonction depuis <code>main</code> pour afficher le r\u00e9sultat.  </p> <p>Concepts Pratiqu\u00e9s : - Combinaison de <code>cin &gt;&gt;</code> et <code>getline</code>. - <code>std::cin.ignore()</code>. - Tableaux de <code>std::string</code>. - Passage de plusieurs tableaux \u00e0 une fonction.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-6-le-menu-interactif-robuste","title":"Exercice 6 : Le Menu Interactif Robuste","text":"<p>Objectif : Cr\u00e9er une application compl\u00e8te et robuste avec un menu, en utilisant des fonctions et une gestion d'erreurs avanc\u00e9e.  </p> <p>Description : 1.  Cr\u00e9ez un programme qui affiche un menu \u00e0 l'utilisateur : <pre><code>--- MENU ---  \n1. Calculer l'aire d'un cercle  \n2. V\u00e9rifier si un nombre est pair ou impair  \n3. Quitter  \nVotre choix :  \n</code></pre> 2.  Le programme doit tourner en boucle et r\u00e9-afficher le menu tant que l'utilisateur ne choisit pas l'option 3. 3.  La saisie du choix de menu doit \u00eatre robuste : si l'utilisateur entre du texte ou un nombre invalide (ex: 5), le programme doit afficher une erreur et redemander le choix. 4.  Option 1 : Appelle une fonction <code>calculer_aire_cercle()</code> qui demande \u00e0 l'utilisateur un rayon (de type <code>double</code>), g\u00e8re les erreurs de saisie pour le rayon, puis affiche l'aire (<code>\u03c0 * rayon\u00b2</code>). 5.  Option 2 : Appelle une fonction <code>verifier_parite()</code> qui demande un entier (en g\u00e9rant les erreurs), puis affiche si le nombre est pair ou impair. 6.  Option 3 : Termine le programme avec un message \"Au revoir !\". 7.  Si l'utilisateur entre un nombre autre que 1, 2, ou 3, affichez un message \"Option invalide\".  </p> <p>Concepts Pratiqu\u00e9s : - Boucle <code>while</code> principale pour le menu. - Boucles <code>while</code> internes pour la saisie robuste. - Fonctions distinctes pour chaque action. - Logique conditionnelle (<code>if</code>/<code>else if</code>/<code>else</code>).  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-7-statistiques-de-notes-avancees","title":"Exercice 7 : Statistiques de Notes Avanc\u00e9es","text":"<p>Objectif : Utiliser le passage par r\u00e9f\u00e9rence pour \"retourner\" plusieurs valeurs depuis une seule fonction.  </p> <p>Description : 1.  Dans <code>main</code>, initialisez un tableau de notes : <code>int notes[] {88, 76, 95, 54, 83, 65, 77, 91};</code>. 2.  \u00c9crivez une seule fonction <code>void calculer_statistiques(const int tableau[], int taille, double&amp; moyenne, int&amp; note_max, int&amp; note_min)</code>. 3.  Cette fonction ne retourne rien (<code>void</code>), mais elle calcule la moyenne, la note maximale et la note minimale et les place dans les variables pass\u00e9es par r\u00e9f\u00e9rence (<code>moyenne</code>, <code>note_max</code>, <code>note_min</code>). 4.  Dans <code>main</code> :     -   D\u00e9clarez trois variables pour recevoir les r\u00e9sultats : <code>double moyenne_resultat {};</code>, <code>int max_resultat {};</code>, <code>int min_resultat {};</code>.     -   Appelez <code>calculer_statistiques</code> en lui passant le tableau et les trois variables par r\u00e9f\u00e9rence.     -   Affichez les valeurs des trois variables de r\u00e9sultats pour prouver que la fonction les a bien modifi\u00e9es.  </p> <p>Concepts Pratiqu\u00e9s : - Param\u00e8tres de sortie (Output parameters) via le passage par r\u00e9f\u00e9rence. - Utilisation de <code>const</code> pour les param\u00e8tres d'entr\u00e9e qui ne doivent pas \u00eatre modifi\u00e9s. - Algorithmique (trouver un min/max).  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-8-le-palindrome","title":"Exercice 8 : Le Palindrome","text":"<p>Objectif : Impl\u00e9menter un algorithme simple en manipulant une cha\u00eene de caract\u00e8res comme un tableau.  </p> <p>Description : Un palindrome est un mot qui se lit de la m\u00eame mani\u00e8re \u00e0 l'endroit et \u00e0 l'envers (ex: \"radar\", \"level\", \"kayak\"). 1.  \u00c9crivez une fonction <code>bool est_palindrome(const std::string&amp; mot)</code>. 2.  \u00c0 l'int\u00e9rieur de cette fonction, utilisez une boucle pour comparer les caract\u00e8res du mot. Comparez le premier avec le dernier, le deuxi\u00e8me avec l'avant-dernier, et ainsi de suite, en s'arr\u00eatant au milieu. Si vous trouvez une paire de caract\u00e8res qui ne correspond pas, la fonction peut imm\u00e9diatement retourner <code>false</code>. Si la boucle se termine sans trouver de diff\u00e9rence, le mot est un palindrome.     - Indice : Vous n'avez pas besoin de cr\u00e9er une deuxi\u00e8me cha\u00eene invers\u00e9e. Travaillez avec deux index (un qui part du d\u00e9but et un qui part de la fin). 3.  Dans <code>main</code>, demandez un mot \u00e0 l'utilisateur, appelez votre fonction et affichez le r\u00e9sultat (ex: \"<code>radar</code> est un palindrome.\" ou \"<code>bonjour</code> n'est pas un palindrome.\").  </p> <p>Concepts Pratiqu\u00e9s : - Manipulation de <code>std::string</code> avec l'op\u00e9rateur <code>[]</code>. - Logique algorithmique (deux pointeurs/index). - Retour anticip\u00e9 (<code>return false;</code>) d\u00e8s qu'une condition est remplie.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-9-le-trieur-de-tableau-tri-a-bulles","title":"Exercice 9 : Le Trieur de Tableau (Tri \u00e0 Bulles)","text":"<p>Objectif : Impl\u00e9menter un algorithme de tri simple, un classique de l'informatique.  </p> <p>Description : Le tri \u00e0 bulles consiste \u00e0 parcourir un tableau plusieurs fois. \u00c0 chaque passage, on compare les \u00e9l\u00e9ments adjacents (l'\u00e9l\u00e9ment <code>i</code> et <code>i+1</code>) et on les \u00e9change s'ils sont dans le mauvais ordre. On r\u00e9p\u00e8te ces passages jusqu'\u00e0 ce que le tableau soit tri\u00e9. 1.  Dans <code>main</code>, d\u00e9clarez un tableau non tri\u00e9 : <code>int tableau[] {5, 1, 4, 2, 8, 3};</code>. 2.  Cr\u00e9ez une fonction <code>void tri_a_bulles(int tableau[], int taille)</code>. 3.  Dans cette fonction, impl\u00e9mentez l'algorithme :     -   Vous aurez besoin d'une boucle <code>for</code> imbriqu\u00e9e dans une autre.     -   La boucle externe contr\u00f4le le nombre de passages.     -   La boucle interne parcourt le tableau et compare les paires d'\u00e9l\u00e9ments.     -   Si <code>tableau[j]</code> est plus grand que <code>tableau[j+1]</code>, vous devez les \u00e9changer. Pour cela, vous pouvez utiliser une fonction <code>void echange(int&amp; a, int&amp; b)</code> que vous \u00e9crirez \u00e9galement (revoyez le passage par r\u00e9f\u00e9rence !). 4.  Dans <code>main</code>, affichez le tableau, appelez la fonction de tri, puis affichez \u00e0 nouveau le tableau pour montrer qu'il est maintenant tri\u00e9.  </p> <p>Concepts Pratiqu\u00e9s : - Algorithme de tri. - Boucles imbriqu\u00e9es. - Modification en place d'un tableau. - Fonction utilitaire (helper function) avec passage par r\u00e9f\u00e9rence.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-10-fusion-de-tableaux-tries","title":"Exercice 10 : Fusion de Tableaux Tri\u00e9s","text":"<p>Objectif : Manipuler plusieurs tableaux et g\u00e9rer plusieurs index simultan\u00e9ment.  </p> <p>Description : C'est une \u00e9tape cl\u00e9 de l'algorithme de \"tri fusion\" (merge sort). 1.  Dans <code>main</code>, d\u00e9clarez deux tableaux d\u00e9j\u00e0 tri\u00e9s :     -   <code>int tab1[] {10, 30, 50, 70};</code>     -   <code>int tab2[] {20, 40, 60};</code> 2.  Cr\u00e9ez une fonction <code>void fusionner(const int tab1[], int taille1, const int tab2[], int taille2, int resultat[])</code>. 3.  Cette fonction re\u00e7oit les deux tableaux sources et un troisi\u00e8me tableau <code>resultat</code> (qui doit \u00eatre assez grand pour contenir tous les \u00e9l\u00e9ments). Elle doit remplir <code>resultat</code> en piochant intelligemment dans <code>tab1</code> et <code>tab2</code> pour que <code>resultat</code> soit aussi tri\u00e9.     -   Indice : Vous aurez besoin de trois variables d'index : une pour votre position dans <code>tab1</code>, une pour <code>tab2</code>, et une pour <code>resultat</code>. 4.  Dans <code>main</code>, d\u00e9clarez un tableau <code>resultat</code> de la bonne taille, appelez votre fonction, puis affichez le tableau <code>resultat</code> pour v\u00e9rifier le travail. Le r\u00e9sultat attendu est <code>{10, 20, 30, 40, 50, 60, 70}</code>.  </p> <p>Concepts Pratiqu\u00e9s : - Algorithme de fusion. - Gestion de plusieurs index. - Utilisation d'un tableau comme \"param\u00e8tre de sortie\" (le tableau <code>resultat</code> est modifi\u00e9).  </p>"},{"location":"exercices/semaine_3_exercice_liste/","title":"Exercice de la Semaine 3 : Impl\u00e9mentation d'une Liste Cha\u00een\u00e9e Simple","text":"<p>Objectif : Comprendre les principes fondamentaux des structures de donn\u00e9es dynamiques en impl\u00e9mentant une liste cha\u00een\u00e9e simple en C++.  </p> <p>Contexte : Une liste cha\u00een\u00e9e est une structure de donn\u00e9es lin\u00e9aire o\u00f9 les \u00e9l\u00e9ments ne sont pas stock\u00e9s \u00e0 des emplacements m\u00e9moire contigus. Chaque \u00e9l\u00e9ment (appel\u00e9 \"n\u0153ud\") contient la donn\u00e9e et un pointeur vers le n\u0153ud suivant dans la s\u00e9quence.  </p>"},{"location":"exercices/semaine_3_exercice_liste/#instructions-generales","title":"Instructions G\u00e9n\u00e9rales :","text":"<ol> <li>Acceptez l'invitation suivante : https://classroom.github.com/a/0Jm7odXx  </li> <li>Dans toutes vos impl\u00e9mentations, utilisez <code>nullptr</code> pour repr\u00e9senter un pointeur nul. (pas de pointeur intelligent)  </li> <li>Vos <code>struct</code> ne doivent pas contenir de constructeur explicite.  </li> <li>Pour toutes les op\u00e9rations qui tentent d'acc\u00e9der ou de modifier un index hors des limites valides de la liste, vous devrez lever une exception de type <code>std::out_of_range</code>. Pour les op\u00e9rations sur une liste vide, levez une exception de type <code>std::runtime_error</code>.  </li> </ol>"},{"location":"exercices/semaine_3_exercice_liste/#partie-1-la-structure-de-base-nud","title":"Partie 1 : La Structure de Base (N\u0153ud)","text":"<ol> <li>Cr\u00e9ez un fichier d'en-t\u00eate <code>Noeud.hpp</code>.  </li> <li>Dans ce fichier, d\u00e9finissez une <code>struct</code> nomm\u00e9e <code>Noeud</code> qui contiendra :  <ul> <li>Un membre <code>int valeur</code> pour stocker la donn\u00e9e enti\u00e8re.  </li> <li>Un pointeur sur le Noeud suivant.  </li> <li>Une liste chain\u00e9e se termine quand le dernier pointeur est nul.  </li> </ul> </li> </ol>"},{"location":"exercices/semaine_3_exercice_liste/#partie-2-la-structure-de-la-liste-chainee","title":"Partie 2 : La Structure de la Liste Cha\u00een\u00e9e","text":"<ol> <li>Cr\u00e9ez un fichier d'en-t\u00eate <code>ListeChainee.hpp</code>.  </li> <li>Dans ce fichier, d\u00e9finissez une <code>struct</code> nomm\u00e9e <code>ListeChainee</code> qui contiendra :  <ul> <li>Un membre qui pointe sur le premier Noeud qui sera un pointeur nomm\u00e9 t\u00eate. Il devra \u00eatre initialis\u00e9 \u00e0 <code>nullptr</code>.  </li> <li>Un membre <code>int compte</code> pour garder une trace du nombre d'\u00e9l\u00e9ments dans la liste. Il devra \u00eatre initialis\u00e9 \u00e0 <code>0</code>.  </li> </ul> </li> </ol>"},{"location":"exercices/semaine_3_exercice_liste/#partie-3-les-fonctions-utilitaires-api-de-la-liste","title":"Partie 3 : Les Fonctions Utilitaires (API de la Liste)","text":"<ol> <li>Cr\u00e9ez un fichier d'en-t\u00eate <code>liste_outils.hpp</code>.  </li> <li> <p>Dans ce fichier, impl\u00e9mentez les fonctions suivantes. Ces fonctions devront op\u00e9rer sur une r\u00e9f\u00e9rence de <code>ListeChainee</code>.  </p> <ul> <li> <p><code>ListeChainee* creer_liste_vide();</code> </p> <ul> <li>Retourne une <code>ListeChainee</code> nouvellement initialis\u00e9e (vide).  </li> </ul> </li> <li> <p><code>void effacer_toute_la_liste(ListeChainee&amp; liste);</code> </p> <ul> <li>Lib\u00e8re toute la m\u00e9moire allou\u00e9e dynamiquement pour les n\u0153uds de la liste et r\u00e9initialise la liste \u00e0 un \u00e9tat vide.  </li> </ul> </li> <li> <p><code>void ajouter_valeur_debut(ListeChainee&amp; liste, int valeur);</code> </p> <ul> <li>Ajoute un nouveau n\u0153ud avec la <code>valeur</code> au d\u00e9but de la liste.  </li> </ul> </li> <li> <p><code>void ajouter_valeur_fin(ListeChainee&amp; liste, int valeur);</code> </p> <ul> <li>Ajoute un nouveau n\u0153ud avec la <code>valeur</code> \u00e0 la fin de la liste.  </li> </ul> </li> <li> <p><code>void ajouter_valeur_index(ListeChainee&amp; liste, int valeur, int index);</code> </p> <ul> <li>Ajoute un nouveau n\u0153ud avec la <code>valeur</code> \u00e0 l'index sp\u00e9cifi\u00e9.  </li> <li>Si <code>index &lt;= 0</code>, ajoute au d\u00e9but (index 0).  </li> <li>Si <code>index &gt;= liste.compte</code>, ajoute \u00e0 la fin.  </li> </ul> </li> <li> <p><code>int retirer_valeur_debut(ListeChainee&amp; liste);</code> </p> <ul> <li>Retire le premier n\u0153ud et retourne sa <code>valeur</code>.  </li> <li>L\u00e8ve <code>std::runtime_error</code> si la liste est vide.  </li> </ul> </li> <li> <p><code>int retirer_valeur_fin(ListeChainee&amp; liste);</code> </p> <ul> <li>Retire le dernier n\u0153ud et retourne sa <code>valeur</code>.  </li> <li>L\u00e8ve <code>std::runtime_error</code> si la liste est vide.  </li> </ul> </li> <li> <p><code>int retirer_valeur_index(ListeChainee&amp; liste, int index);</code> </p> <ul> <li>Retire le n\u0153ud \u00e0 l'index sp\u00e9cifi\u00e9 et retourne sa <code>valeur</code>.  </li> <li>L\u00e8ve <code>std::out_of_range</code> si l'index est invalide (n\u00e9gatif ou sup\u00e9rieur/\u00e9gal au nombre d'\u00e9l\u00e9ments) ou si la liste est vide.  </li> </ul> </li> <li> <p><code>int regarder_valeur_debut(const ListeChainee&amp; liste);</code> </p> <ul> <li>Retourne (sans retirer) la <code>valeur</code> du n\u0153ud au d\u00e9but de la liste.  </li> <li>L\u00e8ve <code>std::runtime_error</code> si la liste est vide.  </li> </ul> </li> <li> <p><code>int regarder_valeur_fin(const ListeChainee&amp; liste);</code> </p> <ul> <li>Retourne (sans retirer) la <code>valeur</code> du n\u0153ud \u00e0 la fin de la liste.  </li> <li>L\u00e8ve <code>std::runtime_error</code> si la liste est vide.  </li> </ul> </li> <li> <p><code>int regarder_valeur_index(const ListeChainee&amp; liste, int index);</code> </p> <ul> <li>Retourne (sans retirer) la <code>valeur</code> du n\u0153ud \u00e0 l'index sp\u00e9cifi\u00e9.  </li> <li>L\u00e8ve <code>std::out_of_range</code> si l'index est invalide (n\u00e9gatif ou sup\u00e9rieur/\u00e9gal au nombre d'\u00e9l\u00e9ments) ou si la liste est vide.  </li> </ul> </li> <li> <p><code>std::vector&lt;int&gt; to_array(const ListeChainee&amp; liste);</code> </p> <ul> <li>Cr\u00e9e et retourne un <code>std::vector&lt;int&gt;</code> contenant toutes les valeurs de la liste dans l'ordre actuel.  </li> </ul> </li> <li> <p>(Optionnel) <code>void afficher_liste(const ListeChainee&amp; liste);</code> </p> <ul> <li>Affiche les \u00e9l\u00e9ments de la liste dans la console, par exemple : <code>[10, 20, 30]</code>.  </li> </ul> </li> </ul> </li> </ol>"},{"location":"exercices/semaine_3_exercice_liste/#partie-4-demonstration-et-tests-maincpp","title":"Partie 4 : D\u00e9monstration et Tests (<code>main.cpp</code>)","text":"<ol> <li>Cr\u00e9ez un fichier <code>main.cpp</code>.  </li> <li>Dans ce fichier, \u00e9crivez le code qui :  <ul> <li>Cr\u00e9e une <code>ListeChainee</code> vide en utilisant <code>creer_liste_vide()</code>.  </li> <li>Ajoute plusieurs \u00e9l\u00e9ments en utilisant <code>ajouter_valeur_debut</code>, <code>ajouter_valeur_fin</code>, et <code>ajouter_valeur_index</code>.  </li> <li>Teste les fonctions de consultation (<code>regarder_valeur_debut</code>, <code>regarder_valeur_fin</code>, <code>regarder_valeur_index</code>) et affiche les r\u00e9sultats.  </li> <li>Retire des \u00e9l\u00e9ments en utilisant <code>retirer_valeur_debut</code>, <code>retirer_valeur_fin</code>, et <code>retirer_valeur_index</code>.  </li> <li>Affiche l'\u00e9tat de la liste (nombre d'\u00e9l\u00e9ments, contenu via <code>to_array</code> ou <code>afficher_liste</code>) apr\u00e8s chaque op\u00e9ration significative.  </li> <li>Impl\u00e9mente des blocs <code>try-catch</code> pour tester et g\u00e9rer les cas d'erreur (tentative de retirer/regarder dans une liste vide, index invalide).  </li> <li>\u00c0 la fin, utilise <code>effacer_toute_la_liste</code> pour lib\u00e9rer proprement toute la m\u00e9moire.  </li> </ul> </li> </ol>"},{"location":"exercices/solution/examen_formatif_solution/","title":"Corrig\u00e9 - Examen Formatif : Les Bases du C++","text":""},{"location":"exercices/solution/examen_formatif_solution/#question-1-initialisation-de-variable-primitive","title":"Question 1 : Initialisation de variable primitive","text":"<p>R\u00e9ponse : <code>double vitesse { 9.8 };</code> </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-2-initialisation-de-struct-sur-la-pile-stack","title":"Question 2 : Initialisation de struct sur la PILE (Stack)","text":"<p>R\u00e9ponse : <code>Position pos { 10, 20 };</code> (Note : L'ordre 10, 20 correspond \u00e0 l'ordre de d\u00e9claration x, y dans la struct). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-3-erreur-de-compilation-narrowing-conversion","title":"Question 3 : Erreur de compilation (Narrowing conversion)","text":"<p>R\u00e9ponse : L'utilisation des accolades <code>{}</code> interdit les \"narrowing conversions\" (conversions affaiblissantes), c'est-\u00e0-dire les conversions qui entra\u00eenent une perte de pr\u00e9cision (ici, passer de <code>15.75</code> \u00e0 <code>15</code>). Si on avait utilis\u00e9 <code>=</code>, le code compilerait mais la valeur serait tronqu\u00e9e \u00e0 <code>15</code> sans avertissement bloquant, ce qui est une source fr\u00e9quente de bogues.  </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-4-initialisation-par-defaut","title":"Question 4 : Initialisation par d\u00e9faut","text":"<p>R\u00e9ponse : <code>0</code> (L'initialisation avec des accolades vides <code>{}</code> garantit une mise \u00e0 z\u00e9ro des types primitifs). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-5-gestion-du-buffer-cin","title":"Question 5 : Gestion du Buffer (cin)","text":"<p>R\u00e9ponse : Le caract\u00e8re de saut de ligne  (g\u00e9n\u00e9r\u00e9 par la touche Entr\u00e9e). (C'est ce caract\u00e8re r\u00e9siduel qui fait souvent \u00e9chouer le prochain 'getline'). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-6-passage-de-parametres-performance","title":"Question 6 : Passage de Param\u00e8tres (Performance)","text":"<p>R\u00e9ponse : <code>void afficher(const GrosseDonnee&amp; donnee);</code> (Le passage par r\u00e9f\u00e9rence constante \u00e9vite la copie et garantit que la fonction ne modifiera pas l'original). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-7-pointers-trace-dexecution","title":"Question 7 : Pointers (Trace d'ex\u00e9cution)","text":"<p>R\u00e9ponse : <code>15</code> (p pointe vers a, donc <code>*p = *p + 10</code> modifie directement a : <code>5 + 10 = 15</code>. Mettre <code>p</code> \u00e0 <code>nullptr</code> ensuite ne change pas la valeur de a). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-8-tableaux-bruts-transfert","title":"Question 8 : Tableaux Bruts (Transfert)","text":"<p>R\u00e9ponse : - Appel : <code>analyser(scores, 3);</code> // ou <code>analyser(scores, std::ssize(scores));</code> - Signature : <code>void analyser(int tab[], int taille);</code> // ou <code>(int* tab, int taille)</code> </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-9-c20-stdspan","title":"Question 9 : C++20 (std::span)","text":"<p>R\u00e9ponse : <code>void analyser(std::span&lt;int&gt; tab);</code> (Note : Le span encapsule \u00e0 la fois le pointeur et la taille). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-10-references-modification","title":"Question 10 : R\u00e9f\u00e9rences (Modification)","text":"<p>R\u00e9ponse : <pre><code>void reinitialiser(int&amp; n) {  \n    n = 0;  \n}  \n</code></pre></p>"},{"location":"exercices/solution/examen_formatif_solution/#question-11-acces-memoire-syntaxe-fleche","title":"Question 11 : Acc\u00e8s M\u00e9moire (Syntaxe fl\u00e8che)","text":"<p>R\u00e9ponse : <code>ptr-&gt;y = 100;</code> </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-12-organisation-des-fichiers-syntaxe-cpp","title":"Question 12 : Organisation des fichiers (Syntaxe CPP)","text":"<p>R\u00e9ponse : <code>void Position::afficher() const { ... }</code> (L'op\u00e9rateur de port\u00e9e <code>::</code> est indispensable pour lier la fonction \u00e0 la structure Position). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-13-memoire-sur-le-tas-heap","title":"Question 13 : M\u00e9moire sur le Tas (Heap)","text":"<p>R\u00e9ponse : <code>int* p_dynamique = new int { 500 };</code> </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-14-danger-des-variables-locales","title":"Question 14 : Danger des variables locales","text":"<p>R\u00e9ponse : La variable <code>local</code> est allou\u00e9e sur la pile. Elle est d\u00e9truite automatiquement d\u00e8s que la fonction se termine. Le pointeur retourn\u00e9 devient alors un \"pointeur pendant\" (dangling pointer) pointant vers une zone m\u00e9moire qui n'est plus valide.  </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-15-algorithme-et-taille-stdssize","title":"Question 15 : Algorithme et Taille (std::ssize)","text":"<p>R\u00e9ponse : <pre><code>for (int i = 0; i &lt; std::ssize(notes); ++i) {  \n    std::cout &lt;&lt; notes[i] &lt;&lt; std::endl;  \n}  \n</code></pre></p>"},{"location":"exercices/solution/examen_formatif_solution/#question-16-liste-chainee-passage-par-reference-de-pointeur","title":"Question 16 : Liste cha\u00een\u00e9e (Passage par r\u00e9f\u00e9rence de pointeur)","text":"<p>R\u00e9ponse : <code>void ajouterDebut(Noeud*&amp; premier)</code> (Il faut une r\u00e9f\u00e9rence sur le pointeur pour que la modification de l'adresse contenue dans 'premier' soit visible \u00e0 l'ext\u00e9rieur de la fonction). </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-17-suppression-dans-une-liste-chainee","title":"Question 17 : Suppression dans une liste cha\u00een\u00e9e","text":"<p>R\u00e9ponse : 1. <code>Noeud* aSupprimer = curseur-&gt;suivant;</code> 2. <code>curseur-&gt;suivant = aSupprimer-&gt;suivant;</code> 3. <code>delete aSupprimer;</code> </p>"},{"location":"exercices/solution/examen_formatif_solution/#question-18-modelisation-complexe-train-et-wagons","title":"Question 18 : Mod\u00e9lisation complexe (Train et Wagons)","text":"<p>R\u00e9ponse : <pre><code>struct Conteneur {  \n    int tonnes;  \n};  \n\nstruct Wagon {  \n    Conteneur* conteneur1; // Pointeur vers le 1er conteneur  \n    Conteneur* conteneur2; // Pointeur vers le 2e conteneur  \n    Wagon* suivant;        // Lien vers le wagon suivant  \n};  \n\nstruct Locomotive {  \n    Wagon* wagon_attache;   // Pointeur vers le premier wagon  \n};  \n\nstruct Train {  \n    Locomotive* locomotive; // Pointeur vers la locomotive  \n};  \n</code></pre></p>"},{"location":"notes/semaine_1_0_introduction/","title":"Notes de la Semaine 1","text":""},{"location":"notes/semaine_1_0_introduction/#sujets-abordes","title":"Sujets Abord\u00e9s","text":"<ul> <li>Pr\u00e9sentation du cours  </li> <li>Environnement de d\u00e9veloppement C++ (IDE, compilateur)  </li> <li>Concepts de base du C++ (variables, types, op\u00e9rateurs)  </li> </ul>"},{"location":"notes/semaine_1_0_introduction/#exercices-et-laboratoires","title":"Exercices et Laboratoires","text":"<ul> <li>Configuration de l'environnement  </li> <li>Premiers programmes \"Hello World\"  </li> </ul>"},{"location":"notes/semaine_1_0_introduction/#remarques","title":"Remarques","text":"<ul> <li>Assurez-vous que votre environnement de d\u00e9veloppement est fonctionnel avant le prochain cours.  </li> <li>Consultez le plan de cours pour les lectures et pr\u00e9parations.  </li> </ul>"},{"location":"notes/semaine_1_0_introduction/#la-fonction-main-en-c","title":"La fonction <code>main()</code> en C++","text":"<p>La fonction <code>main()</code> est le point d'entr\u00e9e de chaque programme C++. C'est l\u00e0 que l'ex\u00e9cution de votre code commence.  </p>"},{"location":"notes/semaine_1_0_introduction/#main-sans-arguments","title":"<code>main()</code> sans arguments","text":"<p>La forme la plus simple de <code>main()</code> ne prend pas d'arguments. <pre><code>#include &lt;iostream&gt;  \n\nint main() {  \n    std::cout &lt;&lt; \"Bonjour !\" &lt;&lt; std::endl;  \n    return 0; // Indique que le programme s'est ex\u00e9cut\u00e9 avec succ\u00e8s  \n}  \n</code></pre></p>"},{"location":"notes/semaine_1_0_introduction/#return-int-vs-void-main-c","title":"<code>return int</code> vs <code>void Main</code> (C#)","text":"<p>Contrairement \u00e0 C# o\u00f9 la fonction <code>Main</code> peut \u00eatre <code>void</code>, la fonction <code>main()</code> en C++ doit retourner un <code>int</code>.  </p> <ul> <li><code>return 0;</code> : Conventionnellement, un retour de <code>0</code> indique que le programme s'est termin\u00e9 avec succ\u00e8s.  </li> <li><code>return un_nombre_non_nul;</code> : Un retour diff\u00e9rent de <code>0</code> (ex: <code>1</code>) indique qu'une erreur s'est produite. Ce code peut \u00eatre utilis\u00e9 par d'autres programmes ou scripts pour d\u00e9tecter un probl\u00e8me.  </li> </ul>"},{"location":"notes/semaine_1_0_introduction/#entrees-et-sorties-en-c-avec-iostream","title":"Entr\u00e9es et Sorties en C++ avec <code>iostream</code>","text":"<p>La m\u00e9thode standard et s\u00e9curitaire pour g\u00e9rer les entr\u00e9es et sorties en C++ est la biblioth\u00e8que <code>&lt;iostream&gt;</code>. Elle utilise des flux (<code>streams</code>) pour envoyer ou recevoir des donn\u00e9es.  </p> <ul> <li><code>std::cout</code> : Flux de sortie standard (g\u00e9n\u00e9ralement la console).  </li> <li><code>std::cin</code> : Flux d'entr\u00e9e standard (g\u00e9n\u00e9ralement le clavier).  </li> <li><code>std::endl</code> : Ins\u00e8re un retour \u00e0 la ligne (<code>\\n</code>) et vide le tampon de sortie.  </li> </ul> <pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n\nint main() {  \n    std::string nom;  \n    std::cout &lt;&lt; \"Entrez votre nom : \";  \n    std::cin &gt;&gt; nom;  \n\n    std::cout &lt;&lt; \"Bonjour \" &lt;&lt; nom &lt;&lt; \" !\" &lt;&lt; std::endl;  \n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_1_0_introduction/#piege-n1-melanger-cin-et-getline","title":"Pi\u00e8ge n\u00b01 : M\u00e9langer <code>cin &gt;&gt;</code> et <code>getline</code>","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> lit les donn\u00e9es jusqu'au premier espace blanc (espace, tabulation, retour \u00e0 la ligne). Le reste, y compris le <code>\\n</code> que vous tapez avec <code>Entr\u00e9e</code>, reste dans le buffer (tampon) d'entr\u00e9e.  </p> <p>\u274c Code probl\u00e9matique : <pre><code>int age;  \nstd::string nom_complet;  \n\nstd::cout &lt;&lt; \"Entrez votre age : \";  \nstd::cin &gt;&gt; age; // L'utilisateur tape \"25\" puis \"Entr\u00e9e\".  \n                 // \"25\" est lu, mais \"\\n\" reste dans le buffer.  \n\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";  \nstd::getline(std::cin, nom_complet); // getline() voit le \"\\n\" restant et croit  \n                                     // que l'utilisateur a d\u00e9j\u00e0 entr\u00e9 une ligne vide.  \n                                     // Il ne demande pas d'input.  \n\nstd::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;  \n// Affiche : Age: 25, Nom: ''  \n</code></pre></p> <p>\u2705 Solution : Vider le buffer avant <code>getline</code> On utilise <code>std::cin.ignore()</code> pour ignorer les caract\u00e8res restants dans le buffer, notamment le <code>\\n</code>.  </p> <pre><code>// ... apr\u00e8s std::cin &gt;&gt; age;  \nstd::cin.ignore(); // Ignore LE caract\u00e8re suivant. Soit le \\n restant  \nstd::cout &lt;&lt; \"Entrez votre nom complet : \";  \nstd::getline(std::cin, nom_complet); // Fonctionne comme pr\u00e9vu  \n</code></pre>"},{"location":"notes/semaine_1_0_introduction/#piege-n2-erreur-de-type-lettres-pour-un-nombre","title":"Pi\u00e8ge n\u00b02 : Erreur de type (lettres pour un nombre)","text":"<p>Si l'utilisateur entre des lettres alors que <code>std::cin &gt;&gt;</code> s'attend \u00e0 un <code>int</code>, le flux <code>cin</code> entre en \u00e9tat d'erreur (<code>failbit</code>). Toute tentative de lecture ult\u00e9rieure \u00e9chouera tant que l'erreur n'est pas corrig\u00e9e et le buffer vid\u00e9.  </p> <p>Pour g\u00e9rer robustement les erreurs de saisie : </p> <ol> <li>V\u00e9rifier l'\u00e9tat de <code>cin</code> : Boucler tant que la lecture \u00e9choue.  </li> <li>Nettoyer les indicateurs d'erreur : <code>std::cin.clear()</code> r\u00e9initialise l'\u00e9tat de <code>cin</code>.  </li> <li>Vider le buffer : <code>std::cin.ignore(...)</code> jette le contenu invalide.  </li> </ol> <p>\u2705 Solution robuste : </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;limits&gt; // Requis pour numeric_limits  \n\nint main() {  \n    int age = 0;  \n\n    // Boucle tant que l'entr\u00e9e est invalide  \n    while (true) {  \n        std::cout &lt;&lt; \"Veuillez entrer votre age : \";  \n        std::cin &gt;&gt; age;  \n\n        if (std::cin.good()) {  \n            // La saisie est un nombre valide, on peut sortir de la boucle.  \n            break;  \n        }  \n\n        // Si on arrive ici, la saisie a \u00e9chou\u00e9.  \n        std::cout &lt;&lt; \"Erreur : Veuillez entrer un nombre valide.\" &lt;&lt; std::endl;  \n\n        // 1. Nettoyer l'indicateur d'erreur de cin  \n        std::cin.clear();  \n\n        // 2. Vider le buffer d'entr\u00e9e  \n        // On ignore tous les caract\u00e8res jusqu'\u00e0 la prochaine fin de ligne '\\n'.  \n        // C'est la mani\u00e8re idiomatique et s\u00e9curitaire de le faire.  \n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');  \n    }  \n\n    std::cout &lt;&lt; \"Vous avez \" &lt;&lt; age &lt;&lt; \" ans.\" &lt;&lt; std::endl;  \n\n    return 0;  \n}  \n</code></pre> <p>Attention aux Nombres Magiques</p> <p>Vous verrez parfois <code>std::cin.ignore(10000, '\\n');</code>. C'est une mauvaise pratique. On suppose arbitrairement que l'utilisateur ne tapera pas plus de 10 000 caract\u00e8res invalides.  </p> <p>La m\u00e9thode correcte, <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');</code>, est la fa\u00e7on C++ standard de dire \"ignorer autant de caract\u00e8res que n\u00e9cessaire\". Elle ne repose sur aucune supposition.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/","title":"Les Types de Donn\u00e9es Fondamentaux","text":"<p>Voici la liste des types fondamentaux \u00e0 utiliser en C++.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/#1-types-entiers-et-logiques","title":"1. Types Entiers et Logiques","text":"<p>Utilis\u00e9s pour compter, indexer ou g\u00e9rer des \u00e9tats.  </p> Type Taille Description Plage de Valeurs (Min / Max) <code>bool</code> 1 octet Logique pure <code>true</code> (1) ou <code>false</code> (0) <code>int</code> 4 octets Entier standard (Sign\u00e9) -2 147 483 648 \u00e0 +2 147 483 647 <code>unsigned int</code> 4 octets Entier positif 0 \u00e0 4 294 967 295 <code>long long</code> 8 octets Grand entier (Sign\u00e9) -9 Quintillions \u00e0 +9 Quintillions"},{"location":"notes/semaine_1_1_types_de_donnees/#2-types-de-caracteres","title":"2. Types de Caract\u00e8res","text":"<p>Un <code>char</code> fait 1 octet (8 bits).  </p> Type Usage Recommand\u00e9 <code>char</code> Texte ASCII standard. (Lettres simples). <code>char8_t</code> Texte UTF-8 (C++20). Cha\u00eenes <code>u8\"...\"</code>."},{"location":"notes/semaine_1_1_types_de_donnees/#3-types-a-virgule-flottante","title":"3. Types \u00e0 Virgule Flottante","text":"<p>Utilis\u00e9s pour les nombres \u00e0 d\u00e9cimales (r\u00e9els).  </p> Type Taille Pr\u00e9cision <code>double</code> 8 octets Standard (~15 chiffres) <code>float</code> 4 octets Faible (~7 chiffres)"},{"location":"notes/semaine_1_1_types_de_donnees/#4-initialisation-des-variables-c20","title":"4. Initialisation des Variables (C++20)","text":"<p>Privil\u00e9giez l'initialisation avec des accolades <code>{}</code> pour \u00e9viter les conversions dangereuses.  </p> <p>Syntaxe : <code>Type nom { valeur };</code> </p> Exemple Correct Pourquoi ? <code>int age { 25 };</code> Initialise <code>age</code> \u00e0 25. <code>double prix { 19.99 };</code> Initialise <code>prix</code> \u00e0 19.99. <code>int x {};</code> Initialise <code>x</code> \u00e0 0. <p>Protection contre les erreurs : <pre><code>int a = 3.9;  // \u26a0\ufe0f DANGEREUX : Compile, mais 'a' vaut 3 (perte de 0.9).  \nint b { 3.9 }; // \ud83d\uded1 ERREUR : Le compilateur refuse de perdre des donn\u00e9es.  \n</code></pre></p>"},{"location":"notes/semaine_1_1_types_de_donnees/#5-manipulation-des-chaines-de-caracteres-en-c","title":"5. Manipulation des Cha\u00eenes de Caract\u00e8res en C++","text":"<p>En C++, le texte ne se g\u00e8re pas avec des tableaux de <code>char</code> (trop dangereux), mais avec la classe standard <code>std::string</code>.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/#les-bases-de-stdstring","title":"Les Bases de <code>std::string</code>","text":"<p>Pour utiliser les cha\u00eenes, vous devez inclure <code>&lt;string&gt;</code>.  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt; // Indispensable  \n\nint main() {  \n    // 1. D\u00e9claration et Initialisation  \n    std::string nom { \"Mario\" };  \n    std::string salutation { \"Bonjour\" };  \n\n    // 2. Concat\u00e9nation (Coller des morceaux)  \n    // On utilise simplement le signe '+'  \n    std::string message = salutation + \" \" + nom + \" !\";  \n    // R\u00e9sultat : \"Bonjour Mario !\"  \n\n    // 3. Acc\u00e8s aux lettres  \n    char premiereLettre = nom[0]; // 'M'  \n    nom[0] = 'W'; // Mario devient Wario  \n}  \n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#operations-courantes","title":"Op\u00e9rations Courantes","text":"<p>Voici les m\u00e9thodes que vous utiliserez dans 90% des cas avec <code>std::string</code>.  </p> Op\u00e9ration M\u00e9thode Exemple R\u00e9sultat Longueur <code>.size()</code> ou <code>.length()</code> <code>nom.size()</code> <code>5</code> (nombre d'octets) Vide ? <code>.empty()</code> <code>nom.empty()</code> <code>false</code> (si contient du texte) Vider <code>.clear()</code> <code>nom.clear()</code> La cha\u00eene devient vide <code>\"\"</code> Ajouter <code>+=</code> ou <code>.append()</code> <code>nom += \" Bros\"</code> <code>\"Mario Bros\"</code> Comparer <code>==</code> ou <code>!=</code> <code>nom == \"Luigi\"</code> <code>false</code> Trouver <code>.find(\"texte\")</code> <code>msg.find(\"jour\")</code> Retourne l'index ou <code>std::string::npos</code> si absent. Sous-cha\u00eene <code>.substr(pos, len)</code> <code>msg.substr(0, 3)</code> Extrait une partie du texte (ex: les 3 premi\u00e8res lettres)."},{"location":"notes/semaine_1_1_types_de_donnees/#copier-et-extraire-des-sous-chaines","title":"Copier et Extraire des Sous-Cha\u00eenes","text":"<p>Copie Compl\u00e8te L'assignation <code>=</code> cr\u00e9e une copie enti\u00e8rement nouvelle et ind\u00e9pendante.  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n#include &lt;format&gt; // N\u00e9cessaire pour std::format  \n\nint main() {  \n    std::string original {\"Bonjour le monde\"};  \n    std::string copie {original}; // Cr\u00e9e une copie compl\u00e8te  \n\n    // Modifier la copie n'affecte pas l'original  \n    copie[0] = 'A';  \n\n    std::cout &lt;&lt; std::format(\"Original : {}\\n\", original); // Affiche \"Bonjour le monde\"  \n    std::cout &lt;&lt; std::format(\"Copie    : {}\\n\", copie);    // Affiche \"Aonjour le monde\"  \n    return 0;  \n}  \n</code></pre> <p>Copie d'une Sous-Cha\u00eene (<code>.substr()</code>) La m\u00e9thode <code>.substr(position_depart, longueur)</code> extrait une partie de la cha\u00eene et en retourne une nouvelle copie.  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n\nint main() {  \n    std::string phrase {\"Le C++ est fantastique\"};  \n\n    // Extrait 3 caract\u00e8res \u00e0 partir de l'index 3  \n    std::string mot_cpp {phrase.substr(3, 3)};  \n\n    // Extrait tout le reste \u00e0 partir de l'index 12  \n    std::string mot_fantastique {phrase.substr(12)};  \n\n    std::cout &lt;&lt; \"Mot 1: \" &lt;&lt; mot_cpp &lt;&lt; std::endl; // Affiche \"C++\"  \n    std::cout &lt;&lt; \"Mot 2: \" &lt;&lt; mot_fantastique &lt;&lt; std::endl; // Affiche \"fantastique\"  \n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#le-defi-des-accents-stdstring-vs-stdwstring","title":"Le D\u00e9fi des Accents : <code>std::string</code> vs <code>std::wstring</code>","text":"<p>G\u00e9rer les accents en C++ est complexe car <code>std::string</code> a \u00e9t\u00e9 con\u00e7u pour l'anglais. Pour C++, une cha\u00eene n'est pas une liste de lettres, c'est une liste d'octets. Avec l'encodage moderne (UTF-8), un caract\u00e8re accentu\u00e9 (<code>\u00e9</code>) p\u00e8se plusieurs octets.  </p> <p>Cons\u00e9quence : Si vous prenez le mot <code>\"\u00e9t\u00e9\"</code>, C++ voit 5 octets (2 pour le <code>\u00e9</code>, 1 pour le <code>t</code>, 2 pour le <code>\u00e9</code>). <code>\"\u00e9t\u00e9\".size()</code> renverra <code>5</code>. <code>.substr(1, 1)</code> tentera de couper un caract\u00e8re au milieu d'un octet, produisant un r\u00e9sultat corrompu.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/#la-solution-simple-pour-ce-cours-stdwstring","title":"La Solution Simple (pour ce cours) : <code>std::wstring</code>","text":"<p>Bien que ce ne soit pas la solution universelle dans le monde professionnel (pour des raisons de portabilit\u00e9), <code>std::wstring</code> est la mani\u00e8re la plus simple de manipuler des cha\u00eenes avec accents dans nos exercices. Chaque caract\u00e8re, accentu\u00e9 ou non, y occupe une seule \"case\".  </p> <p>Configurer la console pour les <code>wchar_t</code></p> <p>Pour que la console affiche correctement les caract\u00e8res larges, il faut inclure <code>&lt;locale&gt;</code>, utiliser le pr\u00e9fixe <code>L\"\"</code> pour vos cha\u00eenes, et <code>std::wcout</code> pour l'affichage.  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n#include &lt;locale&gt; // Pour setlocale  \n\nint main() {  \n    // 1. Configure la locale pour permettre l'affichage des caract\u00e8res larges  \n    std::setlocale(LC_ALL, \"\");  \n\n    // 2. On utilise wstring et le pr\u00e9fixe L\"\"  \n    std::wstring ws = L\"\u00e9t\u00e9\";  \n\n    // 3. substr() fonctionne maintenant logiquement  \n    // On veut le 2\u00e8me caract\u00e8re, qui est bien \u00e0 l'index 1.  \n    std::wstring sub = ws.substr(1, 1);  \n\n    // 4. On utilise wcout pour afficher des wstring  \n    std::wcout &lt;&lt; L\"La sous-chaine de '\u00e9t\u00e9' (pos 1, len 1) est : '\" &lt;&lt; sub &lt;&lt; L\"'\" &lt;&lt; std::endl; // Affiche 't'  \n\n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#decouper-une-chaine-equivalent-de-split","title":"D\u00e9couper une Cha\u00eene (\u00c9quivalent de <code>.split()</code>)","text":"<p><code>std::string</code> n'a pas de m\u00e9thode <code>.split()</code> int\u00e9gr\u00e9e. La technique standard est d'utiliser un outil tr\u00e8s puissant de la biblioth\u00e8que <code>&lt;sstream&gt;</code> : le <code>std::stringstream</code>.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/#focus-sur-stdstringstream-un-stdcin-pour-vos-chaines","title":"Focus sur <code>std::stringstream</code> : Un <code>std::cin</code> pour vos Cha\u00eenes","text":"<p>Imaginez que votre cha\u00eene de caract\u00e8res est un long ruban de machine \u00e0 \u00e9crire. Le <code>stringstream</code> est la t\u00eate de lecture pos\u00e9e sur ce ruban.  </p> <pre><code>#include &lt;sstream&gt; // Indispensable  \n\nstd::string ma_chaine = \"mot1 mot2 mot3\";  \n\n// On charge notre \"ruban\" (la cha\u00eene) dans la t\u00eate de lecture.  \n// Un curseur de lecture invisible est automatiquement plac\u00e9 au tout d\u00e9but.  \nstd::stringstream flux {ma_chaine};  \n</code></pre> <ul> <li>Comme un buffer d'entr\u00e9e : Le <code>stringstream</code> se comporte exactement comme <code>std::cin</code>. Vous pouvez lire des donn\u00e9es avec l'op\u00e9rateur <code>&gt;&gt;</code> ou avec la fonction <code>std::getline</code>.  </li> <li>Curseur interne : \u00c0 chaque op\u00e9ration de lecture, le curseur avance sur le \"ruban\". Si vous lisez <code>\"mot1\"</code>, le curseur se place juste apr\u00e8s, pr\u00eat \u00e0 lire <code>\"mot2\"</code>. Le flux \"d\u00e9file\" \u00e0 mesure que vous le lisez.  </li> <li>Repositionnement (<code>seek</code>) : Il est m\u00eame possible de manipuler ce curseur, de le remettre au d\u00e9but (<code>flux.seekg(0)</code>) ou d'aller \u00e0 une position pr\u00e9cise, un peu comme on rembobine une cassette (m\u00eame si c'est un usage plus avanc\u00e9).  </li> </ul> <p>C'est cet objet qui nous permet de \"parcourir\" une cha\u00eene pour en extraire des morceaux s\u00e9quentiellement.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/#methode-1-decouper-selon-les-espaces","title":"M\u00e9thode 1 : D\u00e9couper selon les espaces","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> extrait des \"mots\" en s'arr\u00eatant \u00e0 n'importe quel \"espace blanc\" (espace, tabulation, retour \u00e0 la ligne).  </p> <pre><code>#include &lt;sstream&gt;  \n#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n\nstd::string phrase {\"J'aime\\tle C++\\nmoderne\"};  \nstd::stringstream flux {phrase};  \nstd::string mot;  \n\nwhile (flux &gt;&gt; mot) {  \n    // La boucle extrait \"J'aime\", puis \"le\", \"C++\", et \"moderne\"  \n    std::cout &lt;&lt; \"- \" &lt;&lt; mot &lt;&lt; std::endl;  \n}  \n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#methode-2-decouper-selon-un-delimiteur-specifique","title":"M\u00e9thode 2 : D\u00e9couper selon un d\u00e9limiteur sp\u00e9cifique","text":"<p>Pour d\u00e9couper selon un caract\u00e8re pr\u00e9cis (ex: une virgule), on utilise <code>std::getline</code> avec le flux.  </p> <p>Recette : 1.  Cr\u00e9ez un <code>stringstream</code> \u00e0 partir de la cha\u00eene source. 2.  Cr\u00e9ez une <code>std::string</code> temporaire pour chaque morceau (\"segment\"). 3.  Utilisez une boucle <code>while (std::getline(mon_flux, segment, 'DELIMITEUR'))</code>.  </p>"},{"location":"notes/semaine_1_1_types_de_donnees/#exemple-pratique-sommer-des-nombres-dans-une-chaine","title":"Exemple Pratique : Sommer des Nombres dans une Cha\u00eene","text":"<pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n#include &lt;sstream&gt;  \n\nint main() {  \n    std::string data {\"10,20,30,40,50\"};  \n    std::stringstream ss {data};  \n    std::string segment;  \n    int somme {0};  \n\n    // 1. On boucle sur le flux, en utilisant la virgule ',' comme d\u00e9limiteur.  \n    while(std::getline(ss, segment, ',')) {  \n        // segment contient successivement \"10\", puis \"20\", ...  \n\n        // 2. On convertit le segment (string) en entier.  \n        int nombre { std::stoi(segment) };  \n\n        // 3. On l'ajoute \u00e0 la somme.  \n        somme += nombre;  \n    }  \n\n    std::cout &lt;&lt; \"La somme finale est : \" &lt;&lt; somme &lt;&lt; std::endl;  \n    return 0;  \n}  \n</code></pre> <p>Que signifie <code>std::stoi</code> ?</p> <p><code>stoi</code> est l'abr\u00e9viation de String To Integer (cha\u00eene vers entier). C'est une fonction de la biblioth\u00e8que <code>&lt;string&gt;</code> qui analyse une cha\u00eene de caract\u00e8res et retourne sa repr\u00e9sentation num\u00e9rique en tant qu'<code>int</code>. Il existe des fonctions similaires pour d'autres types, comme <code>stod</code> (String To Double).  </p>"},{"location":"notes/semaine_1_2_tableau/","title":"4. Les Tableaux Bruts (Static Arrays)","text":"<p>C'est la forme la plus primitive de stockage. Un tableau brut est une suite de cases m\u00e9moire coll\u00e9es les unes aux autres.  </p>"},{"location":"notes/semaine_1_2_tableau/#declaration-et-memoire","title":"D\u00e9claration et M\u00e9moire","text":"<p>Il faut imp\u00e9rativement conna\u00eetre la taille \u00e0 la compilation. Une fois cr\u00e9\u00e9, le tableau ne peut jamais changer de taille.  </p> <pre><code>// Syntaxe : Type nom[Taille];  \n\nint scores[5]; // R\u00e9serve 5 entiers (valeurs al\u00e9atoires si non initialis\u00e9 !)  \n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#initialisation","title":"Initialisation","text":"<p>On utilise les accolades <code>{}</code>.  </p> Syntaxe R\u00e9sultat <code>int t[3] { 10, 20, 30 };</code> Tableau rempli : <code>[10, 20, 30]</code> <code>int t[5] { 10, 20 };</code> Reste rempli de z\u00e9ros : <code>[10, 20, 0, 0, 0]</code> <code>int t[10] {};</code> Tout \u00e0 z\u00e9ro : <code>[0, 0, ... 0]</code> (Recommand\u00e9) <code>int t[] { 1, 2, 3 };</code> Taille auto-d\u00e9duite (ici 3 cases)."},{"location":"notes/semaine_1_2_tableau/#acces-et-danger","title":"Acc\u00e8s et Danger \ud83d\udc80","text":"<p>On acc\u00e8de aux \u00e9l\u00e9ments via l'index [i] (commence \u00e0 0). <pre><code>scores[0] = 100; // Premi\u00e8re case  \nscores[4] = 50;  // Derni\u00e8re case (pour taille 5)  \n</code></pre></p> <p>Pas de garde-fou ! C++ ne v\u00e9rifie pas si vous d\u00e9passez le tableau.</p> <pre><code>int t[3] {1, 2, 3};  \nt[100] = 99; // \ud83d\udca5 \u00c9crit n'importe o\u00f9 dans la RAM.  \n             // Peut faire crasher le programme ou corrompre d'autres variables.  \n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#tableaux-bruts-et-fonctions","title":"Tableaux Bruts et Fonctions","text":"<p>C'est ici que \u00e7a se corse. En C++, on ne peut pas passer un tableau brut \"en entier\" \u00e0 une fonction comme on passerait un entier.  </p>"},{"location":"notes/semaine_1_2_tableau/#le-piege-du-decay-degenerescence","title":"Le Pi\u00e8ge du \"Decay\" (D\u00e9g\u00e9n\u00e9rescence)","text":"<p>Quand vous passez un tableau \u00e0 une fonction, il \"perd\" son identit\u00e9 de tableau et se transforme en simple adresse m\u00e9moire (pointeur) vers la premi\u00e8re case.  </p> <p>Cons\u00e9quence grave</p> <p>La fonction ne conna\u00eet pas la taille du tableau ! Le lien avec la taille d'origine est perdu. La fonction re\u00e7oit juste l'adresse du d\u00e9but, mais elle ne sait pas o\u00f9 \u00e7a s'arr\u00eate.  </p>"},{"location":"notes/semaine_1_2_tableau/#la-bonne-facon-de-faire","title":"La Bonne Fa\u00e7on de Faire","text":"<p>Pour compenser cette perte d'information, vous devez toujours envoyer la taille du tableau manuellement dans un deuxi\u00e8me param\u00e8tre.  </p> <pre><code>// \u274c MAUVAIS : La fonction ne sait pas quand s'arr\u00eater  \nvoid afficher(int tab[]) {  \n    // Impossible de savoir combien d'\u00e9l\u00e9ments il y a ici !  \n}  \n\n// \u2705 BON : On passe le tableau ET sa taille  \nvoid afficher(int tab[], int taille) {  \n    for (int i = 0; i &lt; taille; i++) {  \n        std::cout &lt;&lt; tab[i] &lt;&lt; \" \";  \n    }  \n}  \n\nint main() {  \n    int mesNotes[4] { 10, 15, 20, 12 };  \n\n    // Appel : On donne le tableau et le nombre 4  \n    afficher(mesNotes, 4);  \n}  \n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#problematique-au-niveau-de-la-taille","title":"Probl\u00e9matique au niveau de la taille","text":"<p>La probl\u00e9matique se situe au niveau du \"4\" comment faire pour trouver la taille du tableau.  </p>"},{"location":"notes/semaine_1_2_tableau/#comment-trouver-la-taille-automatiquement-c17-c20","title":"Comment trouver la taille automatiquement (C++17 / C++20)","text":"<p>Plus besoin de compter \u00e0 la main ou de faire des divisions de <code>sizeof</code>. Il faut inclure <code>&lt;iterator&gt;</code> (ou <code>&lt;vector&gt;</code>/<code>&lt;array&gt;</code>).  </p> Commande Version Description <code>std::size(tab)</code> C++17 Retourne la taille en non-sign\u00e9 (<code>unsigned</code>). <code>std::ssize(tab)</code> C++20 Retourne la taille en sign\u00e9 (<code>signed</code>). Recommand\u00e9 pour les boucles avec <code>int i</code>."},{"location":"notes/semaine_1_2_tableau/#determiner-la-taille-dun-tableau-localement","title":"D\u00e9terminer la taille d'un tableau (localement)","text":"<p>La m\u00e9thode C++20 recommand\u00e9e est <code>std::ssize()</code> (de la biblioth\u00e8que <code>&lt;iterator&gt;</code>).  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;iterator&gt;  \n\nint main() {  \n    int notes_cours[] {80, 85, 90, 75, 88};  \n    int taille {std::ssize(notes_cours)};  \n    std::cout &lt;&lt; \"La taille du tableau est : \" &lt;&lt; taille &lt;&lt; std::endl; // Affiche 5  \n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#quel-type-utiliser-pour-la-taille-analyse","title":"Quel type utiliser pour la taille ? (Analyse)","text":"<p>Le choix du type pour la <code>taille</code> est un compromis entre simplicit\u00e9, s\u00e9curit\u00e9 et portabilit\u00e9. Le fichier d'exemple ci-dessous (que vous pouvez t\u00e9l\u00e9charger et compiler) d\u00e9montre plusieurs approches.  </p> Fichier d'exemple : <code>exemple_types_taille.cpp</code> <pre><code>/**  \n * @file main.cpp  \n * @brief Fichier d'exemple pour d\u00e9montrer les diff\u00e9rentes mani\u00e8res de passer la taille  \n *        d'un tableau \u00e0 une fonction en C++, en soulignant les avantages et les risques  \n *        de chaque approche.  \n */  \n\n#include &lt;iostream&gt;  \n#include &lt;iterator&gt; // Pour std::ssize  \n#include &lt;cstddef&gt;  // Pour std::ptrdiff_t  \n\n\n\n/**  \n * @brief APPROCHE 1 : Utilise 'int' pour la taille.  \n * @note Cette version est **risqu\u00e9e** pour des applications g\u00e9n\u00e9rales. Un `int` (32 bits)  \n *       est trop petit pour contenir la taille d'un tr\u00e8s grand tableau, menant \u00e0 des bogues.  \n *       Pour des exercices simples, c'est souvent acceptable.  \n */  \nvoid afficher_moyenne_risque(const int notes[], int taille) {  \n    std::cout &lt;&lt; \"[int] Appel a la fonction risquee...\" &lt;&lt; std::endl;  \n}  \n\n\n/**  \n * @brief APPROCHE 2 : Utilise 'long long' pour la taille.  \n * @note L'utilisation de `long long` est un choix simple et s\u00fbr sur la plupart des  \n *       syst\u00e8mes 64-bit, car il est garanti d'\u00eatre assez grand.  \n */  \nvoid afficher_moyenne_long(const int notes[], long long taille) {  \n    if (taille &lt;= 0) return;  \n    double somme {0.0};  \n    for (long long i {0}; i &lt; taille; ++i) {  \n        somme += notes[i];  \n    }  \n    std::cout &lt;&lt; \"[long long] La moyenne est : \" &lt;&lt; somme / taille &lt;&lt; std::endl;  \n}  \n\n\n/**  \n * @brief APPROCHE 3 : Utilise 'std::ptrdiff_t' pour la taille.  \n * @note Cette version est la plus **techniquement correcte et portable**. `std::ptrdiff_t` est le  \n *       type sign\u00e9 que `std::ssize` retourne. Il est garanti d'\u00eatre assez grand  \n *       sur n'importe quelle plateforme.  \n */  \nvoid afficher_moyenne_semi_pro(const int notes[], std::ptrdiff_t taille) {  \n    std::cout &lt;&lt; \"[ptrdiff_t] Appel a la fonction semi-pro...\" &lt;&lt; std::endl;  \n}  \n\n/**  \n * @brief APPROCHE 4 : Utilise un template de fonction (C++20).  \n * @note L'utilisation de `auto` dans un param\u00e8tre est une fonctionnalit\u00e9 C++20  \n *       qui cr\u00e9e un \"template\". C'est tr\u00e8s flexible, mais moins explicite.  \n */  \nvoid afficher_moyenne_moderne(const int notes[], auto taille)  \n{  \n    std::cout &lt;&lt; \"[auto] Appel moderne qui redirige vers la version 'long long'.\" &lt;&lt; std::endl;  \n    afficher_moyenne_long(notes, taille);  \n}  \n\nint main() {  \n    int notes_cours[] {80, 85, 90, 75, 88};  \n\n    // On utilise std::ssize (C++20) pour obtenir la taille de mani\u00e8re s\u00fbre.  \n    // std::ssize retourne un type sign\u00e9 (std::ptrdiff_t).  \n    auto taille_notes { std::ssize(notes_cours) };  \n\n    std::cout &lt;&lt; \"--- Affichage des moyennes ---\" &lt;&lt; std::endl;  \n\n    // Appel \u00e0 la version `long long`. C'est un bon compromis entre simplicit\u00e9 et s\u00e9curit\u00e9.  \n    afficher_moyenne_long(notes_cours, taille_notes);  \n\n    // Appel \u00e0 la version C++20 avec `auto`.  \n    afficher_moyenne_moderne(notes_cours, taille_notes);  \n\n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#le-bordel-quoi","title":"Le bordel quoi !?","text":"<p>En effet. Ceci \u00e9tant dit !  </p> <p>Il existe une solution qui modernise le c++ et qui va nous \u00eatre utile avec plein d'autres cas. On utilise std::span qui permet de conserver la taille du tableau au travers du passage de param\u00e8tre. La variable contient \"grosso-modo\" la taille et le pointeur de d\u00e9but du tableau.  </p> <p>C'est un pointeur \"gras\"  </p> <pre><code>// Repr\u00e9sentation mentale simplifi\u00e9e  \ntemplate &lt;typename T&gt;  \nstruct Span {  \n    T* pointeur;   // L'adresse du d\u00e9but des donn\u00e9es (8 octets sur 64-bit)  \n    size_t taille; // Le nombre d'\u00e9l\u00e9ments (8 octets sur 64-bit)  \n};  \n</code></pre> <p>Avantage, le span peut \u00eatre utilis\u00e9 avec des tableaux standards vanille, des array de la biblioth\u00e8que standard et des vectors  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;span&gt;   // \ud83d\udc48 Obligatoire (C++20)  \n#include &lt;vector&gt;  \n#include &lt;array&gt;  \n\n// 1. La fonction prend un \"span\" (une vue)  \n// const int : on lit seulement (lecture seule)  \nvoid afficher(std::span&lt;const int&gt; donnees) {  \n    std::cout &lt;&lt; \"[ \";  \n    // Le span conna\u00eet sa taille et permet le foreach !  \n    for (int valeur : donnees) {  \n        std::cout &lt;&lt; valeur &lt;&lt; \" \";  \n    }  \n    std::cout &lt;&lt; \"] (Taille: \" &lt;&lt; donnees.size() &lt;&lt; \")\\n\";  \n}  \n\nint main() {  \n    // Cas A : Tableau Brut (C-Style)  \n    int tabC[] { 1, 2, 3 };  \n\n    // Cas B : std::vector (Dynamique)  \n    std::vector&lt;int&gt; vec { 10, 20, 30, 40 };  \n\n    // Cas C : std::array (Fixe moderne)  \n    std::array&lt;int, 2&gt; arr { 99, 100 };  \n\n    // \u2728 MAGIE : La m\u00eame fonction accepte TOUT !  \n    afficher(tabC); // D\u00e9duit automatiquement la taille (3)  \n    afficher(vec);  // Convertit automatiquement  \n    afficher(arr);  // Convertit automatiquement  \n\n    return 0;  \n}  \n</code></pre> <p>Conclusion Finale : La R\u00e8gle d'Or (C++20) </p> <ol> <li> <p>Pour apprendre (Exercices simples) :     Passer le tableau et sa taille s\u00e9par\u00e9ment (<code>int* tab, int taille</code>) reste une bonne m\u00e9thode p\u00e9dagogique pour comprendre la m\u00e9moire.  </p> </li> <li> <p>Pour le \"Vrai Monde\" (Professionnel) :     Utilisez <code>std::span</code>. C'est le standard moderne qui remplace toutes les anciennes m\u00e9thodes.  </p> <ul> <li>\u274c Plus besoin de <code>void f(int* t, int size)</code> </li> <li>\u274c Plus besoin de <code>void f(const std::vector&lt;int&gt;&amp; v)</code> </li> <li>\u2705 Utilisez <code>void f(std::span&lt;int&gt; data)</code> </li> </ul> </li> </ol>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/","title":"Entr\u00e9es Utilisateur avec <code>std::cin</code>","text":"<p>Cette section explique comment r\u00e9cup\u00e9rer des informations de l'utilisateur via la console en utilisant la biblioth\u00e8que <code>&lt;iostream&gt;</code>.  </p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#1-les-bases-flux-et-buffer","title":"1. Les Bases : Flux et Buffer","text":"<p>En C++, les entr\u00e9es clavier ne vont pas directement dans vos variables. Elles passent par un flux d'entr\u00e9e (<code>std::cin</code>) et une zone d'attente appel\u00e9e le Buffer.  </p> <ul> <li><code>std::cin</code> : Le flux qui lit le clavier.  </li> <li>Buffer : Une salle d'attente o\u00f9 les caract\u00e8res s'empilent quand vous tapez.  </li> <li><code>std::endl</code> : Pour l'affichage (<code>cout</code>), cela fait un retour \u00e0 la ligne (<code>\\n</code>) et force l'affichage imm\u00e9diat.  </li> </ul>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#2-les-deux-facons-de-lire","title":"2. Les Deux Fa\u00e7ons de Lire","text":"<p>Il existe deux outils principaux selon ce que vous voulez lire.  </p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#a-lire-un-mot-ou-un-nombre","title":"A. Lire un mot ou un nombre (<code>&gt;&gt;</code>)","text":"<p>L'op\u00e9rateur d'extraction <code>&gt;&gt;</code> lit des donn\u00e9es jusqu'au premier \"espace blanc\" (Espace, Tabulation, ou Entr\u00e9e).  </p> <pre><code>int age;  \nstd::cin &gt;&gt; age;  \n// Si je tape \"25\" + Entr\u00e9e :  \n// -&gt; '25' va dans la variable.  \n// -&gt; '\\n' (Entr\u00e9e) RESTE dans le buffer.  \n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#b-lire-une-ligne-complete-stdgetline","title":"B. Lire une ligne compl\u00e8te (<code>std::getline</code>)","text":"<p>Cette fonction lit tout jusqu'au retour \u00e0 la ligne (n). Elle est indispensable pour lire des phrases avec des espaces.  </p> <pre><code>std::string nom;  \nstd::getline(std::cin, nom);  \n// Elle consomme le texte ET le '\\n', puis jette le '\\n'.  \n// Le buffer est propre apr\u00e8s son passage.  \n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#3-le-piege-classique-melanger-et-getline","title":"3. Le Pi\u00e8ge Classique : M\u00e9langer <code>&gt;&gt;</code> et <code>getline</code> \u26a0\ufe0f","text":"<p>C'est l'erreur n\u00b01 des d\u00e9butants en C++.  </p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#le-scenario","title":"Le Sc\u00e9nario","text":"<ol> <li>Vous demandez un \u00e2ge avec <code>std::cin &gt;&gt; age</code>.  </li> <li>L'utilisateur tape <code>25</code> et appuie sur <code>Entr\u00e9e</code>.  </li> <li><code>cin</code> extrait le nombre <code>25</code>.  </li> <li>\ud83d\uded1 Probl\u00e8me : Le caract\u00e8re de saut de ligne <code>\\n</code> (correspondant \u00e0 la touche Entr\u00e9e) reste dans le buffer.  </li> <li>Vous appelez <code>std::getline</code> pour demander le nom.  </li> <li><code>getline</code> regarde le buffer, voit le <code>\\n</code> qui tra\u00eene imm\u00e9diatement, pense que l'utilisateur a entr\u00e9 une ligne vide, et s'arr\u00eate.  </li> </ol> <p>R\u00e9sultat : Le programme \"saute\" la demande du nom et ne vous laisse rien \u00e9crire.  </p> <p>Exemple du Code Probl\u00e9matique</p> <pre><code>int age;  \nstd::string nom;  \n\nstd::cout &lt;&lt; \"Age : \";  \nstd::cin &gt;&gt; age;  \n// L'utilisateur tape \"25\" + \"Entr\u00e9e\".  \n// Le '\\n' reste en attente dans la m\u00e9moire.  \n\nstd::cout &lt;&lt; \"Nom : \";  \n// \u274c BUG : getline lit le '\\n' restant et s'arr\u00eate tout de suite.  \nstd::getline(std::cin, nom);  \n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#la-solution-nettoyer-le-buffer","title":"La Solution : Nettoyer le Buffer","text":"<p>Pour corriger cela, il faut ignorer le reste de la ligne (le <code>\\n</code> restant) apr\u00e8s chaque <code>cin &gt;&gt;</code> si vous comptez utiliser <code>getline</code> ensuite.  </p> <p>La Correction</p> <p>Ajoutez cette ligne magique entre les deux lectures :  </p> <pre><code>#include &lt;limits&gt; // N\u00e9cessaire pour numeric_limits  \n\n// ...  \nstd::cin &gt;&gt; age;  \n\n// \ud83e\uddf9 NETTOYAGE : On ignore tout jusqu'au prochain retour \u00e0 la ligne  \nstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');  \n\nstd::cout &lt;&lt; \"Nom : \";  \nstd::getline(std::cin, nom); // \u2705 Fonctionne parfaitement  \n</code></pre> <p>Pourquoi pas juste <code>std::cin.ignore()</code> ?</p> <p><code>std::cin.ignore()</code> tout seul n'ignore qu'un seul caract\u00e8re.  </p> <p>Si l'utilisateur a tap\u00e9 <code>25 abc</code> puis <code>Entr\u00e9e</code>, il restera encore <code>bc</code> et <code>\\n</code> dans le buffer.  </p> <p>La version avec <code>numeric_limits</code> est la version \"blind\u00e9e\" : elle demande d'ignorer le nombre maximum de caract\u00e8res possible jusqu'\u00e0 trouver un retour \u00e0 la ligne. C'est la seule fa\u00e7on de garantir un buffer vide.  </p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#4-gestion-des-erreurs-de-saisie","title":"4. Gestion des Erreurs de Saisie","text":"<p>Que se passe-t-il si l'utilisateur fait n'importe quoi alors que vous attendez un nombre ?  </p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#cas-a-lecture-partielle-45abc","title":"Cas A : Lecture Partielle (<code>45abc</code>)","text":"<p>Si on demande un <code>int</code> et que l'utilisateur tape <code>45abc</code> :  </p> <ol> <li><code>cin</code> lit <code>45</code> (\u2705 Succ\u00e8s).  </li> <li><code>cin</code> s'arr\u00eate au <code>a</code> (car ce n'est pas un chiffre).  </li> <li>R\u00e9sultat : La variable vaut <code>45</code>.  </li> <li>\u26a0\ufe0f Probl\u00e8me : La cha\u00eene <code>abc</code> reste dans le buffer pour la prochaine lecture. Cela causera probablement une erreur au prochain <code>cin</code>.  </li> </ol>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#cas-b-echec-total-abc45","title":"Cas B : \u00c9chec Total (<code>abc45</code>)","text":"<p>Si on demande un <code>int</code> et que l'utilisateur tape <code>abc45</code> :  </p> <ol> <li><code>cin</code> voit <code>a</code> tout de suite.  </li> <li>Il se met imm\u00e9diatement en mode Erreur (le drapeau <code>failbit</code> s'active).  </li> <li>R\u00e9sultat : La variable vaut 0 (ou reste inchang\u00e9e).  </li> <li>\ud83d\uded1 Danger : Tant que <code>cin</code> est en erreur (\"fail state\"), il refusera de lire quoi que ce soit d'autre. Il est \"verrouill\u00e9\".  </li> </ol>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#la-solution-robuste-pattern-a-retenir","title":"La Solution Robuste (Pattern \u00e0 retenir)","text":"<p>Pour un programme solide, on utilise une boucle <code>while</code> qui v\u00e9rifie l'\u00e9tat de <code>cin</code> apr\u00e8s chaque tentative.  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;limits&gt;  \n\nint main() {  \n    int age = 0;  \n\n    std::cout &lt;&lt; \"Entrez votre age : \";  \n\n    // 1. La boucle g\u00e8re L'\u00c9CHEC (Type incorrect, ex: \"abc\")  \n    while (!(std::cin &gt;&gt; age)) {  \n        std::cout &lt;&lt; \"Erreur, ce n'est pas un nombre. Recommencez : \";  \n        std::cin.clear();  \n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');  \n    }  \n\n    // 2. IMPORTANT : On g\u00e8re le SUCC\u00c8S (Nettoyage final)  \n    // On vide le buffer pour enlever le '\\n' restant ou les d\u00e9chets (ex: \"25abc\")  \n    // afin que la suite du programme (ex: un futur getline) fonctionne.  \n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');  \n\n    std::cout &lt;&lt; \"Age valide : \" &lt;&lt; age &lt;&lt; \"\\n\";  \n\n    // Ici, le buffer est propre, pr\u00eat pour un getline !  \n}  \n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#resume-des-commandes-de-nettoyage","title":"R\u00e9sum\u00e9 des Commandes de Nettoyage","text":"<p>Ces deux commandes fonctionnent souvent en duo dans une gestion d'erreur robuste.  </p> Commande R\u00f4le <code>std::cin.clear()</code> R\u00e9parer. R\u00e9initialise les indicateurs d'erreur (comme <code>failbit</code>) pour sortir <code>cin</code> de son \u00e9tat de blocage et lui permettre de relire. <code>std::cin.ignore(MAX, '\\n')</code> Vider. Jette tout ce qui tra\u00eene encore dans le buffer (la saisie fautive + le retour \u00e0 la ligne) pour repartir sur des bases saines. <p>Note</p> <p>Dans ce tableau, <code>MAX</code> est un raccourci pour : <code>std::numeric_limits&lt;std::streamsize&gt;::max()</code>.  </p>"},{"location":"notes/semaine_1_4_compilation_cpp20/","title":"Guide de Compilation en C++20","text":"<p>Ce document explique comment transformer votre code source (<code>.cpp</code>, <code>.hpp</code>) en un programme ex\u00e9cutable \u00e0 l'aide du compilateur <code>g++</code> et du standard C++20.  </p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#1-quest-ce-que-la-compilation","title":"1. Qu'est-ce que la Compilation ?","text":"<p>La compilation est le processus qui traduit votre code C++, lisible par un humain, en code machine, compr\u00e9hensible par l'ordinateur. L'outil qui r\u00e9alise cette traduction est appel\u00e9 un compilateur. Dans ce cours, nous utiliserons <code>g++</code>, le compilateur C++ du projet GNU, l'un des plus populaires.  </p> <p> </p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#2-la-commande-de-compilation-essentielle","title":"2. La Commande de Compilation Essentielle","text":"<p>Pour compiler, vous ouvrirez un terminal (ou une console) et taperez une commande qui ressemble \u00e0 ceci :  </p> <pre><code>g++ [options] -o [nom_executable] [vos_fichiers.cpp]  \n</code></pre> <p>D\u00e9taillons chaque partie :  </p> <ul> <li><code>g++</code> : C'est l'appel au compilateur lui-m\u00eame.  </li> <li><code>[options]</code> : Ce sont des \"drapeaux\" (flags) qui modifient le comportement du compilateur. Les deux plus importants pour nous sont :  <ul> <li><code>-std=c++20</code> : C'est le drapeau crucial qui dit \u00e0 <code>g++</code> d'utiliser le standard C++20. Sans cela, les fonctionnalit\u00e9s modernes du langage ne seront pas disponibles.  </li> <li><code>-Wall</code> : (Abr\u00e9viation de \"Warnings All\") C'est une option tr\u00e8s fortement recommand\u00e9e qui active presque tous les avertissements (<code>warnings</code>). Le compilateur vous signalera des erreurs potentielles dans votre code, m\u00eame si elles ne l'emp\u00eachent pas de compiler. C'est un filet de s\u00e9curit\u00e9 indispensable.  </li> </ul> </li> <li><code>-o [nom_executable]</code> : L'option <code>-o</code> (pour \"output\") vous permet de nommer votre programme final. Si vous l'omettez, le fichier de sortie s'appellera <code>a.out</code> (sur Linux/macOS) ou <code>a.exe</code> (sur Windows).  </li> <li><code>[vos_fichiers.cpp]</code> : C'est la liste de tous vos fichiers <code>.cpp</code>, s\u00e9par\u00e9s par des espaces. Vous n'avez pas besoin d'inclure les fichiers <code>.hpp</code>, car ils sont g\u00e9r\u00e9s via les directives <code>#include</code> dans vos fichiers <code>.cpp</code>.  </li> </ul>"},{"location":"notes/semaine_1_4_compilation_cpp20/#3-exemples-concrets","title":"3. Exemples Concrets","text":""},{"location":"notes/semaine_1_4_compilation_cpp20/#cas-1-un-projet-avec-un-seul-fichier","title":"Cas 1 : Un Projet avec un Seul Fichier","text":"<p>Imaginons que vous avez un seul fichier <code>main.cpp</code>.  </p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp  \n</code></pre> -   Ceci cr\u00e9era un ex\u00e9cutable nomm\u00e9 <code>mon_programme</code>.  </p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#cas-2-un-projet-avec-plusieurs-fichiers","title":"Cas 2 : Un Projet avec Plusieurs Fichiers","text":"<p>Reprenons notre exemple <code>Commande</code>. Nous avons trois fichiers <code>.cpp</code> \u00e0 compiler ensemble.  </p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o exemple main.cpp Commande.cpp ServiceConnexion.cpp  \n</code></pre> -   <code>g++</code> va compiler chaque fichier <code>.cpp</code> et les lier (\"link\") ensemble pour cr\u00e9er un seul ex\u00e9cutable nomm\u00e9 <code>exemple</code>.  </p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#4-executer-votre-programme","title":"4. Ex\u00e9cuter votre Programme","text":"<p>Une fois la compilation r\u00e9ussie (si la commande ne retourne aucune erreur), un nouveau fichier ex\u00e9cutable appara\u00eetra dans votre dossier.  </p> <p>Pour l'ex\u00e9cuter dans le terminal :  </p> <ul> <li> <p>Sur Linux ou macOS : <pre><code>./nom_executable  \n</code></pre>     (Le <code>./</code> signifie \"dans le dossier actuel\")  </p> </li> <li> <p>Sur Windows (cmd ou PowerShell) : <pre><code>.\\nom_executable.exe  \n</code></pre></p> </li> </ul>"},{"location":"notes/semaine_1_4_compilation_cpp20/#5-ca-ne-compile-pas-gerer-les-erreurs","title":"5. \"\u00c7a ne compile pas !\" - G\u00e9rer les Erreurs","text":"<p>Il est normal d'avoir des erreurs de compilation. L'art de la programmation est de savoir les lire.  </p> <p>Les erreurs les plus courantes au d\u00e9but : -   Oubli d'un point-virgule (<code>;</code>) \u00e0 la fin d'une ligne. -   Faute de frappe dans un nom de variable ou de fonction. -   Accolade (<code>{</code> ou <code>}</code>) manquante. -   Oubli d'inclure un en-t\u00eate (ex: <code>#include &lt;string&gt;</code> pour utiliser <code>std::string</code>).  </p> <p>Lisez attentivement les messages d'erreur. <code>g++</code> vous donnera g\u00e9n\u00e9ralement le nom du fichier et le num\u00e9ro de la ligne o\u00f9 l'erreur a \u00e9t\u00e9 d\u00e9tect\u00e9e.  </p> <p>Exemple de message d'erreur : <pre><code>main.cpp: In function 'int main()':  \nmain.cpp:5:3: error: expected ';' before 'return'  \n   return 0;  \n   ^~~~~~  \n</code></pre> Le compilateur nous dit qu'\u00e0 la ligne 5 du fichier <code>main.cpp</code>, il s'attendait \u00e0 un point-virgule avant le mot-cl\u00e9 <code>return</code>.  </p> <p>```  </p>"},{"location":"notes/semaine_2_1_passage_copie_reference/","title":"Les 3 Fa\u00e7ons de Passer des Param\u00e8tres","text":"<p>En C++, il y a trois mani\u00e8res de transmettre une variable \u00e0 une fonction. Choisir la bonne m\u00e9thode est essentiel pour la performance et la s\u00e9curit\u00e9 de votre code.  </p>"},{"location":"notes/semaine_2_1_passage_copie_reference/#1-passage-par-copie-pass-by-value","title":"1. Passage par Copie (Pass-by-Value)","text":"<p>\"Je te donne une photocopie.\" </p> <p>C'est le comportement par d\u00e9faut pour les types simples (<code>int</code>, <code>char</code>, <code>bool</code>, <code>float</code>).  </p> <ul> <li>M\u00e9canisme : La fonction cr\u00e9e une nouvelle variable et copie la valeur de l'originale dedans.  </li> <li>Cons\u00e9quence : Si la fonction modifie la variable, l'originale ne change pas.  </li> <li>Co\u00fbt : Rapide pour les petits nombres, mais tr\u00e8s lent pour les gros objets (comme une image ou un long texte) car il faut tout dupliquer octet par octet.  </li> </ul> <pre><code>#include &lt;iostream&gt;  \n\nvoid copie(int x) {  \n    x = 1000; // Modifie uniquement la photocopie locale  \n    std::cout &lt;&lt; \"Dans la fonction : \" &lt;&lt; x &lt;&lt; \"\\n\";  \n}  \n\nint main() {  \n    int a = 10;  \n    copie(a);  \n    std::cout &lt;&lt; \"Dans le main : \" &lt;&lt; a &lt;&lt; \"\\n\"; // Affiche 10 (intact)  \n}  \n</code></pre>"},{"location":"notes/semaine_2_1_passage_copie_reference/#2-passage-par-reference-pass-by-reference","title":"2. Passage par R\u00e9f\u00e9rence (Pass-by-Reference)","text":"<p>\"Je te donne acc\u00e8s \u00e0 mon fichier Google Doc original.\" </p> <p>On utilise le symbole <code>&amp;</code>. La fonction ne cr\u00e9e aucune nouvelle variable. Elle travaille directement sur la m\u00e9moire de l'original.  </p>"},{"location":"notes/semaine_2_1_passage_copie_reference/#a-reference-modifiable-type","title":"A. R\u00e9f\u00e9rence Modifiable (<code>Type&amp;</code>)","text":"<p>Utilis\u00e9 quand la fonction DOIT modifier l'original.  </p> <pre><code>void modifier(int&amp; x) {  \n    x = 1000; // Modifie la VRAIE variable du main  \n}  \n</code></pre>"},{"location":"notes/semaine_2_1_passage_copie_reference/#b-reference-constante-const-type-le-standard","title":"B. R\u00e9f\u00e9rence Constante (<code>const Type&amp;</code>) \ud83c\udf1f LE STANDARD","text":"<p>C'est la m\u00e9thode reine du C++ pour les objets complexes (<code>std::string</code>, <code>std::vector</code>...). Elle combine le meilleur des deux mondes :  </p> <ol> <li>Vitesse de la r\u00e9f\u00e9rence (pas de copie).  </li> <li>S\u00e9curit\u00e9 de la copie (interdiction de modifier l'original).  </li> </ol> <pre><code>#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n\n// \"const\" + \"&amp;\" = Je regarde l'original, mais je n'ai pas le droit de toucher  \nvoid afficher(const std::string&amp; texte) {  \n    std::cout &lt;&lt; texte;  \n\n    // \ud83d\uded1 ERREUR DE COMPILATION :  \n    // texte = \"Salut\"; // Interdit ! On est en lecture seule.  \n}  \n\nint main{  \n    std::string allo {\"hello\"};  \n    afficher(allo);  \n}  \n</code></pre>"},{"location":"notes/semaine_2_1_passage_copie_reference/#3-passage-par-pointeur-pass-by-pointer","title":"3. Passage par Pointeur (Pass-by-Pointer)","text":"<p>\"Je te donne l'adresse GPS de ma maison.\" </p> <p>C'est l'anc\u00eatre de la r\u00e9f\u00e9rence, h\u00e9rit\u00e9 du langage C. On utilise le symbole <code>*</code> pour d\u00e9clarer le pointeur et <code>&amp;</code> pour r\u00e9cup\u00e9rer l'adresse d'une variable.  </p> <ul> <li>M\u00e9canisme : La fonction re\u00e7oit l'adresse m\u00e9moire (un nombre hexad\u00e9cimal) de la variable, pas la variable elle-m\u00eame.  </li> <li>Syntaxe : C'est plus lourd \u00e0 utiliser. Il faut \"d\u00e9r\u00e9f\u00e9rencer\" le pointeur avec l'\u00e9toile <code>*</code> pour acc\u00e9der \u00e0 la valeur stock\u00e9e \u00e0 cette adresse.  </li> <li>La Diff\u00e9rence Cl\u00e9 : Un pointeur peut \u00eatre vide (<code>nullptr</code>). Une r\u00e9f\u00e9rence, elle, doit toujours \u00eatre li\u00e9e \u00e0 une variable existante.  </li> </ul> <pre><code>// La fonction attend une adresse (int*)  \nvoid remiseAZero(int* ptr) {  \n    // S\u00e9curit\u00e9 : on v\u00e9rifie que l'adresse existe (n'est pas nulle)  \n    if (ptr != nullptr) {  \n        *ptr = 0; // On va \u00e0 l'adresse point\u00e9e et on \u00e9crit 0  \n    }  \n}  \n\nint main() {  \n    int note = 20;  \n\n    // Appel : On envoie l'adresse de 'note' avec '&amp;'  \n    remiseAZero(&amp;note);  \n}  \n</code></pre> <p>## 4. Le Grand R\u00e9capitulatif  </p> <p>Voici le tableau de synth\u00e8se pour savoir quelle m\u00e9thode utiliser en un coup d'\u0153il.  </p> M\u00e9thode Syntaxe (D\u00e9claration) Syntaxe (Appel) Modifie Original ? Peut \u00eatre Null ? Usage Recommand\u00e9 Copie <code>void f(int a)</code> <code>f(a)</code> \u274c Non \u274c Non Petits types simples (<code>int</code>, <code>bool</code>, <code>char</code>). R\u00e9f\u00e9rence <code>void f(int&amp; a)</code> <code>f(a)</code> \u2705 Oui \u274c Non Quand la fonction doit modifier la variable. R\u00e9f. Const <code>void f(const int&amp; a)</code> <code>f(a)</code> \u274c Non \u274c Non Standard pour les objets (<code>string</code>, <code>vector</code>) en lecture seule. Pointeur <code>void f(int* a)</code> <code>f(&amp;a)</code> \u2705 Oui \u2705 Oui Donn\u00e9es optionnelles ou h\u00e9ritage du C. <p>## 5. Guide de D\u00e9cision : Quoi utiliser quand ?  </p> <p>C'est la question la plus importante. Suivez cet algorithme mental pour choisir le bon type de param\u00e8tre.  </p> <p>L'Algorithme de Choix</p> <ol> <li> <p>La variable est-elle \"petite\" ? (<code>int</code>, <code>double</code>, <code>char</code>, <code>bool</code>)     \ud83d\udc49 Utilisez la COPIE. (Ex: <code>void setAge(int age)</code>) C'est plus simple et le processeur g\u00e8re \u00e7a tr\u00e8s vite. </p> </li> <li> <p>La variable est \"grosse\" (<code>string</code>, <code>vector</code>) et je veux juste la lire ?     \ud83d\udc49 Utilisez la R\u00c9F\u00c9RENCE CONSTANTE. (Ex: <code>void afficher(const std::string&amp; nom)</code>) C'est rapide (z\u00e9ro copie) et s\u00fbr. </p> </li> <li> <p>La fonction doit-elle modifier l'original ?     \ud83d\udc49 Utilisez la R\u00c9F\u00c9RENCE. (Ex: <code>void monterNiveau(Joueur&amp; j)</code>)  </p> </li> <li> <p>La donn\u00e9e est-elle optionnelle (peut ne pas exister) ?     \ud83d\udc49 Utilisez le POINTEUR. (Ex: <code>void cibler(Ennemi* cible)</code>) Cela permet de passer <code>nullptr</code> pour dire \"rien\". </p> </li> </ol>"},{"location":"notes/semaine_2_1_passage_copie_reference/#6-le-cas-special-des-tableaux-c","title":"6. Le Cas Sp\u00e9cial des Tableaux C","text":"<p>Attention : Les tableaux de style C (<code>int tab[]</code>) sont des tra\u00eetres !  </p> <p>Le Pi\u00e8ge du Decay (D\u00e9g\u00e9n\u00e9rescence)</p> <p>M\u00eame si vous ne mettez pas de <code>&amp;</code>, un tableau C pass\u00e9 \u00e0 une fonction se comporte toujours comme un pointeur. Il n'est jamais copi\u00e9.  </p> <p>Cela signifie que la fonction peut modifier votre tableau original sans pr\u00e9venir.  </p> <pre><code>// Ceci modifie le VRAI tableau, m\u00eame sans '&amp;' !  \nvoid hack(int tab[]) {  \n    tab[0] = 0; // Le tableau du main est modifi\u00e9  \n}  \n</code></pre> <p>Note : La Solution Moderne</p> <p>C'est pour cela qu'en C++ moderne, on pr\u00e9f\u00e8re <code>std::vector</code> ou <code>std::span</code> qui sont plus s\u00fbrs.  </p>"},{"location":"notes/semaine_2_1_passage_copie_reference/#exemple-des-pointeurs-vu-en-classe","title":"Exemple des pointeurs vu en classe.","text":"<pre><code>#include &lt;iostream&gt; //instruction de pr\u00e9compilation  \n\nvoid fonction_quelconque(int* le_pointeur_de_int) { //j'ai oubli\u00e9 de dire qu'en c++ c'est la casse \"serpent\"  \n    std::cout &lt;&lt; \" entr\u00e9e de fonction \" &lt;&lt; std::endl;  \n    std::cout &lt;&lt; \" adresse o\u00f9 pointe le pointeur : \" &lt;&lt; le_pointeur_de_int &lt;&lt; std::endl;  \n    std::cout &lt;&lt; \" la valeur par d\u00e9r\u00e9f\u00e9rencement : \" &lt;&lt; *le_pointeur_de_int &lt;&lt; std::endl;  \n    // d\u00e9r\u00e9f\u00e9rencer -&gt; enlever la r\u00e9f\u00e9rence et tomber sur le type en dessous, int dans notre cas  \n\n    //modification de la valeur  \n    *le_pointeur_de_int *= 2; //x2 la valeur  \n    std::cout &lt;&lt; \" Fin de fonction \" &lt;&lt; std::endl &lt;&lt; std::endl;  \n}  \n\nint main() {  \n    int a { 10 };  \n    std::cout &lt;&lt; \"adresse de a \" &lt;&lt; &amp;a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a  \n\n    std::cout &lt;&lt; \"valeur de a avant l'appel de fonction \" &lt;&lt; a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a  \n    fonction_quelconque(&amp;a); //appel de la fonction avec l'adresse de a  \n    std::cout &lt;&lt; \"valeur de a apr\u00e8s l'appel de fonction \" &lt;&lt; a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a  \n\n    //preuve que la fonction re\u00e7oit un pointeur  \n    int* a_ptr = &amp;a; //d\u00e9claration d'un pointeur sur l'adresse de la variable a  \n    fonction_quelconque(a_ptr);  \n}  \n</code></pre>"},{"location":"notes/semaine_2_2_les_structs/","title":"De la <code>struct</code> \u00e0 la <code>class</code> : Une Introduction Progressive","text":"<p>L'objectif de cette note est de comprendre l'\u00e9volution de la pens\u00e9e en C++ : comment on passe d'une simple structure de donn\u00e9es \u00e0 un objet complet et robuste. Nous allons suivre une progression en plusieurs \u00e9tapes.  </p>"},{"location":"notes/semaine_2_2_les_structs/#partie-1-la-struct-comme-simple-conteneur-de-donnees","title":"Partie 1 : La <code>struct</code> comme Simple Conteneur de Donn\u00e9es","text":"<p>Au niveau le plus simple, une <code>struct</code> est une mani\u00e8re de regrouper plusieurs variables en un seul type. On la d\u00e9finit g\u00e9n\u00e9ralement dans un fichier d'en-t\u00eate (<code>.hpp</code>) pour pouvoir la r\u00e9utiliser.  </p>"},{"location":"notes/semaine_2_2_les_structs/#11-len-tete-joueurhpp-et-les-gardes","title":"1.1 - L'En-t\u00eate (<code>Joueur.hpp</code>) et les Gardes","text":"<p>Un fichier d'en-t\u00eate doit \u00eatre prot\u00e9g\u00e9 contre l'inclusion multiple. Si un m\u00eame <code>.hpp</code> est inclus plusieurs fois, le compilateur verra la d\u00e9finition de la <code>struct</code> en double et g\u00e9n\u00e9rera une erreur. Pour \u00e9viter cela, on utilise une \"garde d'en-t\u00eate\".  </p> <p>M\u00e9thode Moderne (<code>#pragma once</code>) : \u00c0 placer sur la toute premi\u00e8re ligne. C'est la m\u00e9thode privil\u00e9gi\u00e9e pour ce cours.  </p> <pre><code>// Fichier : Joueur.hpp  \n#pragma once  \n#include &lt;string&gt;  \n\n// La seule responsabilit\u00e9 de ce fichier est de d\u00e9finir la struct Joueur.  \nstruct Joueur {  \n    std::string nom;  \n    int points_de_vie;  \n    int niveau;  \n};  \n</code></pre> <p>M\u00e9thode Traditionnelle (<code>ifndef</code>) : Fonctionne sur tous les compilateurs. Le nom (<code>JOUEUR_HPP</code>) doit \u00eatre unique.  </p> <pre><code>#ifndef JOUEUR_HPP  \n#define JOUEUR_HPP  \n// ... contenu du .hpp ...  \n#endif // JOUEUR_HPP  \n</code></pre>"},{"location":"notes/semaine_2_2_les_structs/#12-utilisation-simple-dans-maincpp","title":"1.2 - Utilisation simple dans <code>main.cpp</code>","text":"<p>Le <code>main.cpp</code> inclut le <code>.hpp</code> et peut ensuite cr\u00e9er et manipuler des variables du type <code>Joueur</code>.  </p> <pre><code>// Fichier : main.cpp  \n#include &lt;iostream&gt;  \n#include &lt;format&gt;  \n#include \"Joueur.hpp\" // On inclut la d\u00e9finition de notre struct  \n\nint main() {  \n    Joueur p1 {  \n        .nom = \"Frodon Sacquet\",  \n        .points_de_vie = 20,  \n        .niveau = 1  \n    };  \n\n    p1.niveau = 2; // Acc\u00e8s direct aux membres publics  \n\n    std::cout &lt;&lt; std::format(\"{} est maintenant niveau {}\\n\", p1.nom, p1.niveau);  \n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_2_2_les_structs/#partie-2-struct-avec-fonctions-libres","title":"Partie 2 : <code>struct</code> avec Fonctions Libres","text":"<p>Rapidement, on se rend compte que du code se r\u00e9p\u00e8te (par exemple, l'affichage d'un joueur). On peut cr\u00e9er des fonctions pour ces t\u00e2ches. Pour garder notre projet organis\u00e9, on s\u00e9pare les d\u00e9clarations des d\u00e9finitions.  </p> <ul> <li><code>JoueurActions.hpp</code> : D\u00e9clare les fonctions \"libres\" qui travaillent sur <code>Joueur</code>. C'est le \"menu des actions\".  </li> <li><code>JoueurActions.cpp</code> : Impl\u00e9mente le code de ces fonctions.  </li> </ul> <p><pre><code>// Fichier : JoueurActions.hpp  \n#pragma once  \n#include \"Joueur.hpp\" // Pour savoir ce qu'est un Joueur  \n\nvoid afficher_joueur(const Joueur&amp; j); // Signature (prototype)  \n</code></pre> <pre><code>// Fichier : JoueurActions.cpp  \n#include \"JoueurActions.hpp\"  \n#include &lt;iostream&gt;  \n#include &lt;format&gt;  \n\nvoid afficher_joueur(const Joueur&amp; j) { // Impl\u00e9mentation  \n    std::cout &lt;&lt; std::format(\"- Nom: {}, PV: {}\\n\", j.nom, j.points_de_vie);  \n}  \n</code></pre> <pre><code>// Fichier : main.cpp (modifi\u00e9)  \n#include \"JoueurActions.hpp\" // On inclut maintenant les actions  \n\nint main() {  \n    Joueur p1 { .nom = \"Sam Gamegie\", .points_de_vie = 30 };  \n    afficher_joueur(p1); // On utilise notre fonction  \n    return 0;  \n}  \n</code></pre></p>"},{"location":"notes/semaine_2_2_les_structs/#partie-21-structure-inclusions-et-compilation","title":"Partie 2.1 : Structure, Inclusions et Compilation","text":"<p>Cette s\u00e9paration des fichiers suit un principe essentiel : le Principe de Responsabilit\u00e9 Unique. Chaque fichier a un seul r\u00f4le.  </p> <ul> <li><code>Joueur.hpp</code> : D\u00e9finit ce qu'EST un <code>Joueur</code>.  </li> <li><code>JoueurActions.hpp</code> : D\u00e9clare ce qu'on PEUT FAIRE avec un <code>Joueur</code>.  </li> <li><code>JoueurActions.cpp</code> : Explique COMMENT on le fait.  </li> <li><code>main.cpp</code> : Lance le programme.  </li> </ul>"},{"location":"notes/semaine_2_2_les_structs/#schema-des-inclusions","title":"Sch\u00e9ma des Inclusions","text":"<p>Voici comment les fichiers d\u00e9pendent les uns des autres. Une fl\u00e8che <code>A -&gt; B</code> signifie que le fichier <code>A</code> inclut le fichier <code>B</code>.  </p> <pre><code>           main.cpp  ---------------&gt; JoueurActions.hpp  \n                                          |  \nJoueurActions.cpp  ------------&gt; JoueurActions.hpp  \n                                          |  \n                                          v  \n                                      Joueur.hpp  \n</code></pre> <p>Le <code>main.cpp</code> n'a pas besoin de conna\u00eetre les d\u00e9tails de <code>Joueur.hpp</code>. Il fait confiance \u00e0 <code>JoueurActions.hpp</code> pour lui fournir les actions n\u00e9cessaires.  </p>"},{"location":"notes/semaine_2_2_les_structs/#compilation-du-projet","title":"Compilation du Projet","text":"<p>Pour cr\u00e9er l'ex\u00e9cutable, vous devez fournir tous les fichiers <code>.cpp</code> au compilateur. Celui-ci va les traduire en code machine, puis l'\u00e9diteur de liens (linker) va les assembler en un seul programme.  </p> <p><pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp JoueurActions.cpp  \n</code></pre> Notez qu'on ne donne jamais les fichiers <code>.hpp</code> au compilateur directement. Ils sont inclus par les <code>.cpp</code>.  </p>"},{"location":"notes/semaine_2_2_les_structs/#partie-3-evolution-vers-les-fonctions-membres","title":"Partie 3 : \u00c9volution vers les Fonctions Membres","text":"<p>L'\u00e9tape suivante est de lier plus fortement un comportement \u00e0 la <code>struct</code> elle-m\u00eame. Si une fonction est intrins\u00e8quement li\u00e9e \u00e0 un objet (comme <code>afficher</code>), on peut en faire une fonction membre.  </p> <p>Important : \u00c0 ce stade, la <code>struct</code> reste un conteneur \"passif\" avec des donn\u00e9es publiques. C'est une \u00e9tape d'organisation, pas encore de protection.  </p> <ul> <li><code>Joueur.hpp</code> : La fonction est d\u00e9clar\u00e9e DANS la <code>struct</code>.  </li> <li><code>Joueur.cpp</code> : Un fichier source pour <code>Joueur</code> impl\u00e9mente ses fonctions membres.  </li> </ul> <p><pre><code>// Fichier : Joueur.hpp (refactoris\u00e9)  \n#pragma once  \n#include &lt;string&gt;  \n\nstruct Joueur {  \n    std::string nom;  \n    int points_de_vie;  \n    int niveau;  \n    void afficher() const; // D\u00e9claration de la fonction MEMBRE  \n};  \n</code></pre> <pre><code>// Fichier : Joueur.cpp (nouveau)  \n#include \"Joueur.hpp\"  \n#include &lt;iostream&gt;  \n#include &lt;format&gt;  \n\nvoid Joueur::afficher() const { // Joueur:: indique que c'est une fonction de Joueur  \n    std::cout &lt;&lt; std::format(\"- Nom: {}, PV: {}\\n\", nom, points_de_vie);  \n}  \n</code></pre> <pre><code>// Fichier : main.cpp (refactoris\u00e9)  \n#include \"Joueur.hpp\"  \n\nint main() {  \n    Joueur p1 { .nom = \"Gandalf\", .points_de_vie = 1000 };  \n    p1.afficher(); // Appel plus naturel : on demande \u00e0 l'objet de s'afficher.  \n    return 0;  \n}  \n</code></pre></p>"},{"location":"notes/semaine_2_2_les_structs/#partie-4-gestion-de-la-memoire-et-fonctions","title":"Partie 4 : Gestion de la M\u00e9moire et Fonctions","text":"<p>Comment passer et retourner des <code>struct</code>s efficacement et sans danger.  </p>"},{"location":"notes/semaine_2_2_les_structs/#41-acces-point-vs-fleche-","title":"4.1 - Acc\u00e8s : Point (<code>.</code>) vs. Fl\u00e8che (<code>-&gt;</code>)","text":"Si vous avez... Op\u00e9rateur Syntaxe Exemple L'objet ou une r\u00e9f\u00e9rence Le point (<code>.</code>) <code>mon_objet.membre</code> <code>p1.nom</code> Un pointeur vers l'objet La fl\u00e8che (<code>-&gt;</code>) <code>ptr_objet-&gt;membre</code> <code>ptr_p1-&gt;nom</code> <p>La fl\u00e8che <code>-&gt;</code> est un raccourci pour d\u00e9r\u00e9f\u00e9rencer puis acc\u00e9der : <code>(*ptr_p1).nom</code>.  </p>"},{"location":"notes/semaine_2_2_les_structs/#42-passage-en-parametre","title":"4.2 - Passage en Param\u00e8tre","text":"<ul> <li>Lecture Seule (<code>const&amp;</code>) : Le plus s\u00fbr et le plus efficace pour passer des objets que la fonction ne doit pas modifier. \u00c9vite une copie. <pre><code>void afficher_details(const Joueur&amp; j) { /* ... */ }  \n</code></pre></li> <li>Lecture/\u00c9criture (<code>&amp;</code>) : Quand la fonction DOIT modifier l'objet original. <pre><code>void monter_niveau(Joueur&amp; j) { j.niveau += 1; }  \n</code></pre></li> </ul>"},{"location":"notes/semaine_2_2_les_structs/#43-retour-de-struct-depuis-une-fonction","title":"4.3 - Retour de <code>struct</code> depuis une fonction","text":"<ul> <li>Par Copie (S\u00fbr) : La fonction retourne une copie. L'objet original cr\u00e9\u00e9 dans la fonction est d\u00e9truit, mais sa copie survit. <pre><code>Joueur creer_ennemi() {  \n    Joueur orc { .nom = \"Orc de base\", .niveau = 1 };  \n    return orc; // OK : une copie de 'orc' est envoy\u00e9e.  \n}  \n</code></pre></li> <li>Par Pointeur (DANGEREUX !)     !!! failure \"\u00c0 NE JAMAIS FAIRE\"     Il ne faut jamais retourner l'adresse (<code>&amp;</code>) ou un pointeur (<code>*</code>) d'une variable locale. La variable est d\u00e9truite \u00e0 la fin de la fonction, et le pointeur devient un \"dangling pointer\" qui pointe vers une zone m\u00e9moire invalide. Utiliser ce pointeur m\u00e8ne \u00e0 un comportement ind\u00e9fini (crash, corruption). <pre><code>Joueur* creer_ennemi_dangereux() {  \n    Joueur gobelin { .nom = \"Gobelin\", .niveau = 1 };  \n    return &amp;gobelin; // ERREUR FATALE !  \n    /*  \n     * gobelin va \u00eatre d\u00e9truit apr\u00e8s la fonction.  \n     * C'est une variable locale, donc, le pointeur  \n     * va pointer sur une valeur instable.  \n     * (m\u00e9moire libre pour autre chose)  \n     */  \n}  \n</code></pre></li> </ul>"},{"location":"notes/semaine_2_2_les_structs/#partie-5-ouverture-vers-la-class-semaine-3","title":"Partie 5 : Ouverture vers la <code>class</code> (Semaine 3)","text":"<p>Le probl\u00e8me de nos <code>struct</code>s actuelles est que leurs donn\u00e9es sont publiques et vuln\u00e9rables (<code>p1.niveau = -99;</code>). La prochaine \u00e9tape est d'apprendre \u00e0 prot\u00e9ger les donn\u00e9es et \u00e0 garantir des r\u00e8gles (invariants) en utilisant le mot-cl\u00e9 <code>class</code>.  </p>"},{"location":"notes/semaine_2_2_les_structs/#apercu-de-levolution-en-class","title":"Aper\u00e7u de l'\u00c9volution en <code>class</code>","text":"<p><pre><code>// Fichier : Joueur.hpp (Version Semaine 3)  \n#pragma once  \n#include &lt;string&gt;  \n\nclass Joueur {  \nprivate: // Les donn\u00e9es sont maintenant prot\u00e9g\u00e9es et inaccessibles de l'ext\u00e9rieur.  \n    std::string nom_;  \n    int points_de_vie_;  \n    int niveau_;  \n\npublic:  \n    // Un \"constructeur\" pour garantir que chaque Joueur est cr\u00e9\u00e9 dans un \u00e9tat valide.  \n    Joueur(const std::string&amp; nom, int pv, int niveau);  \n\n    // Une fonction membre pour une modification contr\u00f4l\u00e9e des donn\u00e9es.  \n    void subir_degats(int degats);  \n\n    // Une fonction membre pour un acc\u00e8s en lecture seule.  \n    void afficher() const;  \n\n    // Un \"getter\" pour lire une valeur priv\u00e9e de mani\u00e8re contr\u00f4l\u00e9e.  \n    int get_niveau() const;  \n};  \n</code></pre> Cette structure est le c\u0153ur de la programmation orient\u00e9e objet en C++ et sera l'objet de la semaine 3.  </p>"},{"location":"notes/semaine_2_2_les_structs/#partie-6-exercices","title":"Partie 6 : Exercices","text":"<p>(Les exercices de la version pr\u00e9c\u00e9dente sont plac\u00e9s ici pour la mise en pratique.) Pour mettre en pratique les concepts ci-dessus, imaginez que vous travaillez avec la structure de fichiers suivante : - <code>Livre.hpp</code> - <code>Exercices.hpp</code> - <code>Exercices.cpp</code> - <code>main.cpp</code> </p>"},{"location":"notes/semaine_2_2_les_structs/#exercice-1-definition-et-initialisation","title":"Exercice 1 : D\u00e9finition et Initialisation","text":"<ol> <li>Dans <code>Livre.hpp</code>, d\u00e9finissez une <code>struct Livre</code> avec <code>titre</code>, <code>auteur</code>, <code>annee_publication</code>.  </li> <li>Dans <code>main.cpp</code>, cr\u00e9ez une instance de <code>Livre</code> et affichez ses membres.  </li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-2-fonctions-libres","title":"Exercice 2 : Fonctions Libres","text":"<ol> <li>Cr\u00e9ez <code>LivreActions.hpp</code>/<code>.cpp</code>.  </li> <li>D\u00e9clarez et d\u00e9finissez une fonction <code>void afficher_livre(const Livre&amp; l);</code>.  </li> <li>Appelez cette fonction depuis <code>main</code>.  </li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-3-fonctions-membres","title":"Exercice 3 : Fonctions Membres","text":"<ol> <li>Modifiez <code>Livre.hpp</code> pour y d\u00e9clarer une fonction membre <code>void afficher() const;</code>.  </li> <li>Cr\u00e9ez <code>Livre.cpp</code> pour impl\u00e9menter <code>Livre::afficher()</code>.  </li> <li>Modifiez <code>main.cpp</code> pour appeler <code>mon_livre.afficher()</code>.  </li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-4-modification-et-pointeur","title":"Exercice 4 : Modification et Pointeur","text":"<ol> <li>\u00c9crivez une fonction membre <code>void corriger_annee(int nouvelle_annee);</code> qui modifie l'ann\u00e9e.  </li> <li>Dans <code>main</code>, cr\u00e9ez un pointeur sur votre livre et utilisez <code>-&gt;</code> pour appeler <code>corriger_annee</code>.  </li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-5-factory-function","title":"Exercice 5 : Factory Function","text":"<ol> <li>\u00c9crivez une fonction libre <code>Livre creer_best_seller();</code> qui retourne un <code>Livre</code> par copie.  </li> <li>Appelez-la depuis <code>main</code> pour cr\u00e9er un nouveau livre.  </li> </ol> <p>```  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/","title":"Allocation de <code>struct</code> : Pile (Stack) vs. Tas (Heap)","text":"<p>En C++, la gestion de la m\u00e9moire est un concept fondamental, et comprendre la diff\u00e9rence entre allouer des donn\u00e9es sur la pile d'appel (stack) et sur le tas (heap) est crucial, surtout lorsqu'il s'agit de <code>struct</code> (ou de classes).  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/#1-allocation-sur-la-pile-stack","title":"1. Allocation sur la Pile (Stack)","text":"<p>Lorsqu'une variable (y compris une instance de <code>struct</code>) est d\u00e9clar\u00e9e directement \u00e0 l'int\u00e9rieur d'une fonction sans utiliser <code>new</code>, elle est allou\u00e9e sur la pile d'appel.  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/#caracteristiques","title":"Caract\u00e9ristiques :","text":"<ul> <li>Dur\u00e9e de vie automatique (Automatic Storage Duration) : L'objet est cr\u00e9\u00e9 \u00e0 l'entr\u00e9e du bloc o\u00f9 il est d\u00e9clar\u00e9 et d\u00e9truit automatiquement \u00e0 la sortie de ce bloc (g\u00e9n\u00e9ralement la fin de la fonction).  </li> <li>Rapide : L'allocation et la d\u00e9sallocation sont tr\u00e8s rapides car elles impliquent de simples ajustements du pointeur de pile.  </li> <li>Taille fixe : La taille de l'objet doit \u00eatre connue \u00e0 la compilation.  </li> <li>M\u00e9moire limit\u00e9e : La pile a une taille limit\u00e9e (souvent quelques Mo), et une allocation excessive peut entra\u00eener un \"stack overflow\".  </li> </ul>"},{"location":"notes/semaine_3_2_struct_pile_tas/#exemple","title":"Exemple :","text":"<p>Consid\u00e9rons une simple <code>struct</code> <code>Point</code>.  </p> <pre><code>struct Point {  \n    int x;  \n    int y;  \n};  \n\nvoid fonctionAvecPile() {  \n    // 'p1' est allou\u00e9 sur la pile  \n    Point p1;  \n    p1.x = 10;  \n    p1.y = 20;  \n\n    std::cout &lt;&lt; \"Point sur la pile: (\" &lt;&lt; p1.x &lt;&lt; \", \" &lt;&lt; p1.y &lt;&lt; \")\" &lt;&lt; std::endl;  \n\n    // 'p1' sera automatiquement d\u00e9truit \u00e0 la fin de cette fonction  \n} // &lt;-- 'p1' est d\u00e9truit ici  \n</code></pre>"},{"location":"notes/semaine_3_2_struct_pile_tas/#2-allocation-sur-le-tas-heap","title":"2. Allocation sur le Tas (Heap)","text":"<p>L'allocation sur le tas, ou m\u00e9moire dynamique, est effectu\u00e9e explicitement par le programmeur \u00e0 l'aide de l'op\u00e9rateur <code>new</code>.  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/#caracteristiques_1","title":"Caract\u00e9ristiques :","text":"<ul> <li>Dur\u00e9e de vie dynamique (Dynamic Storage Duration) : L'objet est cr\u00e9\u00e9 et existe jusqu'\u00e0 ce qu'il soit explicitement d\u00e9truit par l'op\u00e9rateur <code>delete</code>. Si <code>delete</code> n'est pas appel\u00e9, il y a une fuite de m\u00e9moire.  </li> <li>Plus lente : L'allocation et la d\u00e9sallocation sont plus lentes que sur la pile car elles impliquent la recherche d'espace m\u00e9moire disponible.  </li> <li>Taille variable : La taille de l'objet peut \u00eatre d\u00e9termin\u00e9e \u00e0 l'ex\u00e9cution.  </li> <li>M\u00e9moire plus grande : Le tas est g\u00e9n\u00e9ralement beaucoup plus grand que la pile (limit\u00e9 par la m\u00e9moire vive disponible).  </li> <li>Pointeurs : L'op\u00e9rateur <code>new</code> renvoie un pointeur vers l'objet allou\u00e9 sur le tas.  </li> </ul>"},{"location":"notes/semaine_3_2_struct_pile_tas/#exemple_1","title":"Exemple :","text":"<p>Reprenons notre <code>struct</code> <code>Point</code>.  </p> <pre><code>struct Point {  \n    int x;  \n    int y;  \n};  \n\nvoid fonctionAvecTas() {  \n    // 'p2' (le pointeur) est sur la pile, mais l'objet 'Point' point\u00e9 par 'p2' est sur le tas  \n    Point* p2 = new Point;  \n    p2-&gt;x = 30;  \n    p2-&gt;y = 40;  \n\n    std::cout &lt;&lt; \"Point sur le tas: (\" &lt;&lt; p2-&gt;x &lt;&lt; \", \" &lt;&lt; p2-&gt;y &lt;&lt; \")\" &lt;&lt; std::endl;  \n\n    // Il est CRUCIAL de lib\u00e9rer la m\u00e9moire allou\u00e9e sur le tas  \n    delete p2; // &lt;-- 'Point' est d\u00e9truit ici, la m\u00e9moire est lib\u00e9r\u00e9e  \n    p2 = nullptr; // Bonne pratique: \u00e9viter les pointeurs \"dangling\"  \n} // &lt;-- 'p2' (le pointeur lui-m\u00eame) est d\u00e9truit ici (mais pas l'objet s'il n'a pas \u00e9t\u00e9 supprim\u00e9)  \n</code></pre>"},{"location":"notes/semaine_3_2_struct_pile_tas/#3-quand-utiliser-quoi","title":"3. Quand utiliser quoi ?","text":"Caract\u00e9ristique Pile (Stack) Tas (Heap) Dur\u00e9e de vie Automatique (scope du bloc) Dynamique (manuelle avec <code>new</code>/<code>delete</code>) Vitesse Tr\u00e8s rapide Plus lente Gestion m\u00e9moire Automatique Manuelle (source de fuites si oubli de <code>delete</code>) Taille Fixe, connue \u00e0 la compilation Variable, peut \u00eatre d\u00e9termin\u00e9e \u00e0 l'ex\u00e9cution Limites Taille limit\u00e9e (stack overflow possible) Plus grande (limit\u00e9e par RAM), fragmentation possible Acc\u00e8s Direct Via un pointeur Quand l'utiliser ? Objets de petite taille, dur\u00e9e de vie locale Objets de grande taille, dur\u00e9e de vie au-del\u00e0 du scope, polymorphisme"},{"location":"notes/semaine_3_2_struct_pile_tas/#4-les-dangers-des-pointeurs-standards-bruts","title":"4. Les Dangers des Pointeurs Standards (bruts)","text":"<p>Comme illustr\u00e9 avec <code>new</code> et <code>delete</code>, la gestion manuelle de la m\u00e9moire sur le tas avec des pointeurs standards (dits \"bruts\" ou \"raw pointers\") est sujette aux erreurs : - Fuites de m\u00e9moire (Memory Leaks) : Oubli de <code>delete</code>. - Pointeurs invalides (Dangling Pointers) : Utilisation d'un pointeur apr\u00e8s que la m\u00e9moire qu'il pointait ait \u00e9t\u00e9 lib\u00e9r\u00e9e. - Double lib\u00e9ration (Double Free) : Tenter de lib\u00e9rer la m\u00eame m\u00e9moire deux fois.  </p> <p>Bien que nous nous concentrions sur les pointeurs standards pour le moment, il est important de savoir que C++ moderne offre une solution beaucoup plus s\u00fbre et robuste pour la gestion de la m\u00e9moire dynamique : les pointeurs intelligents (smart pointers). Ceux-ci g\u00e8rent automatiquement la lib\u00e9ration de la m\u00e9moire, \u00e9liminant ainsi la plupart des erreurs mentionn\u00e9es ci-dessus. Nous explorerons ce sujet plus en d\u00e9tail ult\u00e9rieurement.  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/#5-retour-de-valeurs-par-fonction-une-difference-cle-avec-c-et-java","title":"5. Retour de valeurs par fonction : Une diff\u00e9rence cl\u00e9 avec C# et Java","text":"<p>Pour des \u00e9tudiants venant de langages comme C# ou Java, la mani\u00e8re dont C++ g\u00e8re le retour d'objets (comme nos <code>struct</code> ou des classes) par valeur depuis une fonction est une diff\u00e9rence fondamentale.  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/#c-le-retour-par-copie","title":"C++ : Le retour par copie","text":"<p>En C++, lorsqu'une fonction retourne un objet par valeur, cela signifie qu'une copie compl\u00e8te de cet objet est cr\u00e9\u00e9e. L'objet original (souvent une variable locale \u00e0 la fonction) est copi\u00e9 vers l'emplacement o\u00f9 la fonction doit stocker son r\u00e9sultat.  </p> <ul> <li>Impact : Si votre <code>struct</code> ou classe est \"lourde\" (contient beaucoup de donn\u00e9es, comme un grand tableau ou des ressources complexes), cette copie peut prendre du temps et utiliser de la m\u00e9moire. C'est comme photocopier un gros livre entier \u00e0 chaque fois que vous le passez \u00e0 quelqu'un.  </li> </ul> <p><pre><code>struct MaStructLourde {  \n    int donnees[1000]; // Une struct \"lourde\" pour l'exemple  \n    MaStructLourde() { /* std::cout &lt;&lt; \"Constructeur MaStructLourde\" &lt;&lt; std::endl; */ }  \n    MaStructLourde(const MaStructLourde&amp;) { /* std::cout &lt;&lt; \"Constructeur de copie MaStructLourde\" &lt;&lt; std::endl; */ }  \n};  \n\nMaStructLourde creerEtRetournerStruct() {  \n    MaStructLourde s; // L'objet est cr\u00e9\u00e9 ici  \n    // ... remplissage de 's'  \n    return s; // Une copie de 's' est faite pour le retour de la fonction  \n}  \n\nint main() {  \n    MaStructLourde resultat = creerEtRetournerStruct(); // La copie est re\u00e7ue ici dans 'resultat'  \n    return 0;  \n}  \n</code></pre> Si vous testez le code ci-dessus en d\u00e9commentant les <code>std::cout</code> dans <code>MaStructLourde</code>, vous verrez souvent que le constructeur de copie est appel\u00e9, ce qui indique qu'une copie a bien eu lieu.  </p>"},{"location":"notes/semaine_3_2_struct_pile_tas/#contraste-avec-c-et-java-le-retour-de-references","title":"Contraste avec C# et Java : Le retour de r\u00e9f\u00e9rences","text":"<p>Dans des langages comme C# et Java, la gestion des objets de classe (non-primitifs) est diff\u00e9rente :  </p> <ul> <li>Tous les objets de classe vivent sur le tas (heap) et sont toujours manipul\u00e9s via des r\u00e9f\u00e9rences. Une r\u00e9f\u00e9rence est un petit marqueur (comme une adresse m\u00e9moire) qui \"pointe\" vers l'objet r\u00e9el sur le tas.  </li> <li>Lorsque vous retournez un objet d'une fonction, vous ne retournez pas l'objet lui-m\u00eame, mais une copie de cette petite r\u00e9f\u00e9rence. L'objet sur le tas, lui, n'est jamais dupliqu\u00e9. C'est comme passer un petit papier avec l'adresse du gros livre, au lieu de le photocopier.  </li> </ul>"},{"location":"notes/semaine_3_2_struct_pile_tas/#retenir-pour-c","title":"Retenir pour C++","text":"<p>En C++, si vous retournez un objet par valeur, attendez-vous \u00e0 une copie. Cette copie est n\u00e9cessaire car la variable locale \u00e0 la fonction qui contenait l'objet original sera automatiquement d\u00e9truite (lib\u00e9r\u00e9e de la pile) d\u00e8s que la fonction se termine. Sans cette copie, l'objet retourn\u00e9 n'existerait plus. Cela peut \u00eatre important pour la performance avec de gros objets. C'est une distinction cl\u00e9 par rapport aux langages o\u00f9 les objets sont toujours pass\u00e9s par r\u00e9f\u00e9rence.  </p>"},{"location":"notes/semaine_3_3_gestion_exceptions/","title":"Gestion des Exceptions : <code>try</code>, <code>catch</code> et <code>throw</code>","text":"<p>En C++, les exceptions sont un m\u00e9canisme puissant pour g\u00e9rer les erreurs et les situations anormales de mani\u00e8re propre et structur\u00e9e, sans interrompre le flux normal du programme. Elles permettent de s\u00e9parer la logique de gestion des erreurs de la logique principale de l'application.  </p>"},{"location":"notes/semaine_3_3_gestion_exceptions/#1-lever-une-exception-throw","title":"1. Lever une Exception (<code>throw</code>)","text":"<p>Lorsqu'une condition d'erreur est d\u00e9tect\u00e9e, une exception peut \u00eatre \"lanc\u00e9e\" (thrown) pour signaler qu'un probl\u00e8me est survenu. Le programme arr\u00eate alors l'ex\u00e9cution normale et recherche un gestionnaire d'exceptions (<code>catch</code>).  </p> <p>Vous pouvez lancer n'importe quel type de donn\u00e9es comme exception, mais il est fortement recommand\u00e9 de lancer des objets de classes d\u00e9riv\u00e9es de <code>std::exception</code>. Cela permet une gestion polymorphique et standardis\u00e9e des erreurs.  </p> <p>Exemple : <code>std::out_of_range</code> pour un index invalide </p> <p>L'exception <code>std::out_of_range</code> est couramment utilis\u00e9e pour signaler qu'un index est en dehors des limites valides d'un conteneur (comme un tableau ou un vecteur).  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;vector&gt;  \n#include &lt;stdexcept&gt; // Pour std::out_of_range  \n\n// Fonction qui pourrait lever une exception  \nint obtenirElement(const std::vector&lt;int&gt;&amp; v, int index) {  \n    if (index &lt; 0 || index &gt;= v.size()) {  \n        // Lever une exception std::out_of_range  \n        throw std::out_of_range(\"Index hors limites : \" + std::to_string(index) +  \n                                \" n'est pas dans la plage [0, \" + std::to_string(v.size() - 1) + \"]\");  \n    }  \n    return v[index];  \n}  \n\nint main() {  \n    std::vector&lt;int&gt; nombres = {10, 20, 30};  \n\n    // Tentative d'acc\u00e8s avec un index valide  \n    std::cout &lt;&lt; \"Element a l'index 1 : \" &lt;&lt; obtenirElement(nombres, 1) &lt;&lt; std::endl;  \n\n    // Tentative d'acc\u00e8s avec un index invalide (ceci sera g\u00e9r\u00e9 par try-catch plus loin)  \n    // obtenirElement(nombres, 5); // Cette ligne l\u00e8verait une exception non g\u00e9r\u00e9e ici  \n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_3_3_gestion_exceptions/#2-capturer-une-exception-try-et-catch","title":"2. Capturer une Exception (<code>try</code> et <code>catch</code>)","text":"<p>Pour g\u00e9rer les exceptions lanc\u00e9es, vous utilisez des blocs <code>try</code> et <code>catch</code>.  </p> <ul> <li>Le bloc <code>try</code> contient le code qui pourrait potentiellement lever une exception.  </li> <li>Le bloc <code>catch</code> suit imm\u00e9diatement le bloc <code>try</code> et sp\u00e9cifie le type d'exception qu'il est capable de g\u00e9rer. Si une exception du type sp\u00e9cifi\u00e9 est lanc\u00e9e dans le bloc <code>try</code>, le contr\u00f4le est transf\u00e9r\u00e9 au bloc <code>catch</code> correspondant.  </li> </ul> <p>Vous pouvez avoir plusieurs blocs <code>catch</code> pour g\u00e9rer diff\u00e9rents types d'exceptions, et un <code>catch(...)</code> pour capturer toute exception non g\u00e9r\u00e9e sp\u00e9cifiquement (\u00e0 utiliser avec prudence).  </p> <p>Exemple : Utilisation de <code>try-catch</code> </p> <p>Reprenons l'exemple pr\u00e9c\u00e9dent avec un bloc <code>try-catch</code> pour g\u00e9rer l'exception <code>std::out_of_range</code>.  </p> <pre><code>#include &lt;iostream&gt;  \n#include &lt;vector&gt;  \n#include &lt;stdexcept&gt; // Pour std::out_of_range  \n\n// Fonction qui pourrait lever une exception (identique \u00e0 pr\u00e9c\u00e9demment)  \nint obtenirElement(const std::vector&lt;int&gt;&amp; v, int index) {  \n    if (index &lt; 0 || index &gt;= v.size()) {  \n        throw std::out_of_range(\"Index hors limites : \" + std::to_string(index) +  \n                                \" n'est pas dans la plage [0, \" + std::to_string(v.size() - 1) + \"]\");  \n    }  \n    return v[index];  \n}  \n\nint main() {  \n    std::vector&lt;int&gt; nombres = {10, 20, 30};  \n\n    // Exemple avec un index valide  \n    try {  \n        std::cout &lt;&lt; \"Element a l'index 1 : \" &lt;&lt; obtenirElement(nombres, 1) &lt;&lt; std::endl;  \n    } catch (const std::out_of_range&amp; e) {  \n        // Ce bloc ne sera pas ex\u00e9cut\u00e9 pour un index valide  \n        std::cerr &lt;&lt; \"Erreur (valide) : \" &lt;&lt; e.what() &lt;&lt; std::endl;  \n    } catch (const std::exception&amp; e) {  \n        std::cerr &lt;&lt; \"Erreur generique (valide) : \" &lt;&lt; e.what() &lt;&lt; std::endl;  \n    }  \n\n    // Exemple avec un index invalide  \n    try {  \n        std::cout &lt;&lt; \"Element a l'index 5 : \" &lt;&lt; obtenirElement(nombres, 5) &lt;&lt; std::endl;  \n    } catch (const std::out_of_range&amp; e) {  \n        // Ce bloc sera ex\u00e9cut\u00e9 car une std::out_of_range a \u00e9t\u00e9 lanc\u00e9e  \n        std::cerr &lt;&lt; \"Erreur (invalide) : \" &lt;&lt; e.what() &lt;&lt; std::endl;  \n    } catch (const std::exception&amp; e) {  \n        // Ce bloc capturerait d'autres exceptions d\u00e9riv\u00e9es de std::exception  \n        std::cerr &lt;&lt; \"Erreur generique (invalide) : \" &lt;&lt; e.what() &lt;&lt; std::endl;  \n    } catch (...) {  \n        // Ce bloc capturerait toute autre exception non d\u00e9riv\u00e9e de std::exception  \n        std::cerr &lt;&lt; \"Erreur inconnue.\" &lt;&lt; std::endl;  \n    }  \n\n    std::cout &lt;&lt; \"Le programme continue son execution apres la gestion de l'exception.\" &lt;&lt; std::endl;  \n\n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_3_3_gestion_exceptions/#3-quand-utiliser-les-exceptions","title":"3. Quand utiliser les Exceptions ?","text":"<p>Utilisez les exceptions pour signaler des situations exceptionnelles et anormales qui emp\u00eachent une fonction de remplir son contrat (par exemple, un fichier manquant, un index hors limites, une allocation m\u00e9moire \u00e9chou\u00e9e).  </p> <p>N'utilisez PAS les exceptions pour le contr\u00f4le de flux normal ou pour des erreurs mineures qui peuvent \u00eatre g\u00e9r\u00e9es par des valeurs de retour (comme un <code>false</code> pour une op\u00e9ration qui \u00e9choue fr\u00e9quemment). L'utilisation abusive des exceptions peut rendre le code plus difficile \u00e0 lire et moins performant.  </p> <p>Exemples de situations o\u00f9 les exceptions ne devraient PAS \u00eatre utilis\u00e9es pour le contr\u00f4le de flux normal : </p> <ol> <li> <p>V\u00e9rification de l'existence d'un fichier ou d'une entr\u00e9e utilisateur invalide : </p> <ul> <li>Pratique \u00e0 \u00e9viter (utilisation d'exception pour le contr\u00f4le de flux) : <pre><code>try {  \n    ouvrirFichier(\"monFichier.txt\"); // Lance une exception si le fichier n'existe pas  \n    // Traiter le fichier  \n} catch (const FichierNonTrouveException&amp; e) {  \n    std::cerr &lt;&lt; \"Erreur : \" &lt;&lt; e.what() &lt;&lt; std::endl;  \n    // G\u00e9rer le cas o\u00f9 le fichier n'existe pas  \n}  \n</code></pre></li> <li>Bonne pratique (contr\u00f4le de flux normal) : <pre><code>if (fichierExiste(\"monFichier.txt\")) {  \n    ouvrirFichier(\"monFichier.txt\");  \n    // Traiter le fichier  \n} else {  \n    std::cerr &lt;&lt; \"Erreur : Le fichier 'monFichier.txt' n'a pas \u00e9t\u00e9 trouv\u00e9.\" &lt;&lt; std::endl;  \n    // G\u00e9rer le cas o\u00f9 le fichier n'existe pas  \n}  \n</code></pre></li> <li>Raisonnement : V\u00e9rifier l'existence d'un fichier avant de l'ouvrir est une condition attendue et fr\u00e9quente. Utiliser une exception force une gestion plus lourde et n'est pas idiomatique pour ce type de v\u00e9rification.  </li> </ul> </li> <li> <p>Parcourir les \u00e9l\u00e9ments d'une collection et d\u00e9tecter la fin : </p> <ul> <li>Pratique \u00e0 \u00e9viter (utilisation d'exception pour le contr\u00f4le de flux) : <pre><code>std::vector&lt;int&gt; nombres = {1, 2, 3};  \ntry {  \n    for (size_t i = 0; ; ++i) {  \n        // Acc\u00e9der \u00e0 nombres.at(i) qui lance une std::out_of_range si l'index est hors limites  \n        std::cout &lt;&lt; nombres.at(i) &lt;&lt; std::endl;  \n    }  \n} catch (const std::out_of_range&amp; e) {  \n    // Fin de la boucle, car l'exception indique qu'il n'y a plus d'\u00e9l\u00e9ments  \n}  \n</code></pre></li> <li>Bonne pratique (contr\u00f4le de flux normal) : <pre><code>std::vector&lt;int&gt; nombres = {1, 2, 3};  \nfor (int nombre : nombres) { // Ou for (size_t i = 0; i &lt; nombres.size(); ++i)  \n    std::cout &lt;&lt; nombre &lt;&lt; std::endl;  \n}  \n</code></pre></li> <li>Raisonnement : L'it\u00e9ration sur une collection et la d\u00e9tection de sa fin sont des op\u00e9rations fondamentales et attendues en programmation. Les boucles sont con\u00e7ues sp\u00e9cifiquement pour cela et sont beaucoup plus claires et efficaces que de s'appuyer sur des exceptions pour signaler la fin.  </li> </ul> </li> </ol>"},{"location":"notes/semaine_4_2_compilation/","title":"L'\u00c9volution d'un Projet C++ : Du Chaos \u00e0 l'Automatisation","text":"<p>Ce guide suit l'\u00e9volution naturelle d'un projet C++. L'objectif est de comprendre que chaque \"bonne pratique\" na\u00eet d'une douleur ou d'une r\u00e9p\u00e9tition inutile.  </p>"},{"location":"notes/semaine_4_2_compilation/#etape-1-le-vrac-tout-a-la-racine","title":"\u00c9tape 1 : Le \"Vrac\" (Tout \u00e0 la racine)","text":"<p>Au d\u00e9but, on met tout dans le m\u00eame dossier. C'est simple, mais \u00e7a devient vite le bazar.  </p> <p>Structure : <pre><code>ProjetBanque/  \n\u251c\u2500\u2500 main.cpp         &lt;-- Point d'entr\u00e9e de l'application (contient le main)  \n\u251c\u2500\u2500 Banque.cpp       &lt;-- Impl\u00e9mentation de la classe Banque  \n\u2514\u2500\u2500 Banque.hpp       &lt;-- D\u00e9claration de la classe (interface)  \n</code></pre></p> <p>\ud83d\udd28 Compilation et Ex\u00e9cution : <pre><code># Compiler  \ng++ -Wall -std=c++20 main.cpp Banque.cpp -o app  \n\n# Lancer l'application  \n./app  \n</code></pre></p> <p>\ud83d\udd34 Le point de friction : D\u00e8s que vous atteignez 10 fichiers, chercher un header au milieu des fichiers compil\u00e9s devient un enfer visuel.  </p>"},{"location":"notes/semaine_4_2_compilation/#etape-2-lorganisation-src-et-include","title":"\u00c9tape 2 : L'Organisation (src et include)","text":"<p>On s\u00e9pare les intentions : ce qui est public (headers) et ce qui est priv\u00e9 (code).  </p> <p>Structure : <pre><code>ProjetBanque/  \n\u251c\u2500\u2500 include/  \n\u2502   \u2514\u2500\u2500 Banque.hpp   &lt;-- On range les d\u00e9finitions (.hpp) ici  \n\u2514\u2500\u2500 src/  \n    \u251c\u2500\u2500 main.cpp         &lt;-- Point d'entr\u00e9e principal  \n    \u2514\u2500\u2500 Banque.cpp       &lt;-- Impl\u00e9mentation (.cpp)  \n</code></pre></p> <p>\ud83d\udd28 Compilation et Ex\u00e9cution : <pre><code># Compiler (il faut dire au compilateur o\u00f9 est le dossier 'include')  \ng++ -Wall -std=c++20 -I include src/main.cpp src/Banque.cpp -o app  \n\n# Lancer  \n./app  \n</code></pre></p> <p>\ud83d\udfe0 Le point de friction : Le param\u00e8tre <code>-I include</code> devient obligatoire. On commence \u00e0 \"configurer\" au lieu de juste \"coder\".  </p>"},{"location":"notes/semaine_4_2_compilation/#etape-3-larrivee-des-tests-le-point-de-rupture","title":"\u00c9tape 3 : L'arriv\u00e9e des Tests (Le point de rupture)","text":"<p>On veut tester notre classe <code>Banque</code> de mani\u00e8re pro avec la biblioth\u00e8que Catch2.  </p>"},{"location":"notes/semaine_4_2_compilation/#1-telecharger-la-bibliotheque-deja-existante","title":"1. T\u00e9l\u00e9charger la biblioth\u00e8que (D\u00e9j\u00e0 existante)","text":"<pre><code>mkdir lib  \nwget https://github.com/catchorg/Catch2/releases/download/v2.13.10/catch.hpp -O lib/catch.hpp &lt;-- mettre le catch.hpp dans le dossier lib du projet  \n</code></pre>"},{"location":"notes/semaine_4_2_compilation/#2-creer-votre-point-dentree-testsmain_testcpp","title":"2. Cr\u00e9er VOTRE point d'entr\u00e9e (<code>tests/main_test.cpp</code>)","text":"<pre><code>#define CATCH_CONFIG_MAIN  \n#include \"catch.hpp\"  \n</code></pre> <p>Structure compl\u00e8te : <pre><code>ProjetBanque/  \n\u251c\u2500\u2500 include/  \n\u2502   \u2514\u2500\u2500 Banque.hpp       &lt;-- D\u00e9claration de Banque  \n\u251c\u2500\u2500 src/  \n\u2502   \u251c\u2500\u2500 main.cpp         &lt;-- Poss\u00e8de le main() de l'APPLICATION  \n\u2502   \u2514\u2500\u2500 Banque.cpp       &lt;-- Code de Banque  \n\u251c\u2500\u2500 lib/  \n\u2502   \u2514\u2500\u2500 catch.hpp        &lt;-- La librairie t\u00e9l\u00e9charg\u00e9e (ne pas toucher)  \n\u2514\u2500\u2500 tests/  \n    \u251c\u2500\u2500 main_test.cpp    &lt;-- Poss\u00e8de le main() des TESTS  \n    \u2514\u2500\u2500 test_Banque.cpp  &lt;-- Vos TEST_CASE unitaires pour Banque  \n</code></pre></p> <p>\ud83d\udd28 Compilation et Ex\u00e9cution (Le cauchemar) : Il faut maintenant deux commandes diff\u00e9rentes car on ne peut pas m\u00e9langer les deux fichiers contenant un <code>main()</code>.  </p> <pre><code># 1. Compiler l'Application  \ng++ -Wall -std=c++20  -I include src/main.cpp src/Banque.cpp -o app  \n\n# 2. Compiler les Tests (Notez l'ajout de -I lib)  \ng++ -Wall -std=c++20  -I include -I lib tests/main_test.cpp tests/test_Banque.cpp src/Banque.cpp -o tests_app  \n\n# Lancer les tests  \n./tests_app  \n</code></pre> <p>\ud83d\udfe1 Le point de friction : La commande est trop longue. Si vous ajoutez <code>Compte.cpp</code>, vous devez modifier vos deux commandes manuellement. C'est ici que l'on craque.  </p>"},{"location":"notes/semaine_4_2_compilation/#etape-4-lautomatisation-naive-cmake-rigide","title":"\u00c9tape 4 : L'Automatisation Na\u00efve (CMake rigide)","text":"<p>Plut\u00f4t que de taper ces lignes de 100 caract\u00e8res, on confie la \"recette\" \u00e0 CMake.  </p> <p>\u26a0\ufe0f Nouveaut\u00e9 : Le dossier <code>build/</code> CMake g\u00e9n\u00e8re \u00e9norm\u00e9ment de fichiers temporaires (Makefiles, fichiers .o, caches). Si on lance CMake \u00e0 la racine, on pollue tout notre projet. La r\u00e8gle d'or : On cr\u00e9e un dossier <code>build</code> qui servira de \"poubelle de compilation\". Tout ce qui est compil\u00e9 ira dedans. Si on veut tout nettoyer, on supprime juste ce dossier.  </p> <p>Fichier <code>CMakeLists.txt</code> : <pre><code>cmake_minimum_required(VERSION 3.10)  \nproject(ProjetBanque)  \ninclude_directories(include lib)  \n\n# On doit tout lister \u00e0 la main... p\u00e9nible si on a 50 fichiers !  \nadd_executable(app src/main.cpp src/Banque.cpp src/Compte.cpp)  \nadd_executable(tests_app tests/main_test.cpp tests/test_Banque.cpp src/Banque.cpp src/Compte.cpp)  \n</code></pre></p> <p>\ud83d\udd28 Compilation et Ex\u00e9cution : <pre><code>mkdir build      # 1. On cr\u00e9e le dossier de compilation  \ncd build         # 2. On entre dedans  \ncmake ..         # 3. On demande \u00e0 CMake de pr\u00e9parer la recette (.. veut dire 'cherche le CMakeLists au dessus') il va cr\u00e9er le fichier makefile pour la compilation  \nmake             # 4. On lance la compilation r\u00e9elle  \n\n# Lancer l'un ou l'autre (ils sont maintenant dans build/)  \n./app  \n./tests_app  \n</code></pre></p>"},{"location":"notes/semaine_4_2_compilation/#etape-5-la-solution-flexible-le-standard","title":"\u00c9tape 5 : La Solution Flexible (Le Standard)","text":"<p>On utilise le scan automatique (<code>GLOB</code>) pour ne plus jamais toucher au fichier CMake.  </p> <p>Fichier <code>CMakeLists.txt</code> final : <pre><code>cmake_minimum_required(VERSION 3.10)  \nproject(ProjetBanque) \n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\ninclude_directories(include lib)  \n\n# On scanne les dossiers automatiquement  \nfile(GLOB SRC_FILES \"src/*.cpp\")  \nfile(GLOB TEST_FILES \"tests/*.cpp\")  \n\n# On enl\u00e8ve le main de l'app pour les tests (pour \u00e9viter le conflit)  \nset(LIB_FILES ${SRC_FILES})  \nlist(REMOVE_ITEM LIB_FILES \"${CMAKE_CURRENT_SOURCE_DIR}/src/main.cpp\")  \n\n# On d\u00e9finit les deux ex\u00e9cutables  \nadd_executable(app src/main.cpp ${LIB_FILES})  \nadd_executable(tests_app ${TEST_FILES} ${LIB_FILES})  \n</code></pre></p> <p>Structure finale : <pre><code>ProjetBanque/  \n\u251c\u2500\u2500 build/               &lt;-- CR\u00c9\u00c9 PAR VOUS (mkdir) : Contient tout ce qui est g\u00e9n\u00e9r\u00e9 (app, tests_app, etc.)  \n\u251c\u2500\u2500 include/             &lt;-- Tous vos headers (.hpp)  \n\u251c\u2500\u2500 src/                 &lt;-- Toute votre logique (.cpp)  \n\u251c\u2500\u2500 lib/                 &lt;-- Librairies externes (Catch2)  \n\u251c\u2500\u2500 tests/               &lt;-- Tous vos fichiers de tests  \n\u2514\u2500\u2500 CMakeLists.txt       &lt;-- Automatique et intelligent  \n</code></pre></p> <p>\ud83d\udd28 Utilisation au quotidien : <pre><code>cd build  \nmake             # Re-compile tout ce qui a chang\u00e9  \n./app            # Lance l'application bancaire  \n./tests_app      # Lance la suite de tests  \n</code></pre></p> <p>\ud83d\udfe2 Le r\u00e9sultat : Vous cr\u00e9ez un fichier ? <code>make</code>. Vous ajoutez un test ? <code>make</code>. La structure est devenue invisible, robuste et automatique.  </p>"},{"location":"notes/semaine_4_3_tests_unitaires/","title":"Les Tests Unitaires avec Catch2","text":"<p>Le test unitaire consiste \u00e0 v\u00e9rifier une seule \"unit\u00e9\" de code (g\u00e9n\u00e9ralement une m\u00e9thode ou une fonction) de mani\u00e8re isol\u00e9e. L'objectif est de s'assurer que chaque petit morceau de logique fonctionne parfaitement avant de les assembler.  </p>"},{"location":"notes/semaine_4_3_tests_unitaires/#1-la-regle-dor-un-test-un-comportement","title":"1. La r\u00e8gle d'or : Un test = Un comportement","text":"<p>En Programmation 3, nous privil\u00e9gions l'utilisation d'un <code>TEST_CASE</code> distinct pour chaque r\u00e8gle d'affaire. Cela permet d'identifier pr\u00e9cis\u00e9ment quelle r\u00e8gle est bris\u00e9e sans que les autres tests ne soient affect\u00e9s.  </p>"},{"location":"notes/semaine_4_3_tests_unitaires/#2-structure-dun-fichier-de-test","title":"2. Structure d'un fichier de test","text":"<p>Pour \u00e9viter les probl\u00e8mes de compilation et de collision de la fonction <code>main()</code>, nous s\u00e9parons les fichiers en deux types.  </p>"},{"location":"notes/semaine_4_3_tests_unitaires/#a-le-porte-etendard-le-runner","title":"A. Le \"Porte-\u00c9tendard\" (Le Runner)","text":"<p>Ce fichier doit \u00eatre pr\u00e9sent une seule fois dans votre projet. Il s'occupe de compiler Catch2 et de g\u00e9n\u00e9rer la fonction <code>main()</code>. Cr\u00e9ez-le sous le nom <code>main_test.cpp</code>.  </p> <pre><code>// tests/main_test.cpp  \n#define CATCH_CONFIG_MAIN  \n#include \"catch.hpp\"  \n</code></pre>"},{"location":"notes/semaine_4_3_tests_unitaires/#b-vos-fichiers-de-tests","title":"B. Vos fichiers de tests","text":"<p>Dans tous vos autres fichiers de tests (ex: <code>test_compte.cpp</code>), vous ne devez JAMAIS remettre le <code>#define CATCH_CONFIG_MAIN</code>. Contentez-vous d'inclure le header et d'\u00e9crire vos tests.  </p> <pre><code>// tests/test_compte.cpp  \n#include \"catch.hpp\"  \n#include \"CompteBancaire.hpp\"  \n\nTEST_CASE(\"Tests de la Classe CompteBancaire\", \"[compte]\") {  \n    CompteBancaire c(\"Simon\", 100.0);  \n    REQUIRE(c.getSolde() == 100.0);  \n}  \n</code></pre>"},{"location":"notes/semaine_4_3_tests_unitaires/#3-les-outils-indispensables","title":"3. Les outils indispensables","text":""},{"location":"notes/semaine_4_3_tests_unitaires/#a-require-lassertion-de-base","title":"A. REQUIRE (L'assertion de base)","text":"<p>V\u00e9rifie une condition. Si elle est fausse, le test s'arr\u00eate imm\u00e9diatement. <pre><code>TEST_CASE(\"Le solde initial est respect\u00e9\", \"[initialisation]\") {  \n    CompteBancaire c(\"Simon\", 100.0);  \n    REQUIRE(c.getSolde() == 100.0);  \n}  \n</code></pre></p>"},{"location":"notes/semaine_4_3_tests_unitaires/#b-info-le-message-personnalise","title":"B. INFO (Le message personnalis\u00e9)","text":"<p>Permet d'afficher un message d'explication uniquement si le test \u00e9choue. Tr\u00e8s utile pour le d\u00e9bogage. <pre><code>TEST_CASE(\"D\u00e9p\u00f4t de fonds\", \"[transaction]\") {  \n    CompteBancaire c(\"Simon\", 100.0);  \n    double montant = 50.0;  \n\n    c.deposer(montant);  \n\n    INFO(\"Le solde apr\u00e8s un d\u00e9p\u00f4t de \" &lt;&lt; montant &lt;&lt; \" devrait \u00eatre de 150.0\");  \n    REQUIRE(c.getSolde() == 150.0);  \n}  \n</code></pre></p>"},{"location":"notes/semaine_4_3_tests_unitaires/#c-gestion-des-exceptions-les-echecs-attendus","title":"C. Gestion des exceptions (Les \u00e9checs attendus)","text":"<p>Souvent, on veut tester que notre code bloque les mauvaises actions.  </p> <ul> <li><code>REQUIRE_THROWS</code> : V\u00e9rifie qu'une exception est lanc\u00e9e (peu importe laquelle).  </li> <li><code>REQUIRE_THROWS_AS</code> : V\u00e9rifie qu'une exception d'un type pr\u00e9cis est lanc\u00e9e (plus rigoureux).  </li> </ul> <pre><code>TEST_CASE(\"S\u00e9curit\u00e9 : Retrait sup\u00e9rieur au solde\", \"[securite]\") {  \n    CompteBancaire c(\"Simon\", 100.0);  \n\n    INFO(\"Tenter de retirer 200$ alors qu'on a 100$ doit lever une erreur\");  \n    REQUIRE_THROWS_AS(c.retirer(200.0), std::runtime_error);  \n}  \n\nTEST_CASE(\"S\u00e9curit\u00e9 : D\u00e9p\u00f4t n\u00e9gatif interdit\", \"[securite]\") {  \n    CompteBancaire c(\"Simon\", 100.0);  \n\n    // On s'assure qu'une exception est lanc\u00e9e, sans pr\u00e9ciser le type  \n    REQUIRE_THROWS(c.deposer(-50.0));  \n}  \n</code></pre>"},{"location":"notes/semaine_4_3_tests_unitaires/#4-exemple-recapitulatif-complet","title":"4. Exemple R\u00e9capitulatif Complet","text":"<p>Voici \u00e0 quoi devrait ressembler un fichier de tests professionnel et facile \u00e0 maintenir (exemple de <code>test_compte.cpp</code>) :  </p> <pre><code>#include \"catch.hpp\"  \n#include \"CompteBancaire.hpp\"  \n\nTEST_CASE(\"Initialisation du titulaire\", \"[unitaire][init]\") {  \n    CompteBancaire c(\"Alice\", 100.0);  \n    REQUIRE(c.getTitulaire() == \"Alice\");  \n}  \n\nTEST_CASE(\"Calcul du solde apr\u00e8s retrait\", \"[unitaire][calcul]\") {  \n    CompteBancaire c(\"Alice\", 100.0);  \n    c.retirer(30.0);  \n    REQUIRE(c.getSolde() == 70.0);  \n}  \n\nTEST_CASE(\"Erreur lors d'un solde initial n\u00e9gatif\", \"[unitaire][erreur]\") {  \n    INFO(\"Le constructeur doit emp\u00eacher la cr\u00e9ation d'un compte d\u00e9biteur\");  \n    REQUIRE_THROWS_AS(CompteBancaire(\"Bob\", -10.0), std::invalid_argument);  \n}  \n</code></pre>"},{"location":"notes/semaine_4_3_tests_unitaires/#5-pourquoi-cette-approche","title":"5. Pourquoi cette approche ?","text":"<ol> <li>Ind\u00e9pendance : Si le test du retrait \u00e9choue, vous savez que le probl\u00e8me vient de la m\u00e9thode <code>retirer()</code> et non du constructeur ou du d\u00e9p\u00f4t.  </li> <li>Rapidit\u00e9 : Vous pouvez lancer uniquement les tests d'erreurs avec la commande : <code>./tests_app [erreur]</code>.  </li> <li>Clart\u00e9 : Les titres des <code>TEST_CASE</code> servent de documentation pour votre code.  </li> </ol>"},{"location":"notes/semaine_4_4_tests_communs/","title":"Collaboration : Structure des Tests (3 Bo\u00eetes Isol\u00e9es)","text":"<p>Pour \u00e9viter que la compilation ne devienne complexe, on s\u00e9pare le projet en trois entit\u00e9s ind\u00e9pendantes. Chaque dossier poss\u00e8de son propre bouton \"D\u00e9marrer\" (le <code>main.cpp</code>) et ses propres biblioth\u00e8ques.</p>"},{"location":"notes/semaine_4_4_tests_communs/#1-organisation-des-fichiers-soutien-de-lautonomie","title":"1. Organisation des Fichiers (Soutien de l'Autonomie)","text":"<p>Chaque dossier de test est une bo\u00eete ferm\u00e9e qui contient son propre point d'entr\u00e9e et sa propre copie de Catch2.</p> <pre><code>Projet/\n\u251c\u2500\u2500 .git/               &lt;-- R\u00c9SERV\u00c9 \n\u251c\u2500\u2500 lib/                &lt;-- R\u00c9SERV\u00c9 (Vide pour le moment, pour futures libs globales)\n\u251c\u2500\u2500 include/            &lt;-- Pour les hpp\n\u251c\u2500\u2500 src/                &lt;-- Votre code m\u00e9tier + main.cpp  \n\u251c\u2500\u2500 tests/  \n\u2502   \u251c\u2500\u2500 lib/             &lt;-- Catch2 pour vos tests  \n\u2502   \u251c\u2500\u2500 main_test.cpp    &lt;-- Votre moteur de test  \n\u2502   \u251c\u2500\u2500 mon_test.cpp     &lt;-- Vos tests .cpp  \n\u2502   \u2514\u2500\u2500 test_commun/         &lt;-- BO\u00ceTE 2 : LE SOUS-MODULE (Groupe)  \n\u2502       \u251c\u2500\u2500 lib/             &lt;-- Catch2 interne au groupe  \n\u2502       \u251c\u2500\u2500 main_test.cpp    &lt;-- Moteur de test du groupe  \n\u2502       \u2514\u2500\u2500 tests_groupe.cpp &lt;-- Tests partag\u00e9s  \n\u251c\u2500\u2500 CMakeLists.txt\n\u2514\u2500\u2500 .gitmodules              &lt;-- Fichier pour les gitmodules\n</code></pre>"},{"location":"notes/semaine_4_4_tests_communs/#2-configuration-cmake-symetrie-totale","title":"2. Configuration CMake (Sym\u00e9trie Totale)","text":"<p>Le script <code>CMakeLists.txt</code> \u00e0 la racine orchestre les trois cibles de mani\u00e8re isol\u00e9e.</p> <pre><code>cmake_minimum_required(VERSION 3.10)\nproject(MonProjet)\n\nset(CMAKE_CXX_STANDARD 20)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\n# --- 1. LES SOURCES (La logique \u00e0 tester) ---\nfile(GLOB TOUT_SRC \"src/*.cpp\")\nset(SRC_FICHIERS ${TOUT_SRC})\nlist(REMOVE_ITEM SRC_FICHIERS \"${CMAKE_CURRENT_SOURCE_DIR}/src/main.cpp\")\n\n# --- 2. VOS TESTS (Bo\u00eete Priv\u00e9e) ---\nfile(GLOB TEST_PERSO_FICHIERS \"tests/test_personnel/*.cpp\")\n\n# --- 3. TESTS DU GROUPE (Bo\u00eete Commune) ---\nfile(GLOB TEST_COMMUN_FICHIERS \"tests/test_commun/*.cpp\")\n\n# --- CR\u00c9ATION DES EX\u00c9CUTABLES ---\n\n# A. L'Application normale (./app)\nadd_executable(app src/main.cpp ${SRC_FICHIERS})\ntarget_include_directories(app PRIVATE include)\n\n# B. Vos tests personnels (./test_perso)\nif(TEST_PERSO_FICHIERS)\n    add_executable(test_perso ${TEST_PERSO_FICHIERS} ${SRC_FICHIERS})\n    # On utilise le lib INTERNE au dossier personnel\n    target_include_directories(test_perso PRIVATE include tests/test_personnel/lib)\nelse()\n    message(WARNING \"Dossier 'test_personnel' vide.\")\nendif()\n\n# C. Les tests du groupe (./test_commun)\nif(TEST_COMMUN_FICHIERS)\n    add_executable(test_commun ${TEST_COMMUN_FICHIERS} ${SRC_FICHIERS})\n    # On utilise le lib INTERNE au sous-module\n    target_include_directories(test_commun PRIVATE include tests/test_commun/lib)\nelse()\n    message(WARNING \"Dossier 'test_commun' absent ou vide.\")\nendif()\n</code></pre>"},{"location":"notes/semaine_4_4_tests_communs/#3-pourquoi-cette-methode","title":"3. Pourquoi cette m\u00e9thode ?","text":"<ol> <li>Ind\u00e9pendance Totale : Le sous-module <code>test_commun</code> peut \u00eatre clon\u00e9 et test\u00e9 seul sur un autre ordinateur. Il n'a besoin de rien d'ext\u00e9rieur \u00e0 son propre dossier.</li> <li>Sym\u00e9trie et Clart\u00e9 : Vos tests personnels fonctionnent exactement comme ceux du groupe. Si vous savez g\u00e9rer l'un, vous savez g\u00e9rer l'autre.</li> <li>Le dossier <code>lib/</code> \u00e0 la racine : Pour le moment, ce dossier reste vide. Il servira plus tard dans la session si nous devons ajouter des biblioth\u00e8ques globales qui servent \u00e0 la fois \u00e0 l'application ET aux tests (comme une biblioth\u00e8que JSON ou de gestion r\u00e9seau).</li> </ol>"},{"location":"notes/semaine_4_4_tests_communs/#4-rappel-git-ajouter-le-sous-module","title":"4. Rappel Git : Ajouter le Sous-Module","text":"<pre><code>git submodule add &lt;URL_DU_DEPOT_DE_TESTS&gt; tests/test_commun\ngit submodule update --init --recursive\n</code></pre>"},{"location":"notes/semaine_4_4_tests_communs/#5-workflow-de-contribution-scenario","title":"5. Workflow de Contribution (Sc\u00e9nario)","text":"<p>\u26a0\ufe0f R\u00e8gle d'or : Le Contrat Social Puisque nous utilisons un d\u00e9p\u00f4t priv\u00e9 sans restrictions techniques de GitHub, rien ne vous emp\u00eache techniquement de pousser directement sur <code>main</code>.  Cependant, nous suivons un contrat social : tout changement doit passer par une branche et une Pull Request. C'est la seule fa\u00e7on d'apprendre le m\u00e9tier correctement et d'\u00e9viter de casser le code de vos coll\u00e8gues. Tout \"push\" direct sur main sera visible dans l'historique.</p>"},{"location":"notes/semaine_4_4_tests_communs/#etape-1-se-deplacer-dans-le-sous-module","title":"\u00c9tape 1 : Se d\u00e9placer dans le sous-module","text":"<p>Le dossier <code>test_commun</code> est un d\u00e9p\u00f4t Git ind\u00e9pendant. Vous devez \"entrer\" dedans pour utiliser Git sur ce d\u00e9p\u00f4t pr\u00e9cis. <pre><code>cd tests/test_commun\n</code></pre></p>"},{"location":"notes/semaine_4_4_tests_communs/#etape-2-creer-une-branche-de-contribution","title":"\u00c9tape 2 : Cr\u00e9er une branche de contribution","text":"<p>Ne travaillez jamais directement sur la branche principale (<code>main</code>). Cr\u00e9ez une branche avec votre nom et le sujet du test. <pre><code>git checkout -b ajout_test_validation_solde_simon\n</code></pre></p>"},{"location":"notes/semaine_4_4_tests_communs/#etape-3-ajouter-votre-test","title":"\u00c9tape 3 : Ajouter votre test","text":"<p>Copiez votre fichier <code>.cpp</code> (ou cr\u00e9ez-en un nouveau) dans ce dossier.  Rappel : V\u00e9rifiez que le test compile avec <code>./test_commun</code> avant de partager !</p>"},{"location":"notes/semaine_4_4_tests_communs/#etape-4-envoyer-votre-test-au-groupe","title":"\u00c9tape 4 : Envoyer votre test au groupe","text":"<pre><code>git add mon_nouveau_test.cpp\ngit commit -m \"Ajout du test de validation du solde\"\ngit push origin ajout_test_validation_solde_simon\n</code></pre>"},{"location":"notes/semaine_4_4_tests_communs/#etape-5-creer-la-pull-request-pr","title":"\u00c9tape 5 : Cr\u00e9er la Pull Request (PR)","text":"<p>Une fois votre branche envoy\u00e9e sur GitHub : 1.  Allez sur la page du d\u00e9p\u00f4t de tests communs. 2.  Un bandeau jaune devrait appara\u00eetre : \"Compare &amp; pull request\". Cliquez dessus. 3.  V\u00e9rifiez que la base est <code>main</code> et que votre branche est la source. 4.  \u00c9crivez un petit message expliquant ce que votre test v\u00e9rifie. 5.  Cliquez sur \"Create pull request\".</p>"},{"location":"notes/semaine_4_4_tests_communs/#etape-6-la-revue-et-lacceptation-merge","title":"\u00c9tape 6 : La revue et l'acceptation (Merge)","text":"<p>C'est ici que le groupe doit s'organiser. Pour accepter une Pull Request : 1.  Allez dans l'onglet \"Pull requests\" du d\u00e9p\u00f4t. 2.  Cliquez sur la PR \u00e0 r\u00e9viser. 3.  V\u00e9rifiez les changements dans l'onglet \"Files changed\". 4.  Si tout est correct, revenez \u00e0 l'onglet \"Conversation\" et cliquez sur le gros bouton vert \"Merge pull request\". 5.  Confirmez en cliquant sur \"Confirm merge\".</p> <p>Voici trois options de gestion pour votre groupe :</p> <ul> <li>Option A : La D\u00e9mocratie Ouverte     Tout le monde a le droit de fusionner sa propre branche dans <code>main</code>. C'est rapide, mais attention : un seul test qui ne compile pas bloque tout le groupe !</li> <li>Option B : Le Comit\u00e9 de Validation (Maintainers)     Vous \u00e9lisez 2 ou 3 \"gardiens du code\" qui sont les seuls autoris\u00e9s \u00e0 accepter les Pull Requests. Ils v\u00e9rifient que le code est propre et qu'il compile avant de l'ajouter au <code>main</code>.</li> <li>Option C : La Responsabilit\u00e9 Tournante     Chaque semaine, un \u00e9tudiant diff\u00e9rent est responsable du d\u00e9p\u00f4t de tests. C'est lui qui r\u00e9vise et fusionne les propositions de ses coll\u00e8gues.</li> </ul>"},{"location":"notes/semaine_4_4_tests_communs/#etape-7-revenir-a-votre-projet","title":"\u00c9tape 7 : Revenir \u00e0 votre projet","text":"<p>N'oubliez pas de ressortir du dossier pour revenir \u00e0 la racine de votre projet principal. <pre><code>cd ../..\n</code></pre></p>"},{"location":"notes/semaine_5_1_classes_encapsulation/","title":"Conception de Classes en C++","text":"<p>Ce guide explique comment transformer une structure de donn\u00e9es en une classe robuste en utilisant l'encapsulation (priv\u00e9/public), les accesseurs et les constructeurs.  </p>"},{"location":"notes/semaine_5_1_classes_encapsulation/#1-utilisation-de-stdchrono-c20","title":"1. Utilisation de <code>std::chrono</code> (C++20)","text":"<p>Depuis C++20, la biblioth\u00e8que <code>&lt;chrono&gt;</code> est devenue l'outil officiel pour g\u00e9rer les dates. Nous utiliserons <code>std::chrono::year_month_day</code>.  </p> <pre><code>#include &lt;chrono&gt;  \nusing namespace std::chrono;  \n\n// Exemple de cr\u00e9ation d'une date :  \n// year_month_day naissance = 1995y / August / 14d;  \n</code></pre>"},{"location":"notes/semaine_5_1_classes_encapsulation/#2-le-fichier-den-tete-clienthpp","title":"2. Le fichier d'en-t\u00eate (<code>Client.hpp</code>)","text":"<pre><code>#pragma once  \n\n#include &lt;string&gt;  \n#include &lt;chrono&gt;  \n\nclass Client {  \npublic:  \n    // 1. Constructeur param\u00e9tr\u00e9  \n    Client(std::string nom, std::string prenom, std::chrono::year_month_day naissance);  \n\n    // 2. Constructeur de copie  \n    // Essentiel pour garantir une duplication propre de l'objet  \n    Client(const Client&amp; autre);  \n\n    // 3. Destructeur  \n    // Appel\u00e9 automatiquement quand l'objet sort du scope  \n    ~Client();  \n\n    // 4. Accesseurs (Getters) - Toujours 'const' car ils ne modifient rien  \n    std::string getNom() const;  \n    std::string getPrenom() const;  \n    std::chrono::year_month_day getDateNaissance() const;  \n\n    // 5. Mutateurs (Setters) - Permettent de modifier avec contr\u00f4le  \n    void setNom(const std::string&amp; nom);  \n    void setPrenom(const std::string&amp; prenom);  \n\nprivate:  \n    // Les donn\u00e9es sont priv\u00e9es : personne ne peut les modifier par erreur  \n    std::string m_nom;  \n    std::string m_prenom;  \n    std::chrono::year_month_day m_dateNaissance;  \n};  \n</code></pre>"},{"location":"notes/semaine_5_1_classes_encapsulation/#3-limplementation-clientcpp","title":"3. L'impl\u00e9mentation (<code>Client.cpp</code>)","text":"<pre><code>#include \"Client.hpp\"  \n\n// On utilise std::chrono pour la clart\u00e9  \nusing namespace std::chrono;  \n\n// Constructeur : on initialise les membres via la liste d'initialisation (plus rapide)  \nClient::Client(std::string nom, std::string prenom, year_month_day naissance)  \n    : m_nom{nom}, m_prenom{prenom}, m_dateNaissance{naissance} {  \n}  \n\n// Constructeur de copie  \nClient::Client(const Client&amp; autre)  \n    : m_nom{autre.m_nom}, m_prenom{autre.m_prenom}, m_dateNaissance{autre.m_dateNaissance} {  \n}  \n\n// Destructeur (vide ici car std::string g\u00e8re sa propre m\u00e9moire)  \nClient::~Client() {  \n}  \n\n// Getters  \nstd::string Client::getNom() const { return m_nom; }  \nstd::string Client::getPrenom() const { return m_prenom; }  \nyear_month_day Client::getDateNaissance() const { return m_dateNaissance; }  \n\n// Setters  \nvoid Client::setNom(const std::string&amp; nom) { m_nom = nom; }  \nvoid Client::setPrenom(const std::string&amp; prenom) { m_prenom = prenom; }  \n</code></pre>"},{"location":"notes/semaine_5_1_classes_encapsulation/#4-concepts-cles-pour-les-etudiants","title":"4. Concepts cl\u00e9s pour les \u00e9tudiants","text":""},{"location":"notes/semaine_5_1_classes_encapsulation/#lencapsulation-prive-vs-public","title":"L'Encapsulation (Priv\u00e9 vs Public)","text":"<ul> <li><code>private</code> : C'est le coffre-fort. Seules les m\u00e9thodes de la classe peuvent toucher \u00e0 ces variables. Cela emp\u00eache un utilisateur de mettre un mois \u00e0 <code>99</code> ou une ann\u00e9e \u00e0 <code>-5</code>.  </li> <li><code>public</code> : C'est l'interface. Ce sont les boutons que l'utilisateur peut presser pour interagir avec l'objet.  </li> </ul>"},{"location":"notes/semaine_5_1_classes_encapsulation/#le-constructeur-de-copie","title":"Le Constructeur de Copie","text":"<p>En C++, quand vous passez un objet \u00e0 une fonction par valeur, le compilateur cr\u00e9e une copie. Le constructeur de copie d\u00e9finit comment cette copie doit \u00eatre faite. Pour des types simples ou <code>std::string</code>, le comportement par d\u00e9faut suffit, mais l'\u00e9crire explicitement est une excellente pratique d'apprentissage.  </p>"},{"location":"notes/semaine_5_1_classes_encapsulation/#le-destructeur","title":"Le Destructeur","text":"<p>C'est le \"m\u00e9nage\" automatique. D\u00e8s qu'une variable <code>Client</code> locale \u00e0 une fonction n'est plus utilis\u00e9e, le destructeur est appel\u00e9 pour lib\u00e9rer les ressources.  </p>"},{"location":"notes/semaine_5_1_classes_encapsulation/#5-exemple-dutilisation-maincpp","title":"5. Exemple d'utilisation (<code>main.cpp</code>)","text":"<p>Voici comment cr\u00e9er un client en utilisant la syntaxe moderne de C++20 pour les dates.  </p> <pre><code>#include \"Client.hpp\"  \n#include &lt;iostream&gt;  \n\nusing namespace std::chrono;  \n\nint main() {  \n    // Cr\u00e9ation d'une date avec les litt\u00e9raux (y pour year, d pour day)  \n    // Notez l'ordre tr\u00e8s lisible : Ann\u00e9e / Mois / Jour  \n    year_month_day dateNaissance = 2000y / March / 12d;  \n\n    // Instanciation du client  \n    Client nouveauClient{\"Gagnon\", \"Alexandre\", dateNaissance};  \n\n    // Affichage des informations  \n    std::cout &lt;&lt; \"Client cr\u00e9\u00e9 : \"  \n              &lt;&lt; nouveauClient.getPrenom() &lt;&lt; \" \"  \n              &lt;&lt; nouveauClient.getNom() &lt;&lt; std::endl;  \n\n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_5_1_classes_encapsulation/#6-saisie-utilisateur-vers-chrono","title":"6. Saisie utilisateur vers Chrono","text":"<p>Si vous devez demander une date \u00e0 l'utilisateur, vous r\u00e9cup\u00e9rez d'abord des entiers (<code>int</code>), puis vous les convertissez explicitement dans les types de <code>chrono</code>.  </p> <pre><code>int a, m, j;  \n\nstd::cout &lt;&lt; \"Annee de naissance : \";  \nstd::cin &gt;&gt; a; // Lecture de l'entier (ex: 1998)  \n\nstd::cout &lt;&lt; \"Mois (1-12) : \";  \nstd::cin &gt;&gt; m; // Lecture de l'entier (ex: 05)  \n\nstd::cout &lt;&lt; \"Jour (1-31) : \";  \nstd::cin &gt;&gt; j; // Lecture de l'entier (ex: 22)  \n\n// Transformation des entiers vers les types officiels de chrono  \n// On utilise le transtypage explicite : year(a), month(m), day(j)  \nyear_month_day dateSaisie { year{a}, month{static_cast&lt;unsigned&gt;(m)}, day{static_cast&lt;unsigned&gt;(j)} };  \n\n// On peut maintenant cr\u00e9er notre client  \nClient clientSaisi{\"Nom\", \"Prenom\", dateSaisie};  \n</code></pre>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/","title":"Les Tests Unitaires (Client) avec Catch2","text":"<p>Le test unitaire consiste \u00e0 v\u00e9rifier une seule \"unit\u00e9\" de code (g\u00e9n\u00e9ralement une m\u00e9thode ou une fonction) de mani\u00e8re isol\u00e9e.  </p>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#1-structure-dun-fichier-de-test","title":"1. Structure d'un fichier de test","text":"<p>Pour \u00e9viter les probl\u00e8mes de compilation et de collision de la fonction <code>main()</code>, nous s\u00e9parons les fichiers en deux types.  </p>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#a-le-porte-etendard-le-runner","title":"A. Le \"Porte-\u00c9tendard\" (Le Runner)","text":"<p>Ce fichier doit \u00eatre pr\u00e9sent une seule fois dans votre projet. Il s'occupe de compiler Catch2 et de g\u00e9n\u00e9rer la fonction <code>main()</code>. Cr\u00e9ez-le sous le nom <code>main_test.cpp</code>.  </p> <pre><code>// tests/main_test.cpp  \n#define CATCH_CONFIG_MAIN  \n#include \"catch.hpp\"  \n</code></pre>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#b-vos-fichiers-de-tests","title":"B. Vos fichiers de tests","text":"<p>Dans tous vos autres fichiers de tests (ex: <code>test_client.cpp</code>), vous ne devez JAMAIS remettre le <code>#define CATCH_CONFIG_MAIN</code>. Contentez-vous d'inclure le header et d'\u00e9crire vos tests.  </p> <pre><code>// tests/test_client.cpp  \n#include \"catch.hpp\"  \n#include \"Client.hpp\"  \n\nusing namespace std::chrono;  \n</code></pre>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#2-les-tests-de-base-require","title":"2. Les tests de base (REQUIRE)","text":"<p>On v\u00e9rifie que les informations pass\u00e9es au constructeur sont bien stock\u00e9es et r\u00e9cup\u00e9rables.  </p> <pre><code>TEST_CASE(\"Initialisation d'un client\", \"[client][init]\") {  \n    year_month_day date = 1990y / May / 15d;  \n    Client c(\"Tremblay\", \"Jean\", date);  \n\n    REQUIRE(c.getNom() == \"Tremblay\");  \n    REQUIRE(c.getPrenom() == \"Jean\");  \n    REQUIRE(c.getDateNaissance() == date);  \n}  \n</code></pre>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#3-tester-les-modifications-setters","title":"3. Tester les modifications (Setters)","text":"<p>On s'assure que changer une valeur fonctionne et n'affecte pas les autres membres.  </p> <pre><code>TEST_CASE(\"Modification du nom d'un client\", \"[client][mutation]\") {  \n    Client c(\"Tremblay\", \"Jean\", 1990y / May / 15d);  \n\n    c.setNom(\"Bouchard\");  \n\n    INFO(\"Le nom devrait \u00eatre Bouchard apr\u00e8s l'appel \u00e0 setNom\");  \n    REQUIRE(c.getNom() == \"Bouchard\");  \n    REQUIRE(c.getPrenom() == \"Jean\"); // On v\u00e9rifie que le pr\u00e9nom n'a pas boug\u00e9  \n}  \n</code></pre>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#4-tester-la-robustesse-exceptions","title":"4. Tester la robustesse (Exceptions)","text":"<p>Si nous ajoutons des validations (ex: pas de nom vide), nous devons tester que la classe r\u00e9agit correctement.  </p> <pre><code>// Imaginons que le constructeur doive lancer une erreur si le nom est vide  \nTEST_CASE(\"S\u00e9curit\u00e9 : Nom vide interdit\", \"[client][securite]\") {  \n    year_month_day date = 1990y / May / 15d;  \n\n    INFO(\"Le constructeur doit lancer une exception si le nom est vide\");  \n    REQUIRE_THROWS_AS(Client(\"\", \"Jean\", date), std::invalid_argument);  \n}  \n</code></pre>"},{"location":"notes/semaine_5_2_tests_unitaires_objet/#5-exemple-recapitulatif-complet","title":"5. Exemple R\u00e9capitulatif Complet","text":"<p>Exemple pour le fichier <code>test_client.cpp</code> :  </p> <pre><code>#include \"catch.hpp\"  \n#include \"Client.hpp\"  \n\nusing namespace std::chrono;  \n\nTEST_CASE(\"V\u00e9rification des informations de naissance\", \"[client][date]\") {  \n    year_month_day date = 1985y / December / 25d;  \n    Client c(\"Noel\", \"Papa\", date);  \n\n    REQUIRE(c.getDateNaissance().year() == 1985y);  \n    REQUIRE(c.getDateNaissance().month() == December);  \n    REQUIRE(c.getDateNaissance().day() == 25d);  \n}  \n\nTEST_CASE(\"Test du constructeur de copie\", \"[client][copie]\") {  \n    Client original(\"Dupont\", \"Marie\", 2000y / January / 1d);  \n    Client copie(original);  \n\n    REQUIRE(copie.getNom() == original.getNom());  \n    REQUIRE(copie.getPrenom() == original.getPrenom());  \n\n    // On modifie la copie pour s'assurer qu'elles sont ind\u00e9pendantes  \n    copie.setNom(\"Lavoie\");  \n    REQUIRE(copie.getNom() != original.getNom());  \n}  \n</code></pre>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/","title":"Les Fichiers Texte en C++","text":"<p>La manipulation de fichiers texte est essentielle pour la persistance de donn\u00e9es lisibles par l'humain.  </p>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/#1-flux-standards","title":"1. Flux Standards","text":"<p>En C++, on utilise la biblioth\u00e8que <code>&lt;fstream&gt;</code> : <code>std::ofstream</code> : Pour l'\u00e9criture (Output File Stream). <code>std::ifstream</code> : Pour la lecture (Input File Stream). *   <code>std::fstream</code> : Pour les deux.  </p>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/#2-encodage-et-unicode","title":"2. Encodage et Unicode","text":"<ul> <li>UTF-8 : C'est la norme moderne. En C++, un <code>std::string</code> peut stocker de l'UTF-8.  </li> <li>Affichage : Attention, la console Windows (cmd) n\u00e9cessite souvent une configuration sp\u00e9cifique (<code>chcp 65001</code>) pour afficher correctement les caract\u00e8res accentu\u00e9s.  </li> </ul>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/#3-portabilite-et-fins-de-ligne-r-n","title":"3. Portabilit\u00e9 et Fins de ligne (r, n)","text":"<p>Les syst\u00e8mes d'exploitation ne s'accordent pas sur la fa\u00e7on de marquer la fin d'une ligne.  </p> <ul> <li>LF (Line Feed) : <code>\\n</code>. Valeur ASCII 10 (0x0A). Utilis\u00e9 par Linux et macOS.  </li> <li>CR (Carriage Return) : <code>\\r</code>. Valeur ASCII 13 (0x0D). Utilis\u00e9 historiquement par les vieux Mac.  </li> <li>CRLF : <code>\\r\\n</code>. Suite des deux caract\u00e8res (13 puis 10). Utilis\u00e9 par Windows.  </li> </ul>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/#pourquoi-est-ce-important","title":"Pourquoi est-ce important ?","text":"<p>Si vous \u00e9crivez un fichier sur Windows et l'ouvrez sur Linux, certains \u00e9diteurs afficheront des caract\u00e8res <code>^M</code> \u00e0 la fin de chaque ligne (repr\u00e9sentant le <code>\\r</code>). Inversement, un fichier Linux ouvert dans de vieux outils Windows s'afficherait sur une seule ligne.  </p> <p>Le standard universel : Aujourd'hui, la majorit\u00e9 des outils (Git, VS Code, etc.) pr\u00e9f\u00e8rent le format LF (<code>\\n</code>) et l'encodage UTF-8.  </p>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/#4-encodage-stdstring-vs-stdwstring","title":"4. Encodage : std::string vs std::wstring","text":"<p>Pour qu'un fichier soit \"universel\", il doit utiliser un encodage compris par tous les syst\u00e8mes.  </p> <ul> <li>UTF-8 (Standard recommand\u00e9) :  <ul> <li>Utilise <code>std::string</code>.  </li> <li>Compatible avec l'ASCII (les 127 premiers caract\u00e8res sont identiques).  </li> <li>C'est le format universel du Web et de la majorit\u00e9 des syst\u00e8mes modernes.  </li> </ul> </li> <li>Gestion des caract\u00e8res sp\u00e9ciaux (\u00e9, \u00e8, \u00e0, Arabe, etc.) :  <ul> <li>En UTF-8, un caract\u00e8re peut occuper plus d'un octet dans un <code>std::string</code>. Par exemple, '\u00e9' occupe 2 octets, alors qu'un caract\u00e8re arabe comme '\u0634' peut en occuper 2 ou 3.  </li> <li>Attention : <code>maString.length()</code> renvoie le nombre d'octets, pas le nombre de caract\u00e8res visibles.  </li> <li>Le dilemme (La ch\u00e8vre et le chou) : Comment avoir l'universalit\u00e9 de l'UTF-8 tout en sachant combien il y a de caract\u00e8res ?  <ul> <li>En UTF-8, les octets de \"continuation\" commencent par les bits <code>10</code>. On peut donc compter uniquement les octets qui ne sont pas des continuations pour obtenir le nombre de points de code (caract\u00e8res). <pre><code>#include &lt;algorithm&gt;  \n\nsize_t compterCaracteres(const std::string&amp; s) {  \n    return std::count_if(s.begin(), s.end(), [](unsigned char c) {  \n        return (c &amp; 0xC0) != 0x80; // On ignore les octets de continuation  \n    });  \n}  \n</code></pre></li> </ul> </li> <li> <p>Biblioth\u00e8ques sp\u00e9cialis\u00e9es : Pour des projets plus complexes, on \u00e9vite de r\u00e9inventer la roue :  </p> <ul> <li>utf8cpp (GitHub : nemtrif/utfcpp) : Une biblioth\u00e8que l\u00e9g\u00e8re (header-only) tr\u00e8s populaire.  </li> </ul> <p>Exemple avec utf8cpp : <pre><code>#include \"utf8.h\"  \n#include &lt;string&gt;  \n#include &lt;iostream&gt;  \n\nvoid exempleUTF8() {  \n    std::string s = \"H\u00e9ll\u00f2 \u0634\"; // UTF-8  \n\n    // 1. Compter les vrais caract\u00e8res (distance)  \n    size_t nb = utf8::distance(s.begin(), s.end());  \n\n    // 2. V\u00e9rifier si la cha\u00eene est valide  \n    bool valide = utf8::is_valid(s.begin(), s.end());  \n\n    // 3. Parcourir les points de code  \n    auto it = s.begin();  \n    while (it != s.end()) {  \n        uint32_t cp = utf8::next(it, s.end());  \n        // cp contient la valeur num\u00e9rique du caract\u00e8re (ex: 0x00E9 pour '\u00e9')  \n    }  \n}  \n</code></pre> *   ICU : Le standard professionnel absolu, mais tr\u00e8s lourd \u00e0 int\u00e9grer.     *   Affichage Windows : Pour voir ces caract\u00e8res en console, il faut forcer l'encodage UTF-8 au d\u00e9but du programme : <pre><code>#ifdef _WIN32  \nsystem(\"chcp 65001 &gt; nul\"); // Force la console Windows en UTF-8  \n#endif  \n</code></pre> *   UTF-16 / wstring :     *   Utilise <code>std::wstring</code> et <code>wchar_t</code>.     *   Probl\u00e8me de portabilit\u00e9 : La taille de <code>wchar_t</code> change selon le syst\u00e8me (2 octets sur Windows, 4 octets sur Linux).     *   \u00c0 \u00e9viter pour le stockage de fichiers si vous visez l'interop\u00e9rabilit\u00e9.  </p> </li> </ul> </li> </ul> <p>Conseil : Utilisez toujours <code>std::string</code> avec de l'UTF-8 pour garantir que vos fichiers soient lisibles partout sans conversion complexe.  </p>"},{"location":"notes/semaine_6_1_fichiers_texte_utf8/#5-exemple-de-lecture-securisee","title":"5. Exemple de lecture s\u00e9curis\u00e9e","text":"<pre><code>#include &lt;iostream&gt;  \n#include &lt;fstream&gt;  \n#include &lt;string&gt;  \n\nvoid lireTexte(const std::string&amp; chemin) {  \n    std::ifstream fichier(chemin);  \n    if (fichier.is_open()) {  \n        std::string ligne;  \n        while (std::getline(fichier, ligne)) {  \n            std::cout &lt;&lt; ligne &lt;&lt; std::endl;  \n        }  \n    }  \n}  \n</code></pre>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/","title":"Les Fichiers Binaires et Structures","text":"<p>Le mode binaire permet de manipuler les donn\u00e9es exactement comme elles sont stock\u00e9es en m\u00e9moire, sans traduction de caract\u00e8res.  </p>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#1-ouverture-en-mode-binaire","title":"1. Ouverture en mode binaire","text":"<p>Il est crucial d'ajouter le flag <code>std::ios::binary</code> : <pre><code>std::ifstream fichier(\"donnees.bin\", std::ios::binary);  \n</code></pre></p>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#2-lecture-et-ecriture-brute","title":"2. Lecture et \u00c9criture brute","text":"<p>On utilise les m\u00e9thodes <code>.read()</code> et <code>.write()</code>. Ces fonctions attendent deux informations essentielles : 1.  L'adresse m\u00e9moire (le pointeur) o\u00f9 se trouvent les donn\u00e9es \u00e0 \u00e9crire (ou o\u00f9 stocker celles qu'on lit). 2.  La taille exacte (en octets) des informations \u00e0 traiter.  </p> <pre><code>int valeur = 42;  \n// On donne l'adresse de 'valeur' (&amp;valeur) et sa taille (sizeof)  \nfichier.write(reinterpret_cast&lt;char*&gt;(&amp;valeur), sizeof(valeur));  \n</code></pre>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#le-reinterpret_castchar","title":"Le <code>reinterpret_cast&lt;char*&gt;</code>","text":"<p>Les fonctions <code>.read()</code> et <code>.write()</code> ne comprennent que les tableaux d'octets (<code>char*</code>). <code>reinterpret_cast&lt;char*&gt;(&amp;maVariable)</code> est la fa\u00e7on moderne en C++ de dire au compilateur : \"Prend cette adresse m\u00e9moire et traite-la comme s'il s'agissait d'un simple pointeur d'octets\".    C'est l'\u00e9quivalent strict du cast \"\u00e0 la C\" : <code>(char*)&amp;maVariable</code>.  </p>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#3-alignement-memoire-et-pragma-pack","title":"3. Alignement m\u00e9moire et <code>#pragma pack</code>","text":"<p>Pour optimiser les performances, le processeur pr\u00e9f\u00e8re lire les donn\u00e9es par blocs align\u00e9s dans la m\u00e9moire vive (RAM). Le compilateur va donc souvent ajouter des octets vides (du padding, souvent des 0) entre les membres d'une structure pour qu'ils tombent \"juste\" sur les blocs de m\u00e9moire.  </p> <p>Le probl\u00e8me : Si vous lisez un fichier binaire structur\u00e9 (comme un BMP) directement dans une <code>struct</code> C++, les octets du fichier ne correspondront plus aux membres de votre structure \u00e0 cause de ces octets de padding ajout\u00e9s par surprise.  </p> <p>On utilise <code>#pragma pack(1)</code> pour dire au compilateur : \"N'ajoute aucun octet de remplissage, colle tout le monde ensemble\".  </p> <pre><code>#pragma pack(push, 1) // On force l'alignement sur 1 octet (pas de padding)  \nstruct MaDonnee {  \n    char id;      // 1 octet  \n    // Normalement, le compilateur ajouterait 3 octets de padding ici pour aligner l'int suivant  \n    int valeur;   // 4 octets  \n};  \n#pragma pack(pop) // On r\u00e9tablit l'alignement standard pour le reste du code  \n</code></pre>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#4-lecture-directe-dans-une-struct","title":"4. Lecture directe dans une struct","text":"<pre><code>MaDonnee d;  \nfichier.read(reinterpret_cast&lt;char*&gt;(&amp;d), sizeof(MaDonnee));  \n</code></pre>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#5-le-piege-de-stdstring-et-des-pointeurs","title":"5. Le pi\u00e8ge de <code>std::string</code> et des pointeurs","text":"<p>ATTENTION : On ne peut pas lire/\u00e9crire directement une structure qui contient une <code>std::string</code> ou un pointeur (ex: <code>int*</code>).  </p>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#pourquoi","title":"Pourquoi ?","text":"<ul> <li>Une <code>std::string</code> n'est pas \"dans\" la structure. Elle contient un pointeur vers une autre zone de la RAM (le tas). Si vous \u00e9crivez la structure, vous enregistrez une adresse m\u00e9moire qui sera invalide la prochaine fois que vous ouvrirez le programme.  </li> <li>Le compilateur ne conna\u00eet pas la taille du texte \u00e0 l'avance.  </li> </ul>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#les-solutions","title":"Les solutions","text":"<ol> <li>Taille fixe (Le plus simple en binaire) : Utilisez un tableau de caract\u00e8res brut. <pre><code>struct Joueur {  \n    char nom[50]; // Toujours 50 octets dans le fichier  \n    int score;  \n};  \n</code></pre></li> <li>S\u00e9rialisation manuelle :  <ul> <li>\u00c9crire la taille de la string (ex: un <code>uint32_t</code>).  </li> <li>\u00c9crire le contenu de la string via <code>.data()</code>.  </li> <li>\u00c0 la lecture : lire la taille, pr\u00e9parer la string avec <code>.resize()</code>, puis lire les caract\u00e8res dedans.  </li> <li>Note : Cette m\u00e9thode emp\u00eache de lire toute la structure d'un seul bloc. </li> </ul> </li> </ol>"},{"location":"notes/semaine_6_2_fichiers_binaires_padding/#exemple-de-serialisation-manuelle-dune-string","title":"Exemple de s\u00e9rialisation manuelle d'une string","text":"<pre><code>// --- \u00c9CRITURE ---  \nstd::string message = \"Bonjour les \u00e9tudiants !\";  \nuint32_t taille = static_cast&lt;uint32_t&gt;(message.length());  \n\n// 1. On \u00e9crit la taille  \nfichier.write(reinterpret_cast&lt;char*&gt;(&amp;taille), sizeof(taille));  \n// 2. On \u00e9crit les caract\u00e8res (sans le \\0 final, inutile en binaire)  \nfichier.write(message.data(), taille);  \n\n// --- LECTURE ---  \nuint32_t tailleLue;  \n// 1. On lit d'abord la taille pour savoir combien d'octets arrivent  \nfichier.read(reinterpret_cast&lt;char*&gt;(&amp;tailleLue), sizeof(tailleLue));  \n\n// 2. On pr\u00e9pare une string de la bonne dimension  \nstd::string messageLu;  \nmessageLu.resize(tailleLue);  \n\n// 3. On lit les caract\u00e8res directement dans la m\u00e9moire de la string  \nfichier.read(messageLu.data(), tailleLue);  \n</code></pre>"},{"location":"notes/semaine_7_1_bmp_structure/","title":"Format BMP : Les Ent\u00eates","text":"<p>Une image BMP commence par deux structures d'ent\u00eates cruciales qui d\u00e9finissent le format et les dimensions.  </p>"},{"location":"notes/semaine_7_1_bmp_structure/#1-le-file-header-14-octets","title":"1. Le File Header (14 octets)","text":"<p>Il contient les informations g\u00e9n\u00e9rales sur le fichier. <pre><code>#pragma pack(push, 1)  \nstruct BMPFileHeader {  \n    uint16_t file_type{0x4D42}; // Signature : Toujours \"BM\" (0x4D42 en petit boutiste)  \n    uint32_t file_size{0};      // Taille totale du fichier en octets  \n    uint16_t reserved1{0};      // Inutilis\u00e9 (0)  \n    uint16_t reserved2{0};      // Inutilis\u00e9 (0)  \n    uint32_t offset_data{0};    // Adresse o\u00f9 commencent les pixels (souvent 54)  \n};  \n#pragma pack(pop)  \n</code></pre></p>"},{"location":"notes/semaine_7_1_bmp_structure/#2-le-dib-header-40-octets-version-courante","title":"2. Le DIB Header (40 octets - version courante)","text":"<p>Il contient les d\u00e9tails techniques de l'image (Bitmap Info Header). <pre><code>#pragma pack(push, 1)  \nstruct BMPInfoHeader {  \n    uint32_t size{40};          // Taille de cette structure (toujours 40)  \n    int32_t  width{0};          // Largeur de l'image en pixels  \n    int32_t  height{0};         // Hauteur de l'image en pixels  \n    uint16_t planes{1};         // Toujours 1  \n    uint16_t bit_count{0};      // 24 pour BGR (3 octets/pixel), 32 pour BGRA  \n    uint32_t compression{0};    // 0 pour aucune compression (BI_RGB)  \n    uint32_t size_image{0};     // Taille des pixels seuls (avec le padding)  \n    int32_t  x_pixels_per_meter{0};  \n    int32_t  y_pixels_per_meter{0};  \n    uint32_t colors_used{0};  \n    uint32_t colors_important{0};  \n};  \n#pragma pack(pop)  \n</code></pre></p>"},{"location":"notes/semaine_7_1_bmp_structure/#3-exemple-concret-image-100x100-pixels-24-bit","title":"3. Exemple concret : Image 100x100 pixels (24-bit)","text":"<p>Voici les valeurs que vous trouveriez dans les structures pour une image simple de 100x100 pixels sans compression :  </p> Champ Valeur Explication file_type <code>0x4D42</code> Correspond aux caract\u00e8res ASCII 'B' et 'M'. file_size <code>30054</code> 14 (FileHeader) + 40 (InfoHeader) + 30 000 (Pixels). offset_data <code>54</code> Les pixels commencent juste apr\u00e8s les 54 octets d'ent\u00eates. width <code>100</code> Largeur en pixels. height <code>100</code> Hauteur en pixels. bit_count <code>24</code> 3 octets par pixel (Bleu, Vert, Rouge). size_image <code>30000</code> 100 pixels * 100 pixels * 3 octets = 30 000."},{"location":"notes/semaine_7_1_bmp_structure/#pourquoi-54-octets-pour-loffset","title":"Pourquoi 54 octets pour l'offset ?","text":"<p>Le chiffre 54 vient de l'addition des deux structures d'ent\u00eate obligatoires : <code>BMPFileHeader</code> : 14 octets <code>BMPInfoHeader</code> : 40 octets Total : 54 octets*  </p> <p>Attention : Bien que 54 soit la valeur la plus courante, il ne faut jamais l'utiliser \"en dur\" (hardcoded) dans votre code. Utilisez toujours la variable <code>offset_data</code> lue dans le fichier. Certains fichiers BMP plus complexes (avec une palette de couleurs ou des m\u00e9tadonn\u00e9es suppl\u00e9mentaires) peuvent avoir un offset beaucoup plus grand.  </p> <p>Note sur la lecture hexad\u00e9cimale : Si vous ouvrez le fichier dans un \u00e9diteur hexad\u00e9cimal, les premiers octets seront : <code>42 4D</code> (BM), suivis de la taille du fichier en petit boutiste (Little Endian).  </p>"},{"location":"notes/semaine_7_1_bmp_structure/#4-fonctions-de-lecture","title":"4. Fonctions de lecture","text":"<p>L'objectif est de cr\u00e9er des fonctions modulaires : <code>void lireFileHeader(std::ifstream&amp; f, BMPFileHeader&amp; h);</code> <code>void lireInfoHeader(std::ifstream&amp; f, BMPInfoHeader&amp; h);</code> </p>"},{"location":"notes/semaine_7_2_bmp_pixels_padding/","title":"Format BMP : Pixels et Padding","text":"<p>Apr\u00e8s les ent\u00eates, on retrouve les donn\u00e9es brutes des couleurs.  </p>"},{"location":"notes/semaine_7_2_bmp_pixels_padding/#1-organisation-bgr","title":"1. Organisation BGR","text":"<p>Contrairement au format RGB habituel, le BMP stocke les couleurs dans l'ordre Blue, Green, Red.    Pour 24 bits : 3 octets par pixel (B, G, R).    Pour 32 bits : 4 octets par pixel (B, G, R, Alpha).  </p>"},{"location":"notes/semaine_7_2_bmp_pixels_padding/#2-le-concept-de-padding","title":"2. Le concept de Padding","text":"<p>Dans un BMP, chaque ligne de pixels doit \u00eatre un multiple de 4 octets. Si la largeur de l'image ne remplit pas cette condition, on ajoute des octets vides (padding) \u00e0 la fin de chaque ligne.  </p>"},{"location":"notes/semaine_7_2_bmp_pixels_padding/#pourquoi-cette-formule-4-width-3-4-4","title":"Pourquoi cette formule ? <code>(4 - (width * 3) % 4) % 4</code>","text":"<p>L'objectif est de trouver combien d'octets il manque pour atteindre le prochain multiple de 4.  </p> <ol> <li><code>width * 3</code> : C'est le nombre d'octets \"utiles\" par ligne (pour du 24 bits). (Bleu, vert et rouge)  </li> <li><code>(...) % 4</code> : Le modulo 4 nous donne le \"reste\". Si une ligne fait 10 pixels (30 octets), <code>30 % 4 = 2</code>. Il y a 2 octets qui d\u00e9passent du dernier bloc de 4.  </li> <li><code>4 - (...)</code> : On calcule combien d'octets ajouter pour compl\u00e9ter le bloc. <code>4 - 2 = 2</code>. Il nous manque 2 octets de padding.  </li> <li>Le dernier <code>% 4</code> : C'est l'astuce math\u00e9matique pour le cas o\u00f9 la ligne est d\u00e9j\u00e0 parfaite. Si <code>width * 3</code> est 12, alors <code>12 % 4 = 0</code>. Sans ce dernier modulo, on ferait <code>4 - 0 = 4</code> octets de padding (ce qui est faux). Avec le <code>% 4</code>, on obtient bien <code>4 % 4 = 0</code>.  </li> </ol>"},{"location":"notes/semaine_7_2_bmp_pixels_padding/#3-le-format-32-bits-bgra-lalignement-gratuit","title":"3. Le format 32 bits (BGRA) : L'alignement \"gratuit\"","text":"<p>Une question fr\u00e9quente des \u00e9tudiants est : \"Pourquoi ne pas toujours utiliser le 32 bits ?\".  </p> <p>En 32 bits (4 octets par pixel : Bleu, Vert, Rouge, Alpha), chaque pixel tombe d\u00e9j\u00e0 sur une fronti\u00e8re de 4 octets. Calcul : <code>width * 4</code> sera toujours un multiple de 4. R\u00e9sultat : Le padding est toujours de 0 octet.  </p> <p>Cela simplifie \u00e9norm\u00e9ment le code de lecture (on lit tout d'un coup sans <code>seekg</code>), mais le fichier p\u00e8se 25% plus lourd sur le disque.  </p>"},{"location":"notes/semaine_7_2_bmp_pixels_padding/#4-lecture-des-pixels-24-bits","title":"4. Lecture des pixels (24 bits)","text":"<p>La lecture doit tenir compte du padding : 1. Lire 3 octets (un pixel). 2. R\u00e9p\u00e9ter pour toute la largeur. 3. Sauter les octets de padding \u00e0 la fin de la ligne avec <code>f.seekg(padding, std::ios::cur)</code>. 4. Passer \u00e0 la ligne suivante.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/","title":"Communication R\u00e9seau : TCP (Texte)","text":"<p>La communication par r\u00e9seau (Sockets/TCP) peut \u00eatre vue comme un fichier que l'on lit et \u00e9crit en temps r\u00e9el entre deux machines.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#1-concepts-de-base","title":"1. Concepts de base","text":"<ul> <li>Adresse IP : L'adresse de la \"maison\" (ex: <code>127.0.0.1</code> pour soi-m\u00eame).  </li> <li>Port : La \"porte\" d'entr\u00e9e sp\u00e9cifique \u00e0 l'application (ex: <code>8080</code>).  </li> <li>Socket : Le point de connexion (le \"tuyau\") entre le client et le serveur.  </li> </ul>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#2-analogie-avec-les-fichiers","title":"2. Analogie avec les fichiers","text":"Action Fichier R\u00e9seau (TCP) Ouverture <code>fstream.open()</code> <code>socket.connect()</code> / <code>accept()</code> \u00c9criture <code>file &lt;&lt; \"Salut\"</code> <code>send(socket, \"Salut\")</code> Lecture <code>getline(file, s)</code> <code>recv(socket, buffer)</code> Fermeture <code>file.close()</code> <code>socket.close()</code>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#3-lecture-et-ecriture-de-texte","title":"3. Lecture et \u00c9criture de Texte","text":"<p>Contrairement \u00e0 un fichier qui a une fin (EOF), une connexion r\u00e9seau reste ouverte. Il faut donc une convention pour savoir quand s'arr\u00eater de lire.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#a-le-delimiteur-standard-n","title":"A. Le d\u00e9limiteur standard : <code>\\n</code>","text":"<p>C'est la m\u00e9thode la plus simple et la plus universelle. On choisit g\u00e9n\u00e9ralement le caract\u00e8re <code>\\n</code> (ASCII 10). Pourquoi ? Parce que cela permet de traiter le flux r\u00e9seau comme une succession de lignes. Alternative : Certains protocoles utilisent <code>\\r\\n</code> (CRLF) ou l'octet nul <code>\\0</code>.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#b-le-probleme-du-decoupage-fragmentation","title":"B. Le probl\u00e8me du \"D\u00e9coupage\" (Fragmentation)","text":"<p>C'est le pi\u00e8ge num\u00e9ro 1 pour les \u00e9tudiants. En TCP, si vous envoyez \"Bonjourn\", le destinataire pourrait recevoir <code>\"Bon\"</code> au premier appel de <code>receive()</code>, puis <code>\"jour\\n\"</code> au second.  </p> <p>La solution technique : Il faut cr\u00e9er un m\u00e9canisme qui accumule les donn\u00e9es dans un tampon (<code>std::string</code>) jusqu'\u00e0 ce qu'un <code>\\n</code> soit d\u00e9tect\u00e9.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#4-les-paquets-sfml-une-alternative-plus-simple","title":"4. Les Paquets SFML (Une alternative plus simple)","text":"<p>SFML propose une classe <code>sf::Packet</code> qui r\u00e8gle ce probl\u00e8me automatiquement en g\u00e9rant elle-m\u00eame la taille des messages. C'est id\u00e9al entre deux programmes SFML, mais incompatible si vous communiquez avec un programme externe (ex: un serveur Web ou une application Python) qui attend du texte brut.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#5-bibliotheques-suggerees","title":"5. Biblioth\u00e8ques sugg\u00e9r\u00e9es","text":"<p>Le C++ standard n'a pas encore de biblioth\u00e8que r\u00e9seau native simple (en attente de standardisation). SFML-network : La plus simple pour d\u00e9buter (orient\u00e9e objet, tr\u00e8s proche des fichiers). Asio (ou Boost.Asio) : Le standard de l'industrie, puissant mais complexe. Sockets Berkeley / WinSock* : L'API syst\u00e8me (C). Difficile car tr\u00e8s bas niveau, mais permet de comprendre comment l'OS g\u00e8re le r\u00e9seau.  </p>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#5-exemple-avec-sfml-network","title":"5. Exemple avec SFML-Network","text":""},{"location":"notes/semaine_8_1_reseau_tcp_texte/#cote-serveur-ecoute-et-repond","title":"C\u00f4t\u00e9 Serveur (\u00c9coute et r\u00e9pond)","text":"<pre><code>#include &lt;SFML/Network.hpp&gt;  \n#include &lt;iostream&gt;  \n#include &lt;string&gt;  \n\nint main() {  \n    sf::TcpListener listener;  \n    // On \u00e9coute sur le port 53000  \n    if (listener.listen(53000) != sf::Socket::Done) return -1;  \n\n    sf::TcpSocket client;  \n    if (listener.accept(client) != sf::Socket::Done) return -1;  \n\n    std::cout &lt;&lt; \"Client connect\u00e9 : \" &lt;&lt; client.getRemoteAddress() &lt;&lt; std::endl;  \n\n    // R\u00e9ception d'un message  \n    char buffer[100];  \n    std::size_t received;  \n    if (client.receive(buffer, 100, received) == sf::Socket::Done) {  \n        std::cout &lt;&lt; \"Message re\u00e7u : \" &lt;&lt; buffer &lt;&lt; std::endl;  \n    }  \n\n    // Envoi d'une r\u00e9ponse  \n    std::string reponse = \"Bien re\u00e7u !\\n\";  \n    client.send(reponse.c_str(), reponse.size());  \n\n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#cote-client-se-connecte-et-envoie","title":"C\u00f4t\u00e9 Client (Se connecte et envoie)","text":"<pre><code>#include &lt;SFML/Network.hpp&gt;  \n#include &lt;iostream&gt;  \n\nint main() {  \n    sf::TcpSocket socket;  \n    // On se connecte au serveur sur la m\u00eame machine  \n    sf::Socket::Status status = socket.connect(\"127.0.0.1\", 53000);  \n    if (status != sf::Socket::Done) return -1;  \n\n    // Envoi de texte  \n    std::string message = \"Salut serveur !\";  \n    socket.send(message.c_str(), message.size());  \n\n    return 0;  \n}  \n</code></pre>"},{"location":"notes/semaine_8_1_reseau_tcp_texte/#6-exemple-de-protocole-simple-client-serveur","title":"6. Exemple de protocole simple (Client-Serveur)","text":"<ol> <li>Client : Envoie une commande (ex: <code>GET_TIME</code>).  </li> <li>Serveur : Re\u00e7oit la ligne, l'analyse, et renvoie la r\u00e9ponse termin\u00e9e par un <code></code>.  </li> <li>Client : Lit jusqu'au <code></code> pour obtenir sa r\u00e9ponse.  </li> </ol>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/","title":"Communication R\u00e9seau : TCP (Binaire)","text":"<p>Envoyer des donn\u00e9es binaires (comme une structure) est beaucoup plus efficace que le texte, mais demande de la rigueur sur l'organisation de la m\u00e9moire.  </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#1-definition-de-la-structure","title":"1. D\u00e9finition de la structure","text":"<p>Comme pour les fichiers BMP, on doit s'assurer que le compilateur n'ajoute pas de padding et que les cha\u00eenes de caract\u00e8res ont une taille fixe.  </p> <pre><code>#include &lt;cstdint&gt;  \n\n#pragma pack(push, 1)  \nstruct ClientData {  \n    char nom[50];          // Taille fixe pour le binaire  \n    char prenom[50];  \n    int32_t anneeNaissance;  \n    int32_t moisNaissance;  \n    int32_t jourNaissance;  \n};  \n#pragma pack(pop)  \n</code></pre>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#2-pourquoi-des-tableaux-char50","title":"2. Pourquoi des tableaux <code>char[50]</code> ?","text":"<p>Comme vu dans les notes sur les fichiers binaires, on ne peut pas envoyer une <code>std::string</code> directement car elle contient un pointeur vers la RAM. En utilisant <code>char[50]</code>, les caract\u00e8res sont stock\u00e9s directement \u00e0 l'int\u00e9rieur de la structure.  </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#3-exemple-avec-sfml-network","title":"3. Exemple avec SFML-Network","text":""},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#cote-client-envoi","title":"C\u00f4t\u00e9 Client (Envoi)","text":"<pre><code>// M\u00e9thode moderne et propre (Initialisation par accolades)  \nClientData donnee = {\"Dupont\", \"Jean\", 1995, 2, 14};  \n\n// OU si la structure existe d\u00e9j\u00e0, on utilise strcpy :  \n// strcpy(donnee.nom, \"Dupont\");  \n\nsf::TcpSocket socket;  \nsocket.connect(\"127.0.0.1\", 53000);  \n\n// On envoie la structure brute (cast\u00e9e en char*)  \nsocket.send(&amp;donnee, sizeof(ClientData));  \n</code></pre>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#cote-serveur-reception","title":"C\u00f4t\u00e9 Serveur (R\u00e9ception)","text":"<pre><code>sf::TcpListener listener;  \nlistener.listen(53000);  \n\nsf::TcpSocket client;  \nlistener.accept(client);  \n\nClientData donneeRecue;  \nstd::size_t nbOctetsRecus;  \n\n// On lit directement dans la structure  \nif (client.receive(&amp;donneeRecue, sizeof(ClientData), nbOctetsRecus) == sf::Socket::Done) {  \n    // V\u00c9RIFICATION :  \n    if (nbOctetsRecus &lt; sizeof(ClientData)) {  \n        std::cout &lt;&lt; \"Attention : Donn\u00e9es incompl\u00e8tes !\" &lt;&lt; std::endl;  \n    } else {  \n        std::cout &lt;&lt; \"Client : \" &lt;&lt; donneeRecue.prenom &lt;&lt; \" \" &lt;&lt; donneeRecue.nom &lt;&lt; std::endl;  \n    }  \n}  \n</code></pre>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#a-quoi-sert-le-parametre-nboctetsrecus","title":"\u00c0 quoi sert le param\u00e8tre <code>nbOctetsRecus</code> ?","text":"<p>C'est une variable remplie par SFML qui vous indique le nombre r\u00e9el d'octets qui viennent d'arriver. Attention : <code>sf::Socket::Done</code> signifie que l'appel a r\u00e9ussi, mais pas forc\u00e9ment* que toutes les donn\u00e9es demand\u00e9es sont arriv\u00e9es. Le r\u00e9seau peut livrer une structure de 100 octets en plusieurs morceaux.  </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#gerer-les-lectures-partielles-encapsulation","title":"G\u00e9rer les lectures partielles (Encapsulation)","text":"<p>Dans un programme professionnel, on isole cette logique dans une fonction d\u00e9di\u00e9e :  </p> <p><pre><code>ClientData recevoirClient(sf::TcpSocket&amp; socket) {  \n    ClientData structure_client;  \n    std::size_t totalRecu = 0;  \n    std::size_t tailleCible = sizeof(ClientData);  \n\n    while (totalRecu &lt; tailleCible) {  \n        std::size_t nbLusCetteFois;  \n\n        // 1. Calculer o\u00f9 \u00e9crire  \n        char* destination = (char*)&amp;structure_client + totalRecu;  \n\n        // 2. Calculer le reste \u00e0 recevoir  \n        std::size_t reste = tailleCible - totalRecu;  \n\n        // 3. R\u00e9ception  \n        sf::Socket::Status etat = socket.receive(destination, reste, nbLusCetteFois);  \n\n        // 4. Gestion des anomalies  \n        if (etat == sf::Socket::Disconnected) {  \n            throw std::runtime_error(\"D\u00e9connexion brutale pendant la r\u00e9ception.\");  \n        } else if (etat == sf::Socket::Error) {  \n            throw std::runtime_error(\"Erreur r\u00e9seau technique.\");  \n        }  \n\n        totalRecu += nbLusCetteFois;  \n    }  \n\n    // Le contrat est rempli : on a re\u00e7u 100% des octets attendus  \n    return structure_client;  \n}  \n</code></pre> Note : L'utilisation d'exceptions permet d'arr\u00eater proprement le traitement si le \"tuyau\" r\u00e9seau est coup\u00e9. </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#pourquoi-utiliser-une-exception-ici","title":"Pourquoi utiliser une exception ici ?","text":"<p>On applique le principe du \"Tout ou rien\" :    Une structure binaire est un contrat. Si vous attendez un <code>ClientData</code>, vous avez besoin de chaque octet pour que l'objet soit valide. Le danger du retour partiel : Si vous retournez la structure alors qu'elle n'est qu'\u00e0 moiti\u00e9 remplie, le reste contient des donn\u00e9es al\u00e9atoires (d\u00e9chets de la RAM). Utiliser ces donn\u00e9es provoquera des bugs impr\u00e9visibles. L'avantage de l'exception : Elle garantit que si le code continue apr\u00e8s la boucle, c'est que les donn\u00e9es sont 100% compl\u00e8tes et fiables*.  </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#4-points-de-vigilance","title":"4. Points de vigilance","text":""},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#1-lendianness-lordre-des-octets","title":"1. L'Endianness (L'ordre des octets)","text":"<p>C'est la fa\u00e7on dont le processeur range les octets d'un nombre (comme un <code>int</code>) dans la RAM.  </p> <p>Imaginez le nombre hexad\u00e9cimal <code>0x12345678</code> (4 octets) :  </p> <ul> <li>Grand-boutiste (Big-endian) : On \u00e9crit dans l'ordre de lecture habituel.  <ul> <li>M\u00e9moire : <code>[12][34][56][78]</code> </li> <li>C'est l'ordre utilis\u00e9 par le r\u00e9seau (\"Network Byte Order\").  </li> </ul> </li> <li>Petit-boutiste (Little-endian) : On met le \"petit bout\" (l'unit\u00e9) en premier.  <ul> <li>M\u00e9moire : <code>[78][56][34][12]</code> </li> <li>C'est l'ordre utilis\u00e9 par la quasi-totalit\u00e9 de nos PC actuels (Intel/AMD).  </li> </ul> </li> </ul> <p>Le saviez-vous ? M\u00eame les nouveaux Mac (puces M1/M2/M3) utilisent le Petit-boutiste. Bien que leur architecture (ARM) soit capable de g\u00e9rer les deux modes, Apple a choisi de rester en Petit-boutiste pour assurer une compatibilit\u00e9 parfaite avec les programmes PC et les anciens Mac Intel.  </p> <p>Le danger : Si un PC (petit-boutiste) envoie un <code>int</code> \u00e0 un serveur (grand-boutiste), le nombre sera totalement invers\u00e9 \u00e0 l'arriv\u00e9e ! Note : Pour ce cours, on travaille souvent entre PC, donc tout le monde est en Petit-boutiste. </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#2-taille-du-message","title":"2. Taille du message","text":"<p>On doit savoir exactement combien d'octets lire ou utiliser un d\u00e9limiteur.  </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#3-evolution","title":"3. \u00c9volution","text":"<p>Si vous changez la <code>struct</code>, recompilez les deux programmes.  </p>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#5-serialisation-manuelle-taille-dynamique","title":"5. S\u00e9rialisation manuelle (Taille dynamique)","text":"<p>Si vous voulez \u00e9viter les tableaux de taille fixe pour optimiser la bande passante.  </p> <pre><code>// --- C\u00d4T\u00c9 CLIENT (\u00c9CRITURE) ---  \nstd::string message = \"Texte dynamique\";  \nuint32_t taille = static_cast&lt;uint32_t&gt;(message.size());  \nsocket.send(&amp;taille, sizeof(taille)); // 1. Envoi taille  \nsocket.send(message.c_str(), taille);  // 2. Envoi contenu  \n\n// --- C\u00d4T\u00c9 SERVEUR (LECTURE) ---  \nuint32_t tailleRecue;  \nstd::size_t nbOctets;  \nif (socket.receive(&amp;tailleRecue, sizeof(tailleRecue), nbOctets) == sf::Socket::Done) {  \n    std::string messageRecu;  \n    messageRecu.resize(tailleRecue);  \n    socket.receive(&amp;messageRecu[0], tailleRecue, nbOctets);  \n    std::cout &lt;&lt; \"Re\u00e7u : \" &lt;&lt; messageRecu &lt;&lt; std::endl;  \n}  \n</code></pre>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#pourquoi-3-parametres-dans-receive","title":"Pourquoi 3 param\u00e8tres dans <code>receive</code> ?","text":"<ol> <li>Le pointeur (<code>&amp;variable</code>) : O\u00f9 poser le colis.  </li> <li>La taille (<code>sizeof</code>) : Taille de la bo\u00eete aux lettres.  </li> <li>La variable (<code>nbOctetsRecus</code>) : Le bon de livraison (rempli par la fonction).  </li> </ol>"},{"location":"notes/semaine_8_2_reseau_tcp_binaire/#comparaison-des-approches","title":"Comparaison des approches","text":"M\u00e9thode Avantages Inconv\u00e9nients Structure fixe Simple, lecture en 1 bloc. Gaspille de l'espace. S\u00e9rialisation Optimise la bande passante. Code plus complexe."},{"location":"notes/semaine_9_1_generique/","title":"Guide C++ : G\u00e9n\u00e9ricit\u00e9 (Templates) et Collections","text":"<p>La g\u00e9n\u00e9ricit\u00e9 (templates) permet de cr\u00e9er du code qui fonctionne avec n'importe quel type de donn\u00e9e (int, std::string, objets personnalis\u00e9s). Ce guide documente l'\u00e9volution de l'architecture des fichiers et la gestion de la m\u00e9moire pour ces classes g\u00e9n\u00e9riques.</p>"},{"location":"notes/semaine_9_1_generique/#1-evolution-de-larchitecture-des-fichiers-templates","title":"1. \u00c9volution de l'Architecture des Fichiers Templates","text":"<p>Historiquement, la s\u00e9paration classique d\u00e9claration/impl\u00e9mentation pose probl\u00e8me avec les templates. Le compilateur a besoin de voir l'impl\u00e9mentation compl\u00e8te pour g\u00e9n\u00e9rer le code du type demand\u00e9.</p>"},{"location":"notes/semaine_9_1_generique/#lerreur-classique-hpp-et-cpp","title":"L'erreur classique : .hpp et .cpp","text":"<ul> <li>Approche : D\u00e9clarer le template dans un .hpp et l'impl\u00e9menter dans un .cpp.</li> <li>R\u00e9sultat : Erreur d'\u00e9dition de liens (undefined reference), car le compilateur ne trouve pas l'impl\u00e9mentation au moment de compiler le .cpp s\u00e9par\u00e9ment.</li> </ul>"},{"location":"notes/semaine_9_1_generique/#la-solution-standard-pre-c20-hpp-et-tpp","title":"La solution standard (Pr\u00e9-C++20) : .hpp et .tpp","text":"<p>Pour r\u00e9soudre le probl\u00e8me sans surcharger visuellement le fichier d'en-t\u00eate, on inclut l'impl\u00e9mentation \u00e0 la fin du header.</p> <p>Contenant.hpp <pre><code>#pragma once\n\ntemplate &lt;typename T&gt;\nclass Contenant {\npublic:\n    Contenant();\n    void faireQuelqueChose();\n};\n\n// Inclusion de l'impl\u00e9mentation \u00e0 la fin\n#include \"Contenant.tpp\" \n</code></pre></p> <p>Contenant.tpp <pre><code>// Pas de #include \"Contenant.hpp\" ici\ntemplate &lt;typename T&gt;\nContenant&lt;T&gt;::Contenant() {}\n\ntemplate &lt;typename T&gt;\nvoid Contenant&lt;T&gt;::faireQuelqueChose() {}\n</code></pre></p>"},{"location":"notes/semaine_9_1_generique/#la-revolution-c20-les-modules-export-module","title":"La r\u00e9volution C++20 : Les Modules (export module)","text":"<p>Avec C++20, on abandonne les .hpp/.tpp et les #include. Tout est regroup\u00e9 dans un seul fichier de module (g\u00e9n\u00e9ralement .cppm ou .ixx), ce qui acc\u00e9l\u00e8re drastiquement la compilation.</p> <p>Contenant.cppm <pre><code>export module contenant;\n\nexport template &lt;typename T&gt;\nclass Contenant {\npublic:\n    Contenant() {}\n    void faireQuelqueChose() {}\n};\n</code></pre></p> <p>Utilisation : Dans le main.cpp, on remplace <code>#include \"Contenant.hpp\"</code> par <code>import contenant;</code>.</p>"},{"location":"notes/semaine_9_1_generique/#2-evolution-du-stockage-vers-les-collections-modernes","title":"2. \u00c9volution du Stockage : Vers les Collections Modernes","text":"<p>Voici comment faire \u00e9voluer une classe Contenant g\u00e9n\u00e9rique, d'une simple variable vers des collections robustes et modernes.</p>"},{"location":"notes/semaine_9_1_generique/#niveau-1-le-contenant-a-1-donnee-unique","title":"Niveau 1 : Le Contenant \u00e0 1 donn\u00e9e unique","text":"<p>La forme la plus basique de g\u00e9n\u00e9ricit\u00e9. La classe ne stocke qu'un seul \u00e9l\u00e9ment de type T.</p> <pre><code>template &lt;typename T&gt;\nclass ContenantUnique {\nprivate:\n    T donnee;\npublic:\n    void set(const T&amp; val) { donnee = val; }\n    T get() const { return donnee; }\n};\n</code></pre>"},{"location":"notes/semaine_9_1_generique/#niveau-2-le-tableau-dynamique-manuel-c-style","title":"Niveau 2 : Le Tableau Dynamique Manuel (C-Style)","text":"<p>Pour stocker plusieurs \u00e9l\u00e9ments dont le nombre n'est connu qu'\u00e0 l'ex\u00e9cution, l'ancienne m\u00e9thode consiste \u00e0 utiliser un pointeur brut et \u00e0 allouer la m\u00e9moire manuellement sur le tas (Heap).</p> <ul> <li>Inconv\u00e9nient : Gestion de la m\u00e9moire manuelle risqu\u00e9e (fuites de m\u00e9moire si on oublie le <code>delete[]</code>).</li> </ul> <pre><code>template &lt;typename T&gt;\nclass ContenantTableau {\nprivate:\n    T* donnees;\n    size_t capacite;\npublic:\n    ContenantTableau(size_t taille) : capacite(taille) {\n        donnees = new T[capacite]; // Allocation manuelle\n    }\n    ~ContenantTableau() {\n        delete[] donnees; // Lib\u00e9ration obligatoire (Destructeur)\n    }\n    // ...\n};\n</code></pre>"},{"location":"notes/semaine_9_1_generique/#niveau-3-le-standard-moderne-fixe-stdarray","title":"Niveau 3 : Le Standard Moderne Fixe (std::array)","text":"<p>Si (et seulement si) la taille de la collection est connue \u00e0 l'avance (\u00e0 la compilation) et ne changera jamais, <code>std::array</code> est la solution C++ moderne. Il remplace avantageusement <code>T donnees[10]</code> en offrant la m\u00eame s\u00e9curit\u00e9 et les m\u00eames m\u00e9thodes qu'un <code>std::vector</code>, mais sans le co\u00fbt de l'allocation dynamique sur le tas.</p> <pre><code>#include &lt;array&gt;\n\n// On passe la taille 'N' en param\u00e8tre du template !\ntemplate &lt;typename T, size_t N&gt;\nclass ContenantArray {\nprivate:\n    std::array&lt;T, N&gt; donnees;\npublic:\n    // La taille N est fix\u00e9e \u00e0 la compilation\n    void set(size_t index, const T&amp; val) {\n        if (index &lt; N) donnees[index] = val;\n    }\n    size_t taille() const { return donnees.size(); } // Retournera toujours N\n};\n</code></pre> <p>Utilisation : <code>ContenantArray&lt;int, 5&gt; monContenant;</code></p>"},{"location":"notes/semaine_9_1_generique/#niveau-4-le-standard-moderne-dynamique-stdvector","title":"Niveau 4 : Le Standard Moderne Dynamique (std::vector)","text":"<p>C'est la r\u00e8gle d'or en C++ moderne : remplacer les <code>T*</code> par <code>std::vector</code>. Le vecteur g\u00e8re sa propre m\u00e9moire, se redimensionne tout seul, et supprime le besoin d'\u00e9crire un destructeur.</p> <pre><code>#include &lt;vector&gt;\n\ntemplate &lt;typename T&gt;\nclass ContenantVector {\nprivate:\n    std::vector&lt;T&gt; donnees;\npublic:\n    ContenantVector(size_t taille) : donnees(taille) {}\n    // Plus besoin de destructeur !\n\n    void ajouter(const T&amp; val) {\n        donnees.push_back(val); // Redimensionnement automatique\n    }\n    size_t taille() const { return donnees.size(); }\n};\n</code></pre>"},{"location":"notes/semaine_9_1_serialisation_objet/","title":"S\u00e9rialisation de Classes en C++","text":"<p>S\u00e9rialiser une classe consiste \u00e0 sauvegarder son \u00e9tat (ses variables membres) dans un format binaire pour pouvoir le reconstruire plus tard ou l'envoyer sur le r\u00e9seau.  </p>"},{"location":"notes/semaine_9_1_serialisation_objet/#1-la-structure-de-base-hpp","title":"1. La structure de base (.hpp)","text":"<p>Voici une classe <code>Client</code> compl\u00e8te incluant une structure pour la date.  </p> <pre><code>// Client.hpp  \n#ifndef CLIENT_HPP  \n#define CLIENT_HPP  \n\n#include &lt;string&gt;  \n#include &lt;iostream&gt;  \n\nstruct DateTime {  \n    int jour, mois, annee;  \n};  \n\nclass Client {  \npublic:  \n    // Constructeur param\u00e9tr\u00e9  \n    Client(std::string nom, std::string prenom, DateTime naissance);  \n\n    // Constructeur de copie (Deep Copy)  \n    Client(const Client&amp; autre);  \n\n    // Destructeur  \n    ~Client();  \n\n    // M\u00e9thodes de s\u00e9rialisation  \n    void sauvegarder(std::ostream&amp; os) const;  \n    void charger(std::istream&amp; is);  \n\n    void afficher() const;  \n\nprivate:  \n    std::string m_nom;  \n    std::string m_prenom;  \n    DateTime m_dateNaissance;  \n};  \n\n#endif  \n</code></pre>"},{"location":"notes/semaine_9_1_serialisation_objet/#2-limplementation-cpp","title":"2. L'impl\u00e9mentation (.cpp)","text":"<pre><code>// Client.cpp  \n#include \"Client.hpp\"  \n#include &lt;cstdint&gt;  \n\nClient::Client(std::string nom, std::string prenom, DateTime naissance)  \n    : m_nom(nom), m_prenom(prenom), m_dateNaissance(naissance) {  \n}  \n\n// Le constructeur de copie assure que les strings sont bien dupliqu\u00e9es  \nClient::Client(const Client&amp; autre)  \n    : m_nom(autre.m_nom), m_prenom(autre.m_prenom), m_dateNaissance(autre.m_dateNaissance) {  \n}  \n\nClient::~Client() {  \n    // Rien \u00e0 lib\u00e9rer manuellement ici car std::string g\u00e8re sa propre m\u00e9moire  \n}  \n\nvoid Client::sauvegarder(std::ostream&amp; os) const {  \n    // 1. S\u00e9rialiser le nom (Taille + Contenu)  \n    uint32_t tailleNom = static_cast&lt;uint32_t&gt;(m_nom.size());  \n    os.write(reinterpret_cast&lt;const char*&gt;(&amp;tailleNom), sizeof(tailleNom));  \n    os.write(m_nom.data(), tailleNom);  \n\n    // 2. S\u00e9rialiser le pr\u00e9nom (Taille + Contenu)  \n    uint32_t taillePrenom = static_cast&lt;uint32_t&gt;(m_prenom.size());  \n    os.write(reinterpret_cast&lt;const char*&gt;(&amp;taillePrenom), sizeof(taillePrenom));  \n    os.write(m_prenom.data(), taillePrenom);  \n\n    // 3. S\u00e9rialiser la date (Type fixe, pas besoin de taille)  \n    os.write(reinterpret_cast&lt;const char*&gt;(&amp;m_dateNaissance), sizeof(m_dateNaissance));  \n}  \n\nvoid Client::charger(std::istream&amp; is) {  \n    // 1. Charger le nom  \n    uint32_t tailleNom;  \n    is.read(reinterpret_cast&lt;char*&gt;(&amp;tailleNom), sizeof(tailleNom));  \n    m_nom.resize(tailleNom);  \n    is.read(&amp;m_nom[0], tailleNom);  \n\n    // 2. Charger le pr\u00e9nom  \n    uint32_t taillePrenom;  \n    is.read(reinterpret_cast&lt;char*&gt;(&amp;taillePrenom), sizeof(taillePrenom));  \n    m_prenom.resize(taillePrenom);  \n    is.read(&amp;m_prenom[0], taillePrenom);  \n\n    // 3. Charger la date  \n    is.read(reinterpret_cast&lt;char*&gt;(&amp;m_dateNaissance), sizeof(m_dateNaissance));  \n}  \n\nvoid Client::afficher() const {  \n    std::cout &lt;&lt; m_prenom &lt;&lt; \" \" &lt;&lt; m_nom &lt;&lt; \" (\"  \n              &lt;&lt; m_dateNaissance.jour &lt;&lt; \"/\" &lt;&lt; m_dateNaissance.mois &lt;&lt; \"/\" &lt;&lt; m_dateNaissance.annee &lt;&lt; \")\" &lt;&lt; std::endl;  \n}  \n</code></pre>"},{"location":"notes/semaine_9_1_serialisation_objet/#3-pourquoi-ces-methodes","title":"3. Pourquoi ces m\u00e9thodes ?","text":""},{"location":"notes/semaine_9_1_serialisation_objet/#le-constructeur-de-copie","title":"Le Constructeur de Copie","text":"<p>Il est essentiel si vous passez vos objets par valeur. Bien que <code>std::string</code> g\u00e8re sa propre copie, il est important que les \u00e9tudiants comprennent que si la classe contenait des pointeurs bruts (<code>char*</code>), un constructeur de copie serait obligatoire pour \u00e9viter que deux objets pointent vers la m\u00eame zone m\u00e9moire (ce qui causerait un crash au destructeur).  </p>"},{"location":"notes/semaine_9_1_serialisation_objet/#la-serialisation-manuelle","title":"La S\u00e9rialisation Manuelle","text":"<p>On utilise la technique \"Taille + Donn\u00e9es\" pour les membres dont la dimension peut varier (<code>std::string</code>). Pour les types fixes comme <code>DateTime</code> ou les <code>int</code>, on \u00e9crit directement le bloc binaire.  </p>"},{"location":"notes/semaine_9_1_serialisation_objet/#utilisation-avec-un-fichier","title":"Utilisation avec un fichier","text":"<pre><code>Client c(\"Gagnon\", \"Sophie\", {12, 5, 1990});  \nstd::ofstream fichier(\"client.bin\", std::ios::binary);  \nc.sauvegarder(fichier);  \n</code></pre>"}]}