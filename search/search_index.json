{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Programmation 3 (420-4A6-VI) - Hiver 2026","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Vous trouverez ici les notes et exercices du cours. J'ajouterai du nouveau contenu continuellement.</p> <p>Pr\u00e9alable \u00e0 ce cours : 420-2A6-VI : Programmation 2 </p> <p>Ce cours est pr\u00e9alable \u00e0 : 420-5B5-VI Projet int\u00e9grateur 1 Cheminement complet: https://informatique.apical.xyz/</p>"},{"location":"#environnement-de-travail","title":"Environnement de travail","text":"<p>Pour le cours vous avez deux logiciels \u00e0 installer:</p> <ul> <li>WSL (Windows subsystem for linux)</li> <li>Un \u00e9diteur de texte \u00e9volu\u00e9 tel notepad++ (recommand\u00e9) </li> <li>Codeblock</li> <li>Git</li> </ul>"},{"location":"#wsl","title":"WSL","text":"<p>Vous devez installer git et build-essential dans l'environnement linux. Les paquets tels que, mais non limit\u00e9s \u00e0, gemini, claude, chatgpt sont proscrit. \u2003</p>"},{"location":"#notepad-ou-autre-editeur-compatible","title":"Notepad++ (ou autre \u00e9diteur compatible)","text":"<p>Parfois git vous demande de faire l'\u00e9ditions de fichiers tel que les commentaires pour les soumissions. (git commit). Il arrive \u00e9galement que des conflits soient pr\u00e9sent. Le logiciels permet de mieux travailler dans ces situations plus complexe.</p>"},{"location":"#git","title":"Git","text":"<p>Installation normale, portez attention \u00e0 l'\u00e9diteur par d\u00e9faut. Autrement, vous allez vous retrouver avec vim pour \u00e9diter vos fichiers</p> <p>Votre identit\u00e9 : dans WSL vous \u00eates dans un environnement \"nouveau\" donc git va vous demander votre identit\u00e9. Utilisez votre courriel coll\u00e8ge comme configuration de courriel globale : @etudiant.cegepvicto.ca  Pour votre nom vous pouvez r\u00e9utiliser votre num\u00e9ro de DA  </p> <pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"[DA]@etudiant.cegepvicto.ca\"\n  git config --global user.name \"Votre nom\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n</code></pre>"},{"location":"#regles-de-classes-et-explications","title":"R\u00e8gles de classes et explications :","text":"<p>Petit rappel des r\u00e8gles au niveau de la P.D.E.A</p>"},{"location":"#conditions-pedagogiques-particulieres","title":"Conditions p\u00e9dagogiques particuli\u00e8res","text":"<p>Utilisation de g\u00e9n\u00e9rateur automatique :  </p> <p>Dans le cadre des activit\u00e9s acad\u00e9miques du cours, l'utilisation de g\u00e9n\u00e9rateurs de code automatiques, d'assistants d'IA tels que ChatGPT, Copilot ou tout autre outil similaire permettant la cr\u00e9ation automatique de contenu, la g\u00e9n\u00e9ration de code ou l\u2019assistance \u00e0 la r\u00e9solution d'exercices, est formellement interdite. Toute utilisation de ces outils durant un cours entra\u00eenera l'exclusion imm\u00e9diate de l'\u00e9l\u00e8ve de la p\u00e9riode concern\u00e9e.  </p>"},{"location":"#utilisation-des-cellulaires-ou-dappareils-mobiles-en-classe","title":"Utilisation des cellulaires ou d'appareils mobiles en classe","text":"<p>Toute utilisation d'appareil mobile tel que cellulaire, tablette ou console de jeux mobile est proscrite pendant le bloc horaire \u00e0 l'int\u00e9rieur du local. (Pr\u00e9cision : pauses incluses.) L'utilisation de tels appareils doit imp\u00e9rativement se faire hors du local afin de favoriser le climat d'apprentissage.  </p> <p>Les manquements aux articles pr\u00e9c\u00e9dents seront consign\u00e9s. Apr\u00e8s trois (3) exclusions, des d\u00e9marches administratives seront entreprises avec l'API afin de d\u00e9terminer les modalit\u00e9s de cheminement.</p>"},{"location":"#environnement-numerique-dapprentissage-plateforme","title":"Environnement num\u00e9rique d\u2019apprentissage (plateforme)","text":"<ul> <li>Team</li> <li>Github</li> <li>Github classroom</li> </ul> <p>L'\u00e9l\u00e8ve a la responsabilit\u00e9 d'avoir un compte github avec un nom d'utilisateur r\u00e9pondant \u00e0 la norme suivante :</p> <p>cgpvicto-[son num\u00e9ro de DA]</p> <p>exemple : cgpvicto-9999999</p> <p>Une fois le compte github cr\u00e9\u00e9. On doit rejoindre le github classroom correspondant \u00e0 son groupe, proc\u00e9dure qui sera donn\u00e9e en classe lors des premi\u00e8res semaines</p>"},{"location":"conventions/","title":"Normes et Conventions de Code C++","text":"<p>Standard du Cours</p> <p>Ce cours utilise officiellement le standard C++20. Tous les exemples et exercices doivent \u00eatre compil\u00e9s avec un compilateur compatible.</p> <p>Ce document d\u00e9finit les standards de programmation attendus pour tous les travaux pratiques et examens. L'objectif est de produire un code lisible, maintenable et proche des standards industriels modernes.</p>"},{"location":"conventions/#1-structure-du-code-et-nommage","title":"1. Structure du Code et Nommage","text":""},{"location":"conventions/#11-nommage-naming-convention","title":"1.1. Nommage (Naming Convention)","text":"<p>Nous adoptons le style de la Biblioth\u00e8que Standard C++ (STL).</p> \u00c9l\u00e9ment Format Exemple Variables <code>snake_case</code> <code>nombre_etudiants</code>, <code>index_courant</code> Fonctions <code>snake_case</code> <code>calculer_moyenne()</code>, <code>sauvegarder_fichier()</code> Classes / Structs <code>PascalCase</code> <code>Etudiant</code>, <code>GestionnaireFichier</code> Constantes <code>SCREAMING_SNAKE</code> <code>MAX_BUFFER_SIZE</code>, <code>PI</code>"},{"location":"conventions/#12-initialisation-uniforme-avec-les-accolades","title":"1.2. Initialisation Uniforme avec les Accolades <code>{}</code>","text":"<p>R\u00e8gle : Pour initialiser toute variable, utilisez toujours la syntaxe avec accolades <code>{}</code> (Uniform Initialization).</p> <p>Pourquoi ? - S\u00e9curit\u00e9 : Emp\u00eache les conversions de type risqu\u00e9es (ex: <code>int x {5.5};</code> g\u00e9n\u00e8re une erreur de compilation). - Uniformit\u00e9 : La m\u00eame syntaxe fonctionne pour tout (variables simples, tableaux, objets). - Garantie Z\u00e9ro : Une initialisation avec des accolades vides (<code>int x {};</code>) garantit que la variable vaut z\u00e9ro (ou son \u00e9quivalent), pr\u00e9venant les bogues de variables non-initialis\u00e9es.</p>"},{"location":"conventions/#2-structure-et-complexite","title":"2. Structure et Complexit\u00e9","text":""},{"location":"conventions/#21-regle-des-3-niveaux","title":"2.1. R\u00e8gle des 3 niveaux","text":"<p>L'imbrication (nesting) ne doit jamais d\u00e9passer 3 niveaux de profondeur.</p>"},{"location":"conventions/#22-clause-de-garde-guard-clause","title":"2.2. Clause de Garde (Guard Clause)","text":"<p>Privil\u00e9giez toujours le retour anticip\u00e9 (Early Return) pour r\u00e9duire la complexit\u00e9.</p>"},{"location":"conventions/#3-bonnes-pratiques-fichiers-et-performance","title":"3. Bonnes pratiques : Fichiers et Performance","text":""},{"location":"conventions/#31-organisation-une-classe-par-fichier","title":"3.1. Organisation : Une Classe par Fichier","text":"<p>Chaque <code>class</code> ou <code>struct</code> doit \u00eatre d\u00e9finie dans son propre couple de fichiers (<code>.hpp</code> et <code>.cpp</code>).</p>"},{"location":"conventions/#32-fichiers-den-tete-et-pragma-once","title":"3.2. Fichiers d'en-t\u00eate et <code>#pragma once</code>","text":"<p>Tout fichier <code>.hpp</code> doit commencer imp\u00e9rativement par <code>#pragma once</code>.</p>"},{"location":"conventions/#33-le-const-et-le-passage-par-reference","title":"3.3. Le <code>const</code> et le passage par r\u00e9f\u00e9rence","text":"<p>Pour les types complexes (<code>string</code>, <code>vector</code>, etc.), utilisez <code>const type&amp;</code> en param\u00e8tre pour \u00e9viter des copies inutiles.</p>"},{"location":"conventions/#4-documentation-du-code-doxygen","title":"4. Documentation du Code (Doxygen)","text":"<p>Le standard est Doxygen. La documentation se place toujours dans les fichiers <code>.hpp</code>.</p> <ul> <li>Classes/Structs : Doivent avoir un bloc <code>/** ... */</code> avec au minimum <code>@brief</code>.</li> <li>M\u00e9thodes : Doivent avoir un bloc <code>///</code> avec <code>@brief</code>, <code>@param</code> et <code>@return</code> si applicable. <pre><code>/**\n * Lire une image sur disque \n *\n * @param nom_fichier le ficheir \u00e0 lire. doit \u00eatre absolu ou relatif\n *     au dossier de travail de l'application.\n *\n * @return l'image stock\u00e9e dans `nom_fichier. Si l'image sur le dosque n'a pas de pixel\n *     `double`, ils seront transtyp\u00e9 (cast) en `double`.\n *\n * @throws IoError Lanc\u00e9 si `nom_fichier` n'existe pas ou n'est pas lisible.\n *\n */\nlsst::afw::image::Image&lt;double&gt; charger_image(std::string const &amp; nom_fichier);\n</code></pre></li> </ul>"},{"location":"conventions/#5-exemple-complet-dapplication","title":"5. Exemple Complet d'Application","text":"<p>T\u00e9l\u00e9charger l'exemple complet (ZIP)</p> <p>Voici un exemple concret qui rassemble tous les standards.</p>"},{"location":"conventions/#51-structure-des-fichiers","title":"5.1. Structure des fichiers","text":"<pre><code>/exemple_commande\n|-- Article.hpp\n|-- Commande.cpp\n|-- Commande.hpp\n|-- main.cpp\n|-- ServiceConnexion.cpp\n`-- ServiceConnexion.hpp\n</code></pre>"},{"location":"conventions/#52-fichiers-den-tete-et-source","title":"5.2. Fichiers d'en-t\u00eate et Source","text":"Fichier : <code>main.cpp</code> <pre><code>#include &lt;iostream&gt;\n#include \"Commande.hpp\"\n\nint main() {\n    ServiceConnexion service_connexion {};\n    Article article_disponible {\"Stylo\", 10};\n    Article article_indisponible {\"Cahier\", 0};\n\n    std::cout &lt;&lt; \"--- Debut des tests de scenarios ---\\\\n\" &lt;&lt; std::endl;\n\n    // Sc\u00e9nario 1 : Commande valide\n    Commande cmd_valide {101};\n    cmd_valide.ajouter_article(article_disponible);\n    cmd_valide.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 2 : Article en rupture de stock\n    Commande cmd_stock_epuise {102};\n    cmd_stock_epuise.ajouter_article(article_disponible);\n    cmd_stock_epuise.ajouter_article(article_indisponible);\n    cmd_stock_epuise.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 3 : Commande invalide (vide)\n    Commande cmd_vide {103};\n    cmd_vide.traiter_commande(service_connexion);\n\n    std::cout &lt;&lt; \"\\n--- Fin des tests ---\\\\n\";\n\n    return 0;\n}\n</code></pre> <p>(Le code des autres fichiers <code>Article.hpp</code>, <code>Commande.hpp</code>, etc. est omis pour la lisibilit\u00e9, mais est inclus dans le ZIP t\u00e9l\u00e9chargeable.)</p>"},{"location":"conventions/#53-compilation-et-resultat","title":"5.3. Compilation et R\u00e9sultat","text":"<p>Pour compiler et ex\u00e9cuter cet exemple : <pre><code>g++ -std=c++20 -Wall -o exemple_commande/exemple exemple_commande/main.cpp exemple_commande/Commande.cpp exemple_commande/ServiceConnexion.cpp\n./exemple_commande/exemple\n</code></pre></p> <p>Le r\u00e9sultat attendu est : <pre><code>--- Debut des tests de scenarios ---\n\nSUCCES : La commande 101 a ete envoyee.\nERREUR (Cmd 102): Un ou plusieurs articles en rupture de stock.\nERREUR (Cmd 103): Commande invalide ou vide.\n\n--- Fin des tests ---\n</code></pre></p>"},{"location":"horaire/","title":"Horaire du cours","text":"<p>Planification de la session Hiver 2026.</p> <p>Remarque importante</p> <p>Les dates de remises sont indiqu\u00e9es par le drapeau \ud83d\udea9. Assurez-vous de v\u00e9rifier cette colonne r\u00e9guli\u00e8rement.</p>"},{"location":"horaire/#partie-1-avant-la-relache","title":"Partie 1 : Avant la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 1 Cours 01 19-01-2026 08:15 Pr\u00e9sentation du plan de cours Cours 02 21-01-2026 13:15 Semaine 2 Cours 03 26-01-2026 08:15 Cours 04 29-01-2026 13:15 Semaine 3 Cours 05 02-02-2026 08:15 Cours 06 05-02-2026 13:15 Semaine 4 Cours 07 09-02-2026 08:15 Cours 08 12-02-2026 13:15 Semaine 5 Cours 09 16-02-2026 08:15 Cours 10 19-02-2026 13:15 Semaine 6 Cours 11 23-02-2026 08:15 Cours 12 26-02-2026 13:15 {: .horaire } <p>\ud83c\udf34 SEMAINE DE REL\u00c2CHE : Du 2 au 6 mars 2026</p> <p>Aucun cours.</p>"},{"location":"horaire/#partie-2-apres-la-relache","title":"Partie 2 : Apr\u00e8s la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 7 Cours 13 09-03-2026 08:15 Cours 14 12-03-2026 13:15 Semaine 8 Cours 15 16-03-2026 08:15 Cours 16 19-03-2026 13:15 Semaine 9 Cours 17 23-03-2026 08:15 Cours 18 26-03-2026 13:15 Semaine 10 Cours 19 30-03-2026 08:15 Cours 20 02-04-2026 13:15 Prochaine rencontre dans 1 sem. Semaine 11 Cours 21 09-04-2026 13:15 Cours 22 13-04-2026 08:15 Semaine 12 Cours 23 16-04-2026 13:15 Cours 24 20-04-2026 08:15 Semaine 13 Cours 25 27-04-2026 08:15 Cours 26 30-04-2026 13:15 Semaine 14 Cours 27 04-05-2026 08:15 Cours 28 07-05-2026 13:15 Semaine 15 Cours 29 11-05-2026 08:15 Cours 30 14-05-2026 13:15 {: .horaire }"},{"location":"ressources/","title":"Ressources","text":""},{"location":"ressources/#documentation-officielle","title":"Documentation officielle","text":"<p>C# documentation officielle : https://learn.microsoft.com/fr-ca/dotnet/csharp/tour-of-csharp/</p> <p>.Net 8.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-8.0</p> <p>.Net 9.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-9.0</p> <p>Tests unitaires MSTest : https://learn.microsoft.com/fr-ca/dotnet/core/testing/unit-testing-with-mstest </p> <p>Table ASCII : https://www.asciitable.com/</p>"},{"location":"exercices/semaine_1_1_exercices/","title":"Exercices de la Semaine 1 : Les Bases","text":"<p>Ces exercices sont con\u00e7us pour pratiquer les concepts de base vus dans les notes de la semaine 1. Concentrez-vous sur la ma\u00eetrise de la compilation, de l'affichage, de la saisie et des fonctions simples.</p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-1-affichage-et-saisie-simple","title":"Bloc 1 : Affichage et Saisie Simple","text":"<p>Exercice 1 : Bonjour le Monde - Objectif : Cr\u00e9er un programme C++ de base. - T\u00e2che : \u00c9crivez un programme qui affiche \"Bonjour le monde !\" dans la console et qui se termine en retournant <code>0</code>.</p> <p>Exercice 2 : Fiche de Pr\u00e9sentation - Objectif : Manipuler <code>std::cout</code> avec plusieurs lignes. - T\u00e2che : \u00c9crivez un programme qui affiche votre nom, votre ville et votre \u00e2ge sur des lignes s\u00e9par\u00e9es.</p> <p>Exercice 3 : D\u00e9claration de Variables - Objectif : Se familiariser avec l'initialisation uniforme. - T\u00e2che : D\u00e9clarez quatre variables en utilisant la syntaxe d'accolades <code>{}</code> : un <code>int</code>, un <code>double</code>, un <code>char</code>, et un <code>bool</code>. Assignez-leur des valeurs de votre choix et affichez chaque valeur avec une description.</p> <p>Exercice 4 : Interaction Simple - Objectif : Utiliser <code>std::cin &gt;&gt;</code> avec <code>std::string</code> et <code>int</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur son pr\u00e9nom et son ann\u00e9e de naissance. Calculez (approximativement) son \u00e2ge et affichez un message comme <code>\"Bonjour [Pr\u00e9nom], vous avez environ [Age] ans.\"</code>.</p> <p>Exercice 5 : Calcul d'Aire - Objectif : Utiliser des types <code>double</code> avec <code>std::cin</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur la largeur et la hauteur d'un rectangle. Calculez et affichez son aire.</p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-2-gestion-du-buffer-et-erreurs-de-saisie","title":"Bloc 2 : Gestion du Buffer et Erreurs de Saisie","text":"<p>Exercice 6 : Le Pi\u00e8ge de <code>getline</code> - Objectif : R\u00e9soudre le conflit entre <code>std::cin &gt;&gt;</code> et <code>std::getline</code>. - T\u00e2che : 1. Demandez \u00e0 l'utilisateur son num\u00e9ro de porte (un <code>int</code>).   2. Demandez-lui ensuite son nom de rue complet (un <code>std::string</code> avec <code>getline</code>).   3. Observez que le programme ignore la saisie de la rue.   4. Corrigez le probl\u00e8me en nettoyant le buffer apr\u00e8s la lecture du nombre.</p> <p>Exercice 7 : Gestion d'Erreur Simple - Objectif : Utiliser <code>std::cin.fail()</code> pour d\u00e9tecter une erreur. - T\u00e2che : Demandez \u00e0 l'utilisateur d'entrer un nombre. Si la saisie \u00e9choue (si l'utilisateur tape du texte), affichez \"Erreur : saisie invalide.\". Sinon, affichez \"Merci !\".</p> <p>Exercice 8 : Boucle de Saisie Robuste - Objectif : Cr\u00e9er une boucle qui force une saisie num\u00e9rique valide. - T\u00e2che : Cr\u00e9ez une boucle <code>while</code> qui continue de demander \"Entrez votre age :\" jusqu'\u00e0 ce que l'utilisateur entre un nombre entier valide. Si l'utilisateur se trompe, le programme doit afficher une erreur et lui redemander.</p> <p>Exercice 9 : Analyse d'Entr\u00e9e Mixte - Objectif : Comprendre comment <code>cin</code> g\u00e8re les lectures partielles. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur un nombre. L'utilisateur doit taper <code>45abc</code>.   2. Lisez la saisie dans une variable de type <code>int</code>.   3. Affichez l'entier que vous avez r\u00e9ussi \u00e0 lire.   4. Ensuite, lisez le reste du buffer dans une variable <code>std::string</code>.   5. Affichez la cha\u00eene de caract\u00e8res. Le r\u00e9sultat devrait vous montrer ce qui restait dans le buffer.</p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-3-fonctions-et-tableaux-classique","title":"Bloc 3 : Fonctions et Tableaux (Classique)","text":"<p>Exercice 10 : Calculatrice Simple - Objectif : \u00c9crire et appeler des fonctions simples. - T\u00e2che : \u00c9crivez quatre fonctions : <code>addition(int a, int b)</code>, <code>soustraction(int a, int b)</code>, <code>multiplication(int a, int b)</code>, et <code>division(int a, int b)</code>. Chaque fonction doit retourner le r\u00e9sultat du calcul. Dans <code>main</code>, testez chaque fonction avec des valeurs de votre choix et affichez les r\u00e9sultats.</p> <p>Exercice 11 : Passage par Copie - Objectif : Constater l'effet d'un passage par copie. - T\u00e2che :   1. \u00c9crivez une fonction <code>ajouter_vingt(int nombre)</code> qui re\u00e7oit un entier, lui ajoute 20, et n'a pas de <code>return</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {10}</code>.   3. Appelez <code>ajouter_vingt(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 12 : Passage par R\u00e9f\u00e9rence - Objectif : Utiliser une r\u00e9f\u00e9rence pour modifier une variable externe. - T\u00e2che :   1. \u00c9crivez une fonction <code>reinitialiser(int&amp; nombre)</code> qui change la valeur de l'entier re\u00e7u \u00e0 <code>0</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur {123}</code>.   3. Appelez <code>reinitialiser(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 13 : Somme d'un Tableau (Style C) - Objectif : Passer un tableau \u00e0 une fonction (m\u00e9thode classique). - T\u00e2che : Cr\u00e9ez une fonction <code>calculer_somme(const int tableau[], int taille)</code> qui retourne la somme de tous les \u00e9l\u00e9ments d'un tableau. Dans <code>main</code>, initialisez un tableau (ex: <code>int tableau[] {10, 20, 30};</code>), trouvez sa taille avec <code>std::ssize</code>, et affichez la somme retourn\u00e9e par votre fonction.</p> <p>Exercice 14 : Trouver le Maximum - Objectif : Parcourir un tableau dans une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>trouver_max(const int tableau[], int taille)</code> qui retourne la plus grande valeur d'un tableau. Testez-la dans <code>main</code>.</p> <p>Exercice 15 : Inversion de Tableau - Objectif : Modifier un tableau via une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau sur place (le premier devient le dernier, etc.). Dans <code>main</code>, d\u00e9clarez un tableau comme <code>int tableau[] {1, 2, 3, 4, 5};</code>, affichez-le, appelez la fonction, puis affichez-le \u00e0 nouveau pour voir le changement.</p>"},{"location":"exercices/semaine_1_1_exercices/#bloc-4-c-moderne-stdspan-vector","title":"Bloc 4 : C++ Moderne (std::span &amp; Vector)","text":"<p>Exercice 16 : La R\u00e8gle d'Or (std::span) - Objectif : Remplacer le couple <code>(tableau, taille)</code> par <code>std::span</code>. - T\u00e2che :   1. Reprenez votre fonction <code>calculer_somme</code> de l'exercice 13.   2. Changez sa signature pour qu'elle prenne un <code>std::span&lt;const int&gt;</code> au lieu d'un tableau et une taille.   3. Dans <code>main</code>, cr\u00e9ez un tableau brut (<code>int t[]...</code>).   4. Appelez la fonction. Remarquez que vous n'avez plus besoin de passer la taille manuellement !</p> <p>Exercice 17 : Optimisation avec R\u00e9f\u00e9rence Constante - Objectif : \u00c9viter les copies inutiles sur les gros objets. - T\u00e2che :   1. \u00c9crivez une fonction <code>afficher_message(std::string message)</code> (par copie).   2. Modifiez-la pour utiliser le passage par r\u00e9f\u00e9rence constante (<code>const std::string&amp;</code>).   3. Ajoutez un <code>cout</code> dans la fonction pour v\u00e9rifier que le message s'affiche bien.   Question : \u00c0 l'utilisation dans le <code>main</code>, est-ce que le code d'appel change ? (R\u00e9ponse attendue : Non, c'est transparent, mais plus rapide).</p> <p>Exercice 18 : Vecteur Dynamique et Span - Objectif : Utiliser un tableau qui peut grandir (<code>vector</code>) avec une fonction moderne. - T\u00e2che :   1. Incluez <code>&lt;vector&gt;</code>.   2. Cr\u00e9ez un <code>std::vector&lt;int&gt;</code> vide.   3. Utilisez une boucle <code>while</code> pour demander des nombres \u00e0 l'utilisateur. Ajoutez-les au vecteur avec <code>.push_back()</code>. Arr\u00eatez quand il tape -1.   4. Appelez votre fonction <code>calculer_somme</code> (celle avec le <code>std::span</code> de l'exercice 16) en lui passant ce vecteur.   Observation : Notez que le <code>span</code> accepte aussi bien le tableau brut (Ex 16) que le vecteur (Ex 18).</p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/","title":"Exercices suppl\u00e9mentaire semaine 1","text":""},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-1-le-valideur-dacces-focus-cin-robuste-fonctions","title":"Exercice 1 : Le Valideur d'Acc\u00e8s (Focus: <code>cin</code> robuste, fonctions)","text":"<p>Objectif : Ma\u00eetriser la saisie num\u00e9rique s\u00e9curitaire et l'appel de fonction simple.  </p> <p>Description : 1.  \u00c9crivez une fonction <code>bool est_majeur(int age)</code> qui retourne <code>true</code> si l'\u00e2ge est de 18 ans ou plus, et <code>false</code> sinon. 2.  Dans votre fonction <code>main</code>, demandez \u00e0 l'utilisateur d'entrer son \u00e2ge. 3.  Votre <code>main</code> doit utiliser une boucle <code>while</code> (comme vu dans les notes) pour forcer l'utilisateur \u00e0 entrer un nombre entier valide. Si l'utilisateur tape du texte, le programme doit afficher une erreur et redemander l'\u00e2ge. 4.  Une fois qu'un \u00e2ge valide est entr\u00e9, appelez la fonction <code>est_majeur</code> et affichez un message clair \u00e0 l'utilisateur, par exemple : \"Acc\u00e8s autoris\u00e9\" ou \"Acc\u00e8s refus\u00e9\".  </p> <p>Concepts Pratiqu\u00e9s : - Boucle de saisie robuste (<code>while</code>, <code>cin.fail</code>, <code>cin.clear</code>, <code>cin.ignore</code>). - Fonctions avec <code>return</code>. - Passage par copie.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-2-le-modificateur-de-profil-focus-passage-par-reference","title":"Exercice 2 : Le Modificateur de Profil (Focus: Passage par r\u00e9f\u00e9rence)","text":"<p>Objectif : Comprendre la diff\u00e9rence fondamentale entre une fonction qui peut modifier une variable et une qui ne le peut pas.  </p> <p>Description : 1.  Dans <code>main</code>, d\u00e9clarez deux variables : <code>int score {1000};</code> et <code>int niveau {5};</code>. 2.  \u00c9crivez une fonction <code>void appliquer_bonus(int&amp; score_actuel)</code> qui prend un score par r\u00e9f\u00e9rence et lui ajoute 500 points. 3.  \u00c9crivez une fonction <code>void simuler_defaite(int score_copie)</code> qui prend un score par copie, lui enl\u00e8ve 200 points et affiche un message \"Simulation : le score tombe \u00e0 [nouveau score]\". 4.  Dans <code>main</code> :     -   Affichez le score et le niveau initiaux.     -   Appelez <code>simuler_defaite(score);</code>.     -   Affichez le score. (A-t-il chang\u00e9 ?)     -   Appelez <code>appliquer_bonus(score);</code>.     -   Affichez le score final. (A-t-il chang\u00e9 ?)  </p> <p>Concepts Pratiqu\u00e9s : - Distinction claire entre passage par copie et par r\u00e9f\u00e9rence (<code>&amp;</code>). - Modification de l'\u00e9tat d'une variable du <code>main</code> depuis une fonction.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-3-lanalyseur-de-notes-focus-tableaux-stdssize","title":"Exercice 3 : L'Analyseur de Notes (Focus: Tableaux, <code>std::ssize</code>)","text":"<p>Objectif : Manipuler des tableaux et les passer \u00e0 des fonctions pour analyse.  </p> <p>Description : Vous allez cr\u00e9er un petit programme d'analyse statistique pour un tableau de notes. 1.  Dans <code>main</code>, initialisez un tableau de notes : <code>int notes[] {88, 76, 95, 54, 83, 65, 77};</code>. 2.  Utilisez <code>std::ssize</code> pour obtenir la taille du tableau et la stocker dans une variable <code>taille</code>. 3.  Cr\u00e9ez une fonction <code>double calculer_moyenne(const int tableau[], int taille)</code> qui calcule et retourne la moyenne des notes. 4.  Cr\u00e9ez une fonction <code>int trouver_note_maximale(const int tableau[], int taille)</code> qui trouve et retourne la meilleure note. 5.  Dans <code>main</code>, appelez vos deux fonctions avec le tableau <code>notes</code> et sa <code>taille</code>. Affichez les r\u00e9sultats de mani\u00e8re format\u00e9e (ex: \"Moyenne: 78.2, Note maximale: 95\").  </p> <p>Concepts Pratiqu\u00e9s : - D\u00e9claration et initialisation de tableaux. - Utilisation de <code>std::ssize</code> (C++20). - Passage de tableaux (et de leur taille) \u00e0 des fonctions. - Parcours de tableau avec une boucle <code>for</code>.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-4-linverseur-de-sequence-focus-algorithmique-sur-tableau","title":"Exercice 4 : L'Inverseur de S\u00e9quence (Focus: Algorithmique sur tableau)","text":"<p>Objectif : Modifier un tableau \"en place\" via une fonction.  </p> <p>Description : Le but est d'inverser l'ordre des \u00e9l\u00e9ments d'un tableau. Par exemple, <code>{10, 20, 30, 40, 50}</code> doit devenir <code>{50, 40, 30, 20, 10}</code>. 1.  \u00c9crivez une fonction <code>void afficher_tableau(const int tableau[], int taille)</code> qui affiche simplement le contenu d'un tableau sur une ligne. 2.  \u00c9crivez une fonction <code>void inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau in-place (sans cr\u00e9er un deuxi\u00e8me tableau temporaire). 3.  Dans <code>main</code> :     -   D\u00e9clarez un tableau, par exemple <code>int sequence[] {10, 20, 30, 40, 50};</code>.     -   Affichez le tableau original en utilisant votre fonction <code>afficher_tableau</code>.     -   Appelez <code>inverser_tableau</code>.     -   Affichez le tableau \u00e0 nouveau pour prouver qu'il a bien \u00e9t\u00e9 invers\u00e9.  </p> <p>Indice : Pour inverser, il suffit d'\u00e9changer le premier \u00e9l\u00e9ment avec le dernier, le deuxi\u00e8me avec l'avant-dernier, et ainsi de suite, en s'arr\u00eatant au milieu du tableau.  </p> <p>Concepts Pratiqu\u00e9s : - Algorithme simple (\u00e9change de variables). - Modification en place d'un tableau pass\u00e9 \u00e0 une fonction. - Parcours de tableau.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-5-le-repertoire-telephonique-focus-combinaison-de-concepts","title":"Exercice 5 : Le R\u00e9pertoire T\u00e9l\u00e9phonique (Focus: Combinaison de concepts)","text":"<p>Objectif : Combiner la gestion de <code>string</code>, les tableaux et le nettoyage du buffer.  </p> <p>Description : Cr\u00e9ez un mini-r\u00e9pertoire qui peut stocker 3 noms et 3 num\u00e9ros de t\u00e9l\u00e9phone. 1.  Dans <code>main</code>, d\u00e9clarez deux tableaux statiques de taille 3 :     -   <code>std::string noms[3];</code>     -   <code>std::string telephones[3];</code> 2.  Cr\u00e9ez une boucle <code>for</code> qui s'ex\u00e9cute 3 fois. \u00c0 chaque tour, elle doit :     -   Demander \u00e0 l'utilisateur son \u00e2ge (juste pour cr\u00e9er le pi\u00e8ge de <code>cin</code> !).     -   Demander son nom complet (doit accepter les espaces).     -   Demander son num\u00e9ro de t\u00e9l\u00e9phone (peut \u00eatre stock\u00e9 dans une <code>string</code>).     -   Stocker le nom et le t\u00e9l\u00e9phone dans les tableaux.     -   Attention : Assurez-vous de bien g\u00e9rer le buffer de <code>cin</code> pour que la lecture du nom complet fonctionne apr\u00e8s celle de l'\u00e2ge ! 3.  Une fois les 3 contacts entr\u00e9s, \u00e9crivez une fonction <code>void afficher_repertoire(const std::string noms[], const std::string telephones[], int taille)</code> qui affiche joliment la liste des contacts. 4.  Appelez cette fonction depuis <code>main</code> pour afficher le r\u00e9sultat.  </p> <p>Concepts Pratiqu\u00e9s : - Combinaison de <code>cin &gt;&gt;</code> et <code>getline</code>. - <code>std::cin.ignore()</code>. - Tableaux de <code>std::string</code>. - Passage de plusieurs tableaux \u00e0 une fonction.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-6-le-menu-interactif-robuste","title":"Exercice 6 : Le Menu Interactif Robuste","text":"<p>Objectif : Cr\u00e9er une application compl\u00e8te et robuste avec un menu, en utilisant des fonctions et une gestion d'erreurs avanc\u00e9e.  </p> <p>Description : 1.  Cr\u00e9ez un programme qui affiche un menu \u00e0 l'utilisateur : <pre><code>--- MENU ---  \n1. Calculer l'aire d'un cercle  \n2. V\u00e9rifier si un nombre est pair ou impair  \n3. Quitter  \nVotre choix :   \n</code></pre> 2.  Le programme doit tourner en boucle et r\u00e9-afficher le menu tant que l'utilisateur ne choisit pas l'option 3. 3.  La saisie du choix de menu doit \u00eatre robuste : si l'utilisateur entre du texte ou un nombre invalide (ex: 5), le programme doit afficher une erreur et redemander le choix. 4.  Option 1 : Appelle une fonction <code>calculer_aire_cercle()</code> qui demande \u00e0 l'utilisateur un rayon (de type <code>double</code>), g\u00e8re les erreurs de saisie pour le rayon, puis affiche l'aire (<code>\u03c0 * rayon\u00b2</code>). 5.  Option 2 : Appelle une fonction <code>verifier_parite()</code> qui demande un entier (en g\u00e9rant les erreurs), puis affiche si le nombre est pair ou impair. 6.  Option 3 : Termine le programme avec un message \"Au revoir !\". 7.  Si l'utilisateur entre un nombre autre que 1, 2, ou 3, affichez un message \"Option invalide\".  </p> <p>Concepts Pratiqu\u00e9s : - Boucle <code>while</code> principale pour le menu. - Boucles <code>while</code> internes pour la saisie robuste. - Fonctions distinctes pour chaque action. - Logique conditionnelle (<code>if</code>/<code>else if</code>/<code>else</code>).  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-7-statistiques-de-notes-avancees","title":"Exercice 7 : Statistiques de Notes Avanc\u00e9es","text":"<p>Objectif : Utiliser le passage par r\u00e9f\u00e9rence pour \"retourner\" plusieurs valeurs depuis une seule fonction.  </p> <p>Description : 1.  Dans <code>main</code>, initialisez un tableau de notes : <code>int notes[] {88, 76, 95, 54, 83, 65, 77, 91};</code>. 2.  \u00c9crivez une seule fonction <code>void calculer_statistiques(const int tableau[], int taille, double&amp; moyenne, int&amp; note_max, int&amp; note_min)</code>. 3.  Cette fonction ne retourne rien (<code>void</code>), mais elle calcule la moyenne, la note maximale et la note minimale et les place dans les variables pass\u00e9es par r\u00e9f\u00e9rence (<code>moyenne</code>, <code>note_max</code>, <code>note_min</code>). 4.  Dans <code>main</code> :     -   D\u00e9clarez trois variables pour recevoir les r\u00e9sultats : <code>double moyenne_resultat {};</code>, <code>int max_resultat {};</code>, <code>int min_resultat {};</code>.     -   Appelez <code>calculer_statistiques</code> en lui passant le tableau et les trois variables par r\u00e9f\u00e9rence.     -   Affichez les valeurs des trois variables de r\u00e9sultats pour prouver que la fonction les a bien modifi\u00e9es.  </p> <p>Concepts Pratiqu\u00e9s : - Param\u00e8tres de sortie (Output parameters) via le passage par r\u00e9f\u00e9rence. - Utilisation de <code>const</code> pour les param\u00e8tres d'entr\u00e9e qui ne doivent pas \u00eatre modifi\u00e9s. - Algorithmique (trouver un min/max).  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-8-le-palindrome","title":"Exercice 8 : Le Palindrome","text":"<p>Objectif : Impl\u00e9menter un algorithme simple en manipulant une cha\u00eene de caract\u00e8res comme un tableau.  </p> <p>Description : Un palindrome est un mot qui se lit de la m\u00eame mani\u00e8re \u00e0 l'endroit et \u00e0 l'envers (ex: \"radar\", \"level\", \"kayak\"). 1.  \u00c9crivez une fonction <code>bool est_palindrome(const std::string&amp; mot)</code>. 2.  \u00c0 l'int\u00e9rieur de cette fonction, utilisez une boucle pour comparer les caract\u00e8res du mot. Comparez le premier avec le dernier, le deuxi\u00e8me avec l'avant-dernier, et ainsi de suite, en s'arr\u00eatant au milieu. Si vous trouvez une paire de caract\u00e8res qui ne correspond pas, la fonction peut imm\u00e9diatement retourner <code>false</code>. Si la boucle se termine sans trouver de diff\u00e9rence, le mot est un palindrome.     - Indice : Vous n'avez pas besoin de cr\u00e9er une deuxi\u00e8me cha\u00eene invers\u00e9e. Travaillez avec deux index (un qui part du d\u00e9but et un qui part de la fin). 3.  Dans <code>main</code>, demandez un mot \u00e0 l'utilisateur, appelez votre fonction et affichez le r\u00e9sultat (ex: \"<code>radar</code> est un palindrome.\" ou \"<code>bonjour</code> n'est pas un palindrome.\").  </p> <p>Concepts Pratiqu\u00e9s : - Manipulation de <code>std::string</code> avec l'op\u00e9rateur <code>[]</code>. - Logique algorithmique (deux pointeurs/index). - Retour anticip\u00e9 (<code>return false;</code>) d\u00e8s qu'une condition est remplie.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-9-le-trieur-de-tableau-tri-a-bulles","title":"Exercice 9 : Le Trieur de Tableau (Tri \u00e0 Bulles)","text":"<p>Objectif : Impl\u00e9menter un algorithme de tri simple, un classique de l'informatique.  </p> <p>Description : Le tri \u00e0 bulles consiste \u00e0 parcourir un tableau plusieurs fois. \u00c0 chaque passage, on compare les \u00e9l\u00e9ments adjacents (l'\u00e9l\u00e9ment <code>i</code> et <code>i+1</code>) et on les \u00e9change s'ils sont dans le mauvais ordre. On r\u00e9p\u00e8te ces passages jusqu'\u00e0 ce que le tableau soit tri\u00e9. 1.  Dans <code>main</code>, d\u00e9clarez un tableau non tri\u00e9 : <code>int tableau[] {5, 1, 4, 2, 8, 3};</code>. 2.  Cr\u00e9ez une fonction <code>void tri_a_bulles(int tableau[], int taille)</code>. 3.  Dans cette fonction, impl\u00e9mentez l'algorithme :     -   Vous aurez besoin d'une boucle <code>for</code> imbriqu\u00e9e dans une autre.     -   La boucle externe contr\u00f4le le nombre de passages.     -   La boucle interne parcourt le tableau et compare les paires d'\u00e9l\u00e9ments.     -   Si <code>tableau[j]</code> est plus grand que <code>tableau[j+1]</code>, vous devez les \u00e9changer. Pour cela, vous pouvez utiliser une fonction <code>void echange(int&amp; a, int&amp; b)</code> que vous \u00e9crirez \u00e9galement (revoyez le passage par r\u00e9f\u00e9rence !). 4.  Dans <code>main</code>, affichez le tableau, appelez la fonction de tri, puis affichez \u00e0 nouveau le tableau pour montrer qu'il est maintenant tri\u00e9.  </p> <p>Concepts Pratiqu\u00e9s : - Algorithme de tri. - Boucles imbriqu\u00e9es. - Modification en place d'un tableau. - Fonction utilitaire (helper function) avec passage par r\u00e9f\u00e9rence.  </p>"},{"location":"exercices/semaine_1_2_exercices_supplementaires/#exercice-10-fusion-de-tableaux-tries","title":"Exercice 10 : Fusion de Tableaux Tri\u00e9s","text":"<p>Objectif : Manipuler plusieurs tableaux et g\u00e9rer plusieurs index simultan\u00e9ment.  </p> <p>Description : C'est une \u00e9tape cl\u00e9 de l'algorithme de \"tri fusion\" (merge sort). 1.  Dans <code>main</code>, d\u00e9clarez deux tableaux d\u00e9j\u00e0 tri\u00e9s :     -   <code>int tab1[] {10, 30, 50, 70};</code>     -   <code>int tab2[] {20, 40, 60};</code> 2.  Cr\u00e9ez une fonction <code>void fusionner(const int tab1[], int taille1, const int tab2[], int taille2, int resultat[])</code>. 3.  Cette fonction re\u00e7oit les deux tableaux sources et un troisi\u00e8me tableau <code>resultat</code> (qui doit \u00eatre assez grand pour contenir tous les \u00e9l\u00e9ments). Elle doit remplir <code>resultat</code> en piochant intelligemment dans <code>tab1</code> et <code>tab2</code> pour que <code>resultat</code> soit aussi tri\u00e9.     -   Indice : Vous aurez besoin de trois variables d'index : une pour votre position dans <code>tab1</code>, une pour <code>tab2</code>, et une pour <code>resultat</code>. 4.  Dans <code>main</code>, d\u00e9clarez un tableau <code>resultat</code> de la bonne taille, appelez votre fonction, puis affichez le tableau <code>resultat</code> pour v\u00e9rifier le travail. Le r\u00e9sultat attendu est <code>{10, 20, 30, 40, 50, 60, 70}</code>.  </p> <p>Concepts Pratiqu\u00e9s : - Algorithme de fusion. - Gestion de plusieurs index. - Utilisation d'un tableau comme \"param\u00e8tre de sortie\" (le tableau <code>resultat</code> est modifi\u00e9).  </p>"},{"location":"notes/semaine_1_0_introduction/","title":"Notes de la Semaine 1","text":""},{"location":"notes/semaine_1_0_introduction/#sujets-abordes","title":"Sujets Abord\u00e9s","text":"<ul> <li>Pr\u00e9sentation du cours</li> <li>Environnement de d\u00e9veloppement C++ (IDE, compilateur)</li> <li>Concepts de base du C++ (variables, types, op\u00e9rateurs)</li> </ul>"},{"location":"notes/semaine_1_0_introduction/#exercices-et-laboratoires","title":"Exercices et Laboratoires","text":"<ul> <li>Configuration de l'environnement</li> <li>Premiers programmes \"Hello World\"</li> </ul>"},{"location":"notes/semaine_1_0_introduction/#remarques","title":"Remarques","text":"<ul> <li>Assurez-vous que votre environnement de d\u00e9veloppement est fonctionnel avant le prochain cours.</li> <li>Consultez le plan de cours pour les lectures et pr\u00e9parations.</li> </ul>"},{"location":"notes/semaine_1_0_introduction/#la-fonction-main-en-c","title":"La fonction <code>main()</code> en C++","text":"<p>La fonction <code>main()</code> est le point d'entr\u00e9e de chaque programme C++. C'est l\u00e0 que l'ex\u00e9cution de votre code commence.</p>"},{"location":"notes/semaine_1_0_introduction/#main-sans-arguments","title":"<code>main()</code> sans arguments","text":"<p>La forme la plus simple de <code>main()</code> ne prend pas d'arguments. <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Bonjour !\" &lt;&lt; std::endl;\n    return 0; // Indique que le programme s'est ex\u00e9cut\u00e9 avec succ\u00e8s\n}\n</code></pre></p>"},{"location":"notes/semaine_1_0_introduction/#return-int-vs-void-main-c","title":"<code>return int</code> vs <code>void Main</code> (C#)","text":"<p>Contrairement \u00e0 C# o\u00f9 la fonction <code>Main</code> peut \u00eatre <code>void</code>, la fonction <code>main()</code> en C++ doit retourner un <code>int</code>.</p> <ul> <li><code>return 0;</code> : Conventionnellement, un retour de <code>0</code> indique que le programme s'est termin\u00e9 avec succ\u00e8s.</li> <li><code>return un_nombre_non_nul;</code> : Un retour diff\u00e9rent de <code>0</code> (ex: <code>1</code>) indique qu'une erreur s'est produite. Ce code peut \u00eatre utilis\u00e9 par d'autres programmes ou scripts pour d\u00e9tecter un probl\u00e8me.</li> </ul>"},{"location":"notes/semaine_1_0_introduction/#entrees-et-sorties-en-c-avec-iostream","title":"Entr\u00e9es et Sorties en C++ avec <code>iostream</code>","text":"<p>La m\u00e9thode standard et s\u00e9curitaire pour g\u00e9rer les entr\u00e9es et sorties en C++ est la biblioth\u00e8que <code>&lt;iostream&gt;</code>. Elle utilise des flux (<code>streams</code>) pour envoyer ou recevoir des donn\u00e9es.</p> <ul> <li><code>std::cout</code> : Flux de sortie standard (g\u00e9n\u00e9ralement la console).</li> <li><code>std::cin</code> : Flux d'entr\u00e9e standard (g\u00e9n\u00e9ralement le clavier).</li> <li><code>std::endl</code> : Ins\u00e8re un retour \u00e0 la ligne (<code>\\n</code>) et vide le tampon de sortie.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string nom;\n    std::cout &lt;&lt; \"Entrez votre nom : \";\n    std::cin &gt;&gt; nom;\n\n    std::cout &lt;&lt; \"Bonjour \" &lt;&lt; nom &lt;&lt; \" !\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_0_introduction/#piege-n1-melanger-cin-et-getline","title":"Pi\u00e8ge n\u00b01 : M\u00e9langer <code>cin &gt;&gt;</code> et <code>getline</code>","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> lit les donn\u00e9es jusqu'au premier espace blanc (espace, tabulation, retour \u00e0 la ligne). Le reste, y compris le <code>\\n</code> que vous tapez avec <code>Entr\u00e9e</code>, reste dans le buffer (tampon) d'entr\u00e9e.</p> <p>\u274c Code probl\u00e9matique : <pre><code>int age;\nstd::string nom_complet;\n\nstd::cout &lt;&lt; \"Entrez votre age : \";\nstd::cin &gt;&gt; age; // L'utilisateur tape \"25\" puis \"Entr\u00e9e\".\n                 // \"25\" est lu, mais \"\\n\" reste dans le buffer.\n\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // getline() voit le \"\\n\" restant et croit\n                                     // que l'utilisateur a d\u00e9j\u00e0 entr\u00e9 une ligne vide.\n                                     // Il ne demande pas d'input.\n\nstd::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;\n// Affiche : Age: 25, Nom: ''\n</code></pre></p> <p>\u2705 Solution : Vider le buffer avant <code>getline</code> On utilise <code>std::cin.ignore()</code> pour ignorer les caract\u00e8res restants dans le buffer, notamment le <code>\\n</code>.</p> <pre><code>// ... apr\u00e8s std::cin &gt;&gt; age;\nstd::cin.ignore(); // Ignore LE caract\u00e8re suivant. Soit le \\n restant\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // Fonctionne comme pr\u00e9vu\n</code></pre>"},{"location":"notes/semaine_1_0_introduction/#piege-n2-erreur-de-type-lettres-pour-un-nombre","title":"Pi\u00e8ge n\u00b02 : Erreur de type (lettres pour un nombre)","text":"<p>Si l'utilisateur entre des lettres alors que <code>std::cin &gt;&gt;</code> s'attend \u00e0 un <code>int</code>, le flux <code>cin</code> entre en \u00e9tat d'erreur (<code>failbit</code>). Toute tentative de lecture ult\u00e9rieure \u00e9chouera tant que l'erreur n'est pas corrig\u00e9e et le buffer vid\u00e9.</p> <p>Pour g\u00e9rer robustement les erreurs de saisie :</p> <ol> <li>V\u00e9rifier l'\u00e9tat de <code>cin</code> : Boucler tant que la lecture \u00e9choue.</li> <li>Nettoyer les indicateurs d'erreur : <code>std::cin.clear()</code> r\u00e9initialise l'\u00e9tat de <code>cin</code>.</li> <li>Vider le buffer : <code>std::cin.ignore(...)</code> jette le contenu invalide.</li> </ol> <p>\u2705 Solution robuste :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt; // Requis pour numeric_limits\n\nint main() {\n    int age = 0;\n\n    // Boucle tant que l'entr\u00e9e est invalide\n    while (true) {\n        std::cout &lt;&lt; \"Veuillez entrer votre age : \";\n        std::cin &gt;&gt; age;\n\n        if (std::cin.good()) {\n            // La saisie est un nombre valide, on peut sortir de la boucle.\n            break; \n        }\n\n        // Si on arrive ici, la saisie a \u00e9chou\u00e9.\n        std::cout &lt;&lt; \"Erreur : Veuillez entrer un nombre valide.\" &lt;&lt; std::endl;\n\n        // 1. Nettoyer l'indicateur d'erreur de cin\n        std::cin.clear();\n\n        // 2. Vider le buffer d'entr\u00e9e\n        // On ignore tous les caract\u00e8res jusqu'\u00e0 la prochaine fin de ligne '\\n'.\n        // C'est la mani\u00e8re idiomatique et s\u00e9curitaire de le faire.\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    }\n\n    std::cout &lt;&lt; \"Vous avez \" &lt;&lt; age &lt;&lt; \" ans.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Attention aux Nombres Magiques</p> <p>Vous verrez parfois <code>std::cin.ignore(10000, '\\n');</code>. C'est une mauvaise pratique. On suppose arbitrairement que l'utilisateur ne tapera pas plus de 10 000 caract\u00e8res invalides. </p> <p>La m\u00e9thode correcte, <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');</code>, est la fa\u00e7on C++ standard de dire \"ignorer autant de caract\u00e8res que n\u00e9cessaire\". Elle ne repose sur aucune supposition.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/","title":"Les Types de Donn\u00e9es Fondamentaux","text":"<p>Voici la liste des types fondamentaux \u00e0 utiliser en C++.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/#1-types-entiers-et-logiques","title":"1. Types Entiers et Logiques","text":"<p>Utilis\u00e9s pour compter, indexer ou g\u00e9rer des \u00e9tats.</p> Type Taille Description Plage de Valeurs (Min / Max) <code>bool</code> 1 octet Logique pure <code>true</code> (1) ou <code>false</code> (0) <code>int</code> 4 octets Entier standard (Sign\u00e9) -2 147 483 648 \u00e0 +2 147 483 647 <code>unsigned int</code> 4 octets Entier positif 0 \u00e0 4 294 967 295 <code>long long</code> 8 octets Grand entier (Sign\u00e9) -9 Quintillions \u00e0 +9 Quintillions"},{"location":"notes/semaine_1_1_types_de_donnees/#2-types-de-caracteres","title":"2. Types de Caract\u00e8res","text":"<p>Un <code>char</code> fait 1 octet (8 bits).</p> Type Usage Recommand\u00e9 <code>char</code> Texte ASCII standard. (Lettres simples). <code>char8_t</code> Texte UTF-8 (C++20). Cha\u00eenes <code>u8\"...\"</code>."},{"location":"notes/semaine_1_1_types_de_donnees/#3-types-a-virgule-flottante","title":"3. Types \u00e0 Virgule Flottante","text":"<p>Utilis\u00e9s pour les nombres \u00e0 d\u00e9cimales (r\u00e9els).</p> Type Taille Pr\u00e9cision <code>double</code> 8 octets Standard (~15 chiffres) <code>float</code> 4 octets Faible (~7 chiffres)"},{"location":"notes/semaine_1_1_types_de_donnees/#4-initialisation-des-variables-c20","title":"4. Initialisation des Variables (C++20)","text":"<p>Privil\u00e9giez l'initialisation avec des accolades <code>{}</code> pour \u00e9viter les conversions dangereuses.</p> <p>Syntaxe : <code>Type nom { valeur };</code></p> Exemple Correct Pourquoi ? <code>int age { 25 };</code> Initialise <code>age</code> \u00e0 25. <code>double prix { 19.99 };</code> Initialise <code>prix</code> \u00e0 19.99. <code>int x {};</code> Initialise <code>x</code> \u00e0 0. <p>Protection contre les erreurs : <pre><code>int a = 3.9;  // \u26a0\ufe0f DANGEREUX : Compile, mais 'a' vaut 3 (perte de 0.9).\nint b { 3.9 }; // \ud83d\uded1 ERREUR : Le compilateur refuse de perdre des donn\u00e9es.\n</code></pre></p>"},{"location":"notes/semaine_1_1_types_de_donnees/#5-manipulation-des-chaines-de-caracteres-en-c","title":"5. Manipulation des Cha\u00eenes de Caract\u00e8res en C++","text":"<p>En C++, le texte ne se g\u00e8re pas avec des tableaux de <code>char</code> (trop dangereux), mais avec la classe standard <code>std::string</code>.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/#les-bases-de-stdstring","title":"Les Bases de <code>std::string</code>","text":"<p>Pour utiliser les cha\u00eenes, vous devez inclure <code>&lt;string&gt;</code>.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt; // Indispensable\n\nint main() {\n    // 1. D\u00e9claration et Initialisation\n    std::string nom { \"Mario\" };\n    std::string salutation { \"Bonjour\" };\n\n    // 2. Concat\u00e9nation (Coller des morceaux)\n    // On utilise simplement le signe '+'\n    std::string message = salutation + \" \" + nom + \" !\"; \n    // R\u00e9sultat : \"Bonjour Mario !\"\n\n    // 3. Acc\u00e8s aux lettres\n    char premiereLettre = nom[0]; // 'M'\n    nom[0] = 'W'; // Mario devient Wario\n}\n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#operations-courantes","title":"Op\u00e9rations Courantes","text":"<p>Voici les m\u00e9thodes que vous utiliserez dans 90% des cas avec <code>std::string</code>.</p> Op\u00e9ration M\u00e9thode Exemple R\u00e9sultat Longueur <code>.size()</code> ou <code>.length()</code> <code>nom.size()</code> <code>5</code> (nombre d'octets) Vide ? <code>.empty()</code> <code>nom.empty()</code> <code>false</code> (si contient du texte) Vider <code>.clear()</code> <code>nom.clear()</code> La cha\u00eene devient vide <code>\"\"</code> Ajouter <code>+=</code> ou <code>.append()</code> <code>nom += \" Bros\"</code> <code>\"Mario Bros\"</code> Comparer <code>==</code> ou <code>!=</code> <code>nom == \"Luigi\"</code> <code>false</code> Trouver <code>.find(\"texte\")</code> <code>msg.find(\"jour\")</code> Retourne l'index ou <code>std::string::npos</code> si absent. Sous-cha\u00eene <code>.substr(pos, len)</code> <code>msg.substr(0, 3)</code> Extrait une partie du texte (ex: les 3 premi\u00e8res lettres)."},{"location":"notes/semaine_1_1_types_de_donnees/#copier-et-extraire-des-sous-chaines","title":"Copier et Extraire des Sous-Cha\u00eenes","text":"<p>Copie Compl\u00e8te L'assignation <code>=</code> cr\u00e9e une copie enti\u00e8rement nouvelle et ind\u00e9pendante.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;format&gt; // N\u00e9cessaire pour std::format\n\nint main() {\n    std::string original {\"Bonjour le monde\"};\n    std::string copie {original}; // Cr\u00e9e une copie compl\u00e8te\n\n    // Modifier la copie n'affecte pas l'original\n    copie[0] = 'A';\n\n    std::cout &lt;&lt; std::format(\"Original : {}\\n\", original); // Affiche \"Bonjour le monde\"\n    std::cout &lt;&lt; std::format(\"Copie    : {}\\n\", copie);    // Affiche \"Aonjour le monde\"\n    return 0;\n}\n</code></pre> <p>Copie d'une Sous-Cha\u00eene (<code>.substr()</code>) La m\u00e9thode <code>.substr(position_depart, longueur)</code> extrait une partie de la cha\u00eene et en retourne une nouvelle copie.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string phrase {\"Le C++ est fantastique\"};\n\n    // Extrait 3 caract\u00e8res \u00e0 partir de l'index 3\n    std::string mot_cpp {phrase.substr(3, 3)}; \n\n    // Extrait tout le reste \u00e0 partir de l'index 12\n    std::string mot_fantastique {phrase.substr(12)}; \n\n    std::cout &lt;&lt; \"Mot 1: \" &lt;&lt; mot_cpp &lt;&lt; std::endl; // Affiche \"C++\"\n    std::cout &lt;&lt; \"Mot 2: \" &lt;&lt; mot_fantastique &lt;&lt; std::endl; // Affiche \"fantastique\"\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#le-defi-des-accents-stdstring-vs-stdwstring","title":"Le D\u00e9fi des Accents : <code>std::string</code> vs <code>std::wstring</code>","text":"<p>G\u00e9rer les accents en C++ est complexe car <code>std::string</code> a \u00e9t\u00e9 con\u00e7u pour l'anglais. Pour C++, une cha\u00eene n'est pas une liste de lettres, c'est une liste d'octets. Avec l'encodage moderne (UTF-8), un caract\u00e8re accentu\u00e9 (<code>\u00e9</code>) p\u00e8se plusieurs octets.</p> <p>Cons\u00e9quence : Si vous prenez le mot <code>\"\u00e9t\u00e9\"</code>, C++ voit 5 octets (2 pour le <code>\u00e9</code>, 1 pour le <code>t</code>, 2 pour le <code>\u00e9</code>). *   <code>\"\u00e9t\u00e9\".size()</code> renverra <code>5</code>. *   <code>.substr(1, 1)</code> tentera de couper un caract\u00e8re au milieu d'un octet, produisant un r\u00e9sultat corrompu.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/#la-solution-simple-pour-ce-cours-stdwstring","title":"La Solution Simple (pour ce cours) : <code>std::wstring</code>","text":"<p>Bien que ce ne soit pas la solution universelle dans le monde professionnel (pour des raisons de portabilit\u00e9), <code>std::wstring</code> est la mani\u00e8re la plus simple de manipuler des cha\u00eenes avec accents dans nos exercices. Chaque caract\u00e8re, accentu\u00e9 ou non, y occupe une seule \"case\".</p> <p>Configurer la console pour les <code>wchar_t</code></p> <p>Pour que la console affiche correctement les caract\u00e8res larges, il faut inclure <code>&lt;locale&gt;</code>, utiliser le pr\u00e9fixe <code>L\"\"</code> pour vos cha\u00eenes, et <code>std::wcout</code> pour l'affichage.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;locale&gt; // Pour setlocale\n\nint main() {\n    // 1. Configure la locale pour permettre l'affichage des caract\u00e8res larges\n    std::setlocale(LC_ALL, \"\");\n\n    // 2. On utilise wstring et le pr\u00e9fixe L\"\"\n    std::wstring ws = L\"\u00e9t\u00e9\";\n\n    // 3. substr() fonctionne maintenant logiquement\n    // On veut le 2\u00e8me caract\u00e8re, qui est bien \u00e0 l'index 1.\n    std::wstring sub = ws.substr(1, 1); \n\n    // 4. On utilise wcout pour afficher des wstring\n    std::wcout &lt;&lt; L\"La sous-chaine de '\u00e9t\u00e9' (pos 1, len 1) est : '\" &lt;&lt; sub &lt;&lt; L\"'\" &lt;&lt; std::endl; // Affiche 't'\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#decouper-une-chaine-equivalent-de-split","title":"D\u00e9couper une Cha\u00eene (\u00c9quivalent de <code>.split()</code>)","text":"<p><code>std::string</code> n'a pas de m\u00e9thode <code>.split()</code> int\u00e9gr\u00e9e. La technique standard est d'utiliser un outil tr\u00e8s puissant de la biblioth\u00e8que <code>&lt;sstream&gt;</code> : le <code>std::stringstream</code>.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/#focus-sur-stdstringstream-un-stdcin-pour-vos-chaines","title":"Focus sur <code>std::stringstream</code> : Un <code>std::cin</code> pour vos Cha\u00eenes","text":"<p>Imaginez que votre cha\u00eene de caract\u00e8res est un long ruban de machine \u00e0 \u00e9crire. Le <code>stringstream</code> est la t\u00eate de lecture pos\u00e9e sur ce ruban.</p> <pre><code>#include &lt;sstream&gt; // Indispensable\n\nstd::string ma_chaine = \"mot1 mot2 mot3\";\n\n// On charge notre \"ruban\" (la cha\u00eene) dans la t\u00eate de lecture.\n// Un curseur de lecture invisible est automatiquement plac\u00e9 au tout d\u00e9but.\nstd::stringstream flux {ma_chaine}; \n</code></pre> <ul> <li>Comme un buffer d'entr\u00e9e : Le <code>stringstream</code> se comporte exactement comme <code>std::cin</code>. Vous pouvez lire des donn\u00e9es avec l'op\u00e9rateur <code>&gt;&gt;</code> ou avec la fonction <code>std::getline</code>.</li> <li>Curseur interne : \u00c0 chaque op\u00e9ration de lecture, le curseur avance sur le \"ruban\". Si vous lisez <code>\"mot1\"</code>, le curseur se place juste apr\u00e8s, pr\u00eat \u00e0 lire <code>\"mot2\"</code>. Le flux \"d\u00e9file\" \u00e0 mesure que vous le lisez.</li> <li>Repositionnement (<code>seek</code>) : Il est m\u00eame possible de manipuler ce curseur, de le remettre au d\u00e9but (<code>flux.seekg(0)</code>) ou d'aller \u00e0 une position pr\u00e9cise, un peu comme on rembobine une cassette (m\u00eame si c'est un usage plus avanc\u00e9).</li> </ul> <p>C'est cet objet qui nous permet de \"parcourir\" une cha\u00eene pour en extraire des morceaux s\u00e9quentiellement.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/#methode-1-decouper-selon-les-espaces","title":"M\u00e9thode 1 : D\u00e9couper selon les espaces","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> extrait des \"mots\" en s'arr\u00eatant \u00e0 n'importe quel \"espace blanc\" (espace, tabulation, retour \u00e0 la ligne).</p> <pre><code>#include &lt;sstream&gt; \n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nstd::string phrase {\"J'aime\\tle C++\\nmoderne\"};\nstd::stringstream flux {phrase};\nstd::string mot;\n\nwhile (flux &gt;&gt; mot) {\n    // La boucle extrait \"J'aime\", puis \"le\", \"C++\", et \"moderne\"\n    std::cout &lt;&lt; \"- \" &lt;&lt; mot &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"notes/semaine_1_1_types_de_donnees/#methode-2-decouper-selon-un-delimiteur-specifique","title":"M\u00e9thode 2 : D\u00e9couper selon un d\u00e9limiteur sp\u00e9cifique","text":"<p>Pour d\u00e9couper selon un caract\u00e8re pr\u00e9cis (ex: une virgule), on utilise <code>std::getline</code> avec le flux.</p> <p>Recette : 1.  Cr\u00e9ez un <code>stringstream</code> \u00e0 partir de la cha\u00eene source. 2.  Cr\u00e9ez une <code>std::string</code> temporaire pour chaque morceau (\"segment\"). 3.  Utilisez une boucle <code>while (std::getline(mon_flux, segment, 'DELIMITEUR'))</code>.</p>"},{"location":"notes/semaine_1_1_types_de_donnees/#exemple-pratique-sommer-des-nombres-dans-une-chaine","title":"Exemple Pratique : Sommer des Nombres dans une Cha\u00eene","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n\nint main() {\n    std::string data {\"10,20,30,40,50\"};\n    std::stringstream ss {data};\n    std::string segment;\n    int somme {0};\n\n    // 1. On boucle sur le flux, en utilisant la virgule ',' comme d\u00e9limiteur.\n    while(std::getline(ss, segment, ',')) {\n        // segment contient successivement \"10\", puis \"20\", ...\n\n        // 2. On convertit le segment (string) en entier.\n        int nombre { std::stoi(segment) };\n\n        // 3. On l'ajoute \u00e0 la somme.\n        somme += nombre;\n    }\n\n    std::cout &lt;&lt; \"La somme finale est : \" &lt;&lt; somme &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> <p>Que signifie <code>std::stoi</code> ?</p> <p><code>stoi</code> est l'abr\u00e9viation de String To Integer (cha\u00eene vers entier). C'est une fonction de la biblioth\u00e8que <code>&lt;string&gt;</code> qui analyse une cha\u00eene de caract\u00e8res et retourne sa repr\u00e9sentation num\u00e9rique en tant qu'<code>int</code>. Il existe des fonctions similaires pour d'autres types, comme <code>stod</code> (String To Double).</p>"},{"location":"notes/semaine_1_2_tableau/","title":"4. Les Tableaux Bruts (Static Arrays)","text":"<p>C'est la forme la plus primitive de stockage. Un tableau brut est une suite de cases m\u00e9moire coll\u00e9es les unes aux autres.</p>"},{"location":"notes/semaine_1_2_tableau/#declaration-et-memoire","title":"D\u00e9claration et M\u00e9moire","text":"<p>Il faut imp\u00e9rativement conna\u00eetre la taille \u00e0 la compilation. Une fois cr\u00e9\u00e9, le tableau ne peut jamais changer de taille.</p> <pre><code>// Syntaxe : Type nom[Taille];\n\nint scores[5]; // R\u00e9serve 5 entiers (valeurs al\u00e9atoires si non initialis\u00e9 !)\n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#initialisation","title":"Initialisation","text":"<p>On utilise les accolades <code>{}</code>.</p> Syntaxe R\u00e9sultat <code>int t[3] { 10, 20, 30 };</code> Tableau rempli : <code>[10, 20, 30]</code> <code>int t[5] { 10, 20 };</code> Reste rempli de z\u00e9ros : <code>[10, 20, 0, 0, 0]</code> <code>int t[10] {};</code> Tout \u00e0 z\u00e9ro : <code>[0, 0, ... 0]</code> (Recommand\u00e9) <code>int t[] { 1, 2, 3 };</code> Taille auto-d\u00e9duite (ici 3 cases)."},{"location":"notes/semaine_1_2_tableau/#acces-et-danger","title":"Acc\u00e8s et Danger \ud83d\udc80","text":"<p>On acc\u00e8de aux \u00e9l\u00e9ments via l'index [i] (commence \u00e0 0). <pre><code>scores[0] = 100; // Premi\u00e8re case\nscores[4] = 50;  // Derni\u00e8re case (pour taille 5)\n</code></pre></p> <p>Pas de garde-fou ! C++ ne v\u00e9rifie pas si vous d\u00e9passez le tableau.</p> <pre><code>int t[3] {1, 2, 3};\nt[100] = 99; // \ud83d\udca5 \u00c9crit n'importe o\u00f9 dans la RAM.\n             // Peut faire crasher le programme ou corrompre d'autres variables.\n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#tableaux-bruts-et-fonctions","title":"Tableaux Bruts et Fonctions","text":"<p>C'est ici que \u00e7a se corse. En C++, on ne peut pas passer un tableau brut \"en entier\" \u00e0 une fonction comme on passerait un entier.</p>"},{"location":"notes/semaine_1_2_tableau/#le-piege-du-decay-degenerescence","title":"Le Pi\u00e8ge du \"Decay\" (D\u00e9g\u00e9n\u00e9rescence)","text":"<p>Quand vous passez un tableau \u00e0 une fonction, il \"perd\" son identit\u00e9 de tableau et se transforme en simple adresse m\u00e9moire (pointeur) vers la premi\u00e8re case.</p> <p>Cons\u00e9quence grave</p> <p>La fonction ne conna\u00eet pas la taille du tableau ! Le lien avec la taille d'origine est perdu. La fonction re\u00e7oit juste l'adresse du d\u00e9but, mais elle ne sait pas o\u00f9 \u00e7a s'arr\u00eate.</p>"},{"location":"notes/semaine_1_2_tableau/#la-bonne-facon-de-faire","title":"La Bonne Fa\u00e7on de Faire","text":"<p>Pour compenser cette perte d'information, vous devez toujours envoyer la taille du tableau manuellement dans un deuxi\u00e8me param\u00e8tre.</p> <pre><code>// \u274c MAUVAIS : La fonction ne sait pas quand s'arr\u00eater\nvoid afficher(int tab[]) { \n    // Impossible de savoir combien d'\u00e9l\u00e9ments il y a ici !\n}\n\n// \u2705 BON : On passe le tableau ET sa taille\nvoid afficher(int tab[], int taille) {\n    for (int i = 0; i &lt; taille; i++) {\n        std::cout &lt;&lt; tab[i] &lt;&lt; \" \";\n    }\n}\n\nint main() {\n    int mesNotes[4] { 10, 15, 20, 12 };\n\n    // Appel : On donne le tableau et le nombre 4\n    afficher(mesNotes, 4); \n}\n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#problematique-au-niveau-de-la-taille","title":"Probl\u00e9matique au niveau de la taille","text":"<p>La probl\u00e9matique se situe au niveau du \"4\" comment faire pour trouver la taille du tableau.  </p>"},{"location":"notes/semaine_1_2_tableau/#comment-trouver-la-taille-automatiquement-c17-c20","title":"Comment trouver la taille automatiquement (C++17 / C++20)","text":"<p>Plus besoin de compter \u00e0 la main ou de faire des divisions de <code>sizeof</code>. Il faut inclure <code>&lt;iterator&gt;</code> (ou <code>&lt;vector&gt;</code>/<code>&lt;array&gt;</code>).</p> Commande Version Description <code>std::size(tab)</code> C++17 Retourne la taille en non-sign\u00e9 (<code>unsigned</code>). <code>std::ssize(tab)</code> C++20 Retourne la taille en sign\u00e9 (<code>signed</code>). Recommand\u00e9 pour les boucles avec <code>int i</code>."},{"location":"notes/semaine_1_2_tableau/#determiner-la-taille-dun-tableau-localement","title":"D\u00e9terminer la taille d'un tableau (localement)","text":"<p>La m\u00e9thode C++20 recommand\u00e9e est <code>std::ssize()</code> (de la biblioth\u00e8que <code>&lt;iterator&gt;</code>).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nint main() {\n    int notes_cours[] {80, 85, 90, 75, 88};\n    int taille {std::ssize(notes_cours)}; \n    std::cout &lt;&lt; \"La taille du tableau est : \" &lt;&lt; taille &lt;&lt; std::endl; // Affiche 5\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#quel-type-utiliser-pour-la-taille-analyse","title":"Quel type utiliser pour la taille ? (Analyse)","text":"<p>Le choix du type pour la <code>taille</code> est un compromis entre simplicit\u00e9, s\u00e9curit\u00e9 et portabilit\u00e9. Le fichier d'exemple ci-dessous (que vous pouvez t\u00e9l\u00e9charger et compiler) d\u00e9montre plusieurs approches.</p> Fichier d'exemple : <code>exemple_types_taille.cpp</code> <pre><code>/**\n * @file main.cpp\n * @brief Fichier d'exemple pour d\u00e9montrer les diff\u00e9rentes mani\u00e8res de passer la taille\n *        d'un tableau \u00e0 une fonction en C++, en soulignant les avantages et les risques\n *        de chaque approche.\n */\n\n#include &lt;iostream&gt;\n#include &lt;iterator&gt; // Pour std::ssize\n#include &lt;cstddef&gt;  // Pour std::ptrdiff_t\n\n\n\n/**\n * @brief APPROCHE 1 : Utilise 'int' pour la taille.\n * @note Cette version est **risqu\u00e9e** pour des applications g\u00e9n\u00e9rales. Un `int` (32 bits)\n *       est trop petit pour contenir la taille d'un tr\u00e8s grand tableau, menant \u00e0 des bogues.\n *       Pour des exercices simples, c'est souvent acceptable.\n */\nvoid afficher_moyenne_risque(const int notes[], int taille) {\n    std::cout &lt;&lt; \"[int] Appel a la fonction risquee...\" &lt;&lt; std::endl;\n}\n\n\n/**\n * @brief APPROCHE 2 : Utilise 'long long' pour la taille.\n * @note L'utilisation de `long long` est un choix simple et s\u00fbr sur la plupart des \n *       syst\u00e8mes 64-bit, car il est garanti d'\u00eatre assez grand.\n */\nvoid afficher_moyenne_long(const int notes[], long long taille) {\n    if (taille &lt;= 0) return;\n    double somme {0.0};\n    for (long long i {0}; i &lt; taille; ++i) { \n        somme += notes[i];\n    }\n    std::cout &lt;&lt; \"[long long] La moyenne est : \" &lt;&lt; somme / taille &lt;&lt; std::endl;\n}\n\n\n/**\n * @brief APPROCHE 3 : Utilise 'std::ptrdiff_t' pour la taille.\n * @note Cette version est la plus **techniquement correcte et portable**. `std::ptrdiff_t` est le \n *       type sign\u00e9 que `std::ssize` retourne. Il est garanti d'\u00eatre assez grand\n *       sur n'importe quelle plateforme.\n */\nvoid afficher_moyenne_semi_pro(const int notes[], std::ptrdiff_t taille) {\n    std::cout &lt;&lt; \"[ptrdiff_t] Appel a la fonction semi-pro...\" &lt;&lt; std::endl;\n}\n\n/**\n * @brief APPROCHE 4 : Utilise un template de fonction (C++20).\n * @note L'utilisation de `auto` dans un param\u00e8tre est une fonctionnalit\u00e9 C++20\n *       qui cr\u00e9e un \"template\". C'est tr\u00e8s flexible, mais moins explicite.\n */\nvoid afficher_moyenne_moderne(const int notes[], auto taille)\n{\n    std::cout &lt;&lt; \"[auto] Appel moderne qui redirige vers la version 'long long'.\" &lt;&lt; std::endl;\n    afficher_moyenne_long(notes, taille);\n}\n\nint main() {\n    int notes_cours[] {80, 85, 90, 75, 88};\n\n    // On utilise std::ssize (C++20) pour obtenir la taille de mani\u00e8re s\u00fbre.\n    // std::ssize retourne un type sign\u00e9 (std::ptrdiff_t).\n    auto taille_notes { std::ssize(notes_cours) };\n\n    std::cout &lt;&lt; \"--- Affichage des moyennes ---\" &lt;&lt; std::endl;\n\n    // Appel \u00e0 la version `long long`. C'est un bon compromis entre simplicit\u00e9 et s\u00e9curit\u00e9.\n    afficher_moyenne_long(notes_cours, taille_notes);\n\n    // Appel \u00e0 la version C++20 avec `auto`.\n    afficher_moyenne_moderne(notes_cours, taille_notes);\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_2_tableau/#le-bordel-quoi","title":"Le bordel quoi !?","text":"<p>En effet. Ceci \u00e9tant dit !</p> <p>Il existe une solution qui modernise le c++ et qui va nous \u00eatre utile avec plein d'autres cas. On utilise std::span qui permet de conserver la taille du tableau au travers du passage de param\u00e8tre. La variable contient \"grosso-modo\" la taille et le pointeur de d\u00e9but du tableau.</p> <p>C'est un pointeur \"gras\" </p> <pre><code>// Repr\u00e9sentation mentale simplifi\u00e9e\ntemplate &lt;typename T&gt;\nstruct Span {\n    T* pointeur;   // L'adresse du d\u00e9but des donn\u00e9es (8 octets sur 64-bit)\n    size_t taille; // Le nombre d'\u00e9l\u00e9ments (8 octets sur 64-bit)\n};\n</code></pre> <p>Avantage, le span peut \u00eatre utilis\u00e9 avec des tableaux standards vanille, des array de la biblioth\u00e8que standard et des vectors</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;span&gt;   // \ud83d\udc48 Obligatoire (C++20)\n#include &lt;vector&gt;\n#include &lt;array&gt;\n\n// 1. La fonction prend un \"span\" (une vue)\n// const int : on lit seulement (lecture seule)\nvoid afficher(std::span&lt;const int&gt; donnees) {\n    std::cout &lt;&lt; \"[ \";\n    // Le span conna\u00eet sa taille et permet le foreach !\n    for (int valeur : donnees) {\n        std::cout &lt;&lt; valeur &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; \"] (Taille: \" &lt;&lt; donnees.size() &lt;&lt; \")\\n\";\n}\n\nint main() {\n    // Cas A : Tableau Brut (C-Style)\n    int tabC[] { 1, 2, 3 };\n\n    // Cas B : std::vector (Dynamique)\n    std::vector&lt;int&gt; vec { 10, 20, 30, 40 };\n\n    // Cas C : std::array (Fixe moderne)\n    std::array&lt;int, 2&gt; arr { 99, 100 };\n\n    // \u2728 MAGIE : La m\u00eame fonction accepte TOUT !\n    afficher(tabC); // D\u00e9duit automatiquement la taille (3)\n    afficher(vec);  // Convertit automatiquement\n    afficher(arr);  // Convertit automatiquement\n\n    return 0;\n}\n</code></pre> <p>Conclusion Finale : La R\u00e8gle d'Or (C++20)</p> <ol> <li> <p>Pour apprendre (Exercices simples) :      Passer le tableau et sa taille s\u00e9par\u00e9ment (<code>int* tab, int taille</code>) reste une bonne m\u00e9thode p\u00e9dagogique pour comprendre la m\u00e9moire.</p> </li> <li> <p>Pour le \"Vrai Monde\" (Professionnel) :     Utilisez <code>std::span</code>. C'est le standard moderne qui remplace toutes les anciennes m\u00e9thodes.</p> <ul> <li>\u274c Plus besoin de <code>void f(int* t, int size)</code></li> <li>\u274c Plus besoin de <code>void f(const std::vector&lt;int&gt;&amp; v)</code></li> <li>\u2705 Utilisez <code>void f(std::span&lt;int&gt; data)</code></li> </ul> </li> </ol>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/","title":"Entr\u00e9es Utilisateur avec <code>std::cin</code>","text":"<p>Cette section explique comment r\u00e9cup\u00e9rer des informations de l'utilisateur via la console en utilisant la biblioth\u00e8que <code>&lt;iostream&gt;</code>.</p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#1-les-bases-flux-et-buffer","title":"1. Les Bases : Flux et Buffer","text":"<p>En C++, les entr\u00e9es clavier ne vont pas directement dans vos variables. Elles passent par un flux d'entr\u00e9e (<code>std::cin</code>) et une zone d'attente appel\u00e9e le Buffer.</p> <ul> <li><code>std::cin</code> : Le flux qui lit le clavier.</li> <li>Buffer : Une salle d'attente o\u00f9 les caract\u00e8res s'empilent quand vous tapez.</li> <li><code>std::endl</code> : Pour l'affichage (<code>cout</code>), cela fait un retour \u00e0 la ligne (<code>\\n</code>) et force l'affichage imm\u00e9diat.</li> </ul>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#2-les-deux-facons-de-lire","title":"2. Les Deux Fa\u00e7ons de Lire","text":"<p>Il existe deux outils principaux selon ce que vous voulez lire.</p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#a-lire-un-mot-ou-un-nombre","title":"A. Lire un mot ou un nombre (<code>&gt;&gt;</code>)","text":"<p>L'op\u00e9rateur d'extraction <code>&gt;&gt;</code> lit des donn\u00e9es jusqu'au premier \"espace blanc\" (Espace, Tabulation, ou Entr\u00e9e).</p> <pre><code>int age;\nstd::cin &gt;&gt; age; \n// Si je tape \"25\" + Entr\u00e9e :\n// -&gt; '25' va dans la variable.\n// -&gt; '\\n' (Entr\u00e9e) RESTE dans le buffer.\n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#b-lire-une-ligne-complete-stdgetline","title":"B. Lire une ligne compl\u00e8te (<code>std::getline</code>)","text":"<p>Cette fonction lit tout jusqu'au retour \u00e0 la ligne (n). Elle est indispensable pour lire des phrases avec des espaces.  </p> <pre><code>std::string nom;\nstd::getline(std::cin, nom);\n// Elle consomme le texte ET le '\\n', puis jette le '\\n'.\n// Le buffer est propre apr\u00e8s son passage.\n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#3-le-piege-classique-melanger-et-getline","title":"3. Le Pi\u00e8ge Classique : M\u00e9langer <code>&gt;&gt;</code> et <code>getline</code> \u26a0\ufe0f","text":"<p>C'est l'erreur n\u00b01 des d\u00e9butants en C++.</p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#le-scenario","title":"Le Sc\u00e9nario","text":"<ol> <li>Vous demandez un \u00e2ge avec <code>std::cin &gt;&gt; age</code>.</li> <li>L'utilisateur tape <code>25</code> et appuie sur <code>Entr\u00e9e</code>.</li> <li><code>cin</code> extrait le nombre <code>25</code>.</li> <li>\ud83d\uded1 Probl\u00e8me : Le caract\u00e8re de saut de ligne <code>\\n</code> (correspondant \u00e0 la touche Entr\u00e9e) reste dans le buffer.</li> <li>Vous appelez <code>std::getline</code> pour demander le nom.</li> <li><code>getline</code> regarde le buffer, voit le <code>\\n</code> qui tra\u00eene imm\u00e9diatement, pense que l'utilisateur a entr\u00e9 une ligne vide, et s'arr\u00eate.</li> </ol> <p>R\u00e9sultat : Le programme \"saute\" la demande du nom et ne vous laisse rien \u00e9crire.</p> <p>Exemple du Code Probl\u00e9matique</p> <pre><code>int age;\nstd::string nom;\n\nstd::cout &lt;&lt; \"Age : \";\nstd::cin &gt;&gt; age; \n// L'utilisateur tape \"25\" + \"Entr\u00e9e\". \n// Le '\\n' reste en attente dans la m\u00e9moire.\n\nstd::cout &lt;&lt; \"Nom : \";\n// \u274c BUG : getline lit le '\\n' restant et s'arr\u00eate tout de suite.\nstd::getline(std::cin, nom); \n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#la-solution-nettoyer-le-buffer","title":"La Solution : Nettoyer le Buffer","text":"<p>Pour corriger cela, il faut ignorer le reste de la ligne (le <code>\\n</code> restant) apr\u00e8s chaque <code>cin &gt;&gt;</code> si vous comptez utiliser <code>getline</code> ensuite.</p> <p>La Correction</p> <p>Ajoutez cette ligne magique entre les deux lectures :</p> <pre><code>#include &lt;limits&gt; // N\u00e9cessaire pour numeric_limits\n\n// ...\nstd::cin &gt;&gt; age;\n\n// \ud83e\uddf9 NETTOYAGE : On ignore tout jusqu'au prochain retour \u00e0 la ligne\nstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\nstd::cout &lt;&lt; \"Nom : \";\nstd::getline(std::cin, nom); // \u2705 Fonctionne parfaitement\n</code></pre> <p>Pourquoi pas juste <code>std::cin.ignore()</code> ?</p> <p><code>std::cin.ignore()</code> tout seul n'ignore qu'un seul caract\u00e8re.</p> <p>Si l'utilisateur a tap\u00e9 <code>25 abc</code> puis <code>Entr\u00e9e</code>, il restera encore <code>bc</code> et <code>\\n</code> dans le buffer.</p> <p>La version avec <code>numeric_limits</code> est la version \"blind\u00e9e\" : elle demande d'ignorer le nombre maximum de caract\u00e8res possible jusqu'\u00e0 trouver un retour \u00e0 la ligne. C'est la seule fa\u00e7on de garantir un buffer vide.</p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#4-gestion-des-erreurs-de-saisie","title":"4. Gestion des Erreurs de Saisie","text":"<p>Que se passe-t-il si l'utilisateur fait n'importe quoi alors que vous attendez un nombre ?</p>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#cas-a-lecture-partielle-45abc","title":"Cas A : Lecture Partielle (<code>45abc</code>)","text":"<p>Si on demande un <code>int</code> et que l'utilisateur tape <code>45abc</code> :</p> <ol> <li><code>cin</code> lit <code>45</code> (\u2705 Succ\u00e8s).</li> <li><code>cin</code> s'arr\u00eate au <code>a</code> (car ce n'est pas un chiffre).</li> <li>R\u00e9sultat : La variable vaut <code>45</code>.</li> <li>\u26a0\ufe0f Probl\u00e8me : La cha\u00eene <code>abc</code> reste dans le buffer pour la prochaine lecture. Cela causera probablement une erreur au prochain <code>cin</code>.</li> </ol>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#cas-b-echec-total-abc45","title":"Cas B : \u00c9chec Total (<code>abc45</code>)","text":"<p>Si on demande un <code>int</code> et que l'utilisateur tape <code>abc45</code> :</p> <ol> <li><code>cin</code> voit <code>a</code> tout de suite.</li> <li>Il se met imm\u00e9diatement en mode Erreur (le drapeau <code>failbit</code> s'active).</li> <li>R\u00e9sultat : La variable vaut 0 (ou reste inchang\u00e9e).</li> <li>\ud83d\uded1 Danger : Tant que <code>cin</code> est en erreur (\"fail state\"), il refusera de lire quoi que ce soit d'autre. Il est \"verrouill\u00e9\".</li> </ol>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#la-solution-robuste-pattern-a-retenir","title":"La Solution Robuste (Pattern \u00e0 retenir)","text":"<p>Pour un programme solide, on utilise une boucle <code>while</code> qui v\u00e9rifie l'\u00e9tat de <code>cin</code> apr\u00e8s chaque tentative.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main() {\n    int age = 0;\n\n    std::cout &lt;&lt; \"Entrez votre age : \";\n\n    // 1. La boucle g\u00e8re L'\u00c9CHEC (Type incorrect, ex: \"abc\")\n    while (!(std::cin &gt;&gt; age)) { \n        std::cout &lt;&lt; \"Erreur, ce n'est pas un nombre. Recommencez : \";\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    }\n\n    // 2. IMPORTANT : On g\u00e8re le SUCC\u00c8S (Nettoyage final)\n    // On vide le buffer pour enlever le '\\n' restant ou les d\u00e9chets (ex: \"25abc\")\n    // afin que la suite du programme (ex: un futur getline) fonctionne.\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::cout &lt;&lt; \"Age valide : \" &lt;&lt; age &lt;&lt; \"\\n\";\n\n    // Ici, le buffer est propre, pr\u00eat pour un getline !\n}\n</code></pre>"},{"location":"notes/semaine_1_3_gestion_saisie_cin/#resume-des-commandes-de-nettoyage","title":"R\u00e9sum\u00e9 des Commandes de Nettoyage","text":"<p>Ces deux commandes fonctionnent souvent en duo dans une gestion d'erreur robuste.</p> Commande R\u00f4le <code>std::cin.clear()</code> R\u00e9parer. R\u00e9initialise les indicateurs d'erreur (comme <code>failbit</code>) pour sortir <code>cin</code> de son \u00e9tat de blocage et lui permettre de relire. <code>std::cin.ignore(MAX, '\\n')</code> Vider. Jette tout ce qui tra\u00eene encore dans le buffer (la saisie fautive + le retour \u00e0 la ligne) pour repartir sur des bases saines. <p>Note</p> <p>Dans ce tableau, <code>MAX</code> est un raccourci pour : <code>std::numeric_limits&lt;std::streamsize&gt;::max()</code>.</p>"},{"location":"notes/semaine_1_4_compilation_cpp20/","title":"Guide de Compilation en C++20","text":"<p>Ce document explique comment transformer votre code source (<code>.cpp</code>, <code>.hpp</code>) en un programme ex\u00e9cutable \u00e0 l'aide du compilateur <code>g++</code> et du standard C++20.</p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#1-quest-ce-que-la-compilation","title":"1. Qu'est-ce que la Compilation ?","text":"<p>La compilation est le processus qui traduit votre code C++, lisible par un humain, en code machine, compr\u00e9hensible par l'ordinateur. L'outil qui r\u00e9alise cette traduction est appel\u00e9 un compilateur. Dans ce cours, nous utiliserons <code>g++</code>, le compilateur C++ du projet GNU, l'un des plus populaires.</p> <p></p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#2-la-commande-de-compilation-essentielle","title":"2. La Commande de Compilation Essentielle","text":"<p>Pour compiler, vous ouvrirez un terminal (ou une console) et taperez une commande qui ressemble \u00e0 ceci :</p> <pre><code>g++ [options] -o [nom_executable] [vos_fichiers.cpp]\n</code></pre> <p>D\u00e9taillons chaque partie :</p> <ul> <li><code>g++</code> : C'est l'appel au compilateur lui-m\u00eame.</li> <li><code>[options]</code> : Ce sont des \"drapeaux\" (flags) qui modifient le comportement du compilateur. Les deux plus importants pour nous sont :<ul> <li><code>-std=c++20</code> : C'est le drapeau crucial qui dit \u00e0 <code>g++</code> d'utiliser le standard C++20. Sans cela, les fonctionnalit\u00e9s modernes du langage ne seront pas disponibles.</li> <li><code>-Wall</code> : (Abr\u00e9viation de \"Warnings All\") C'est une option tr\u00e8s fortement recommand\u00e9e qui active presque tous les avertissements (<code>warnings</code>). Le compilateur vous signalera des erreurs potentielles dans votre code, m\u00eame si elles ne l'emp\u00eachent pas de compiler. C'est un filet de s\u00e9curit\u00e9 indispensable.</li> </ul> </li> <li><code>-o [nom_executable]</code> : L'option <code>-o</code> (pour \"output\") vous permet de nommer votre programme final. Si vous l'omettez, le fichier de sortie s'appellera <code>a.out</code> (sur Linux/macOS) ou <code>a.exe</code> (sur Windows).</li> <li><code>[vos_fichiers.cpp]</code> : C'est la liste de tous vos fichiers <code>.cpp</code>, s\u00e9par\u00e9s par des espaces. Vous n'avez pas besoin d'inclure les fichiers <code>.hpp</code>, car ils sont g\u00e9r\u00e9s via les directives <code>#include</code> dans vos fichiers <code>.cpp</code>.</li> </ul>"},{"location":"notes/semaine_1_4_compilation_cpp20/#3-exemples-concrets","title":"3. Exemples Concrets","text":""},{"location":"notes/semaine_1_4_compilation_cpp20/#cas-1-un-projet-avec-un-seul-fichier","title":"Cas 1 : Un Projet avec un Seul Fichier","text":"<p>Imaginons que vous avez un seul fichier <code>main.cpp</code>.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp\n</code></pre> -   Ceci cr\u00e9era un ex\u00e9cutable nomm\u00e9 <code>mon_programme</code>.</p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#cas-2-un-projet-avec-plusieurs-fichiers","title":"Cas 2 : Un Projet avec Plusieurs Fichiers","text":"<p>Reprenons notre exemple <code>Commande</code>. Nous avons trois fichiers <code>.cpp</code> \u00e0 compiler ensemble.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o exemple main.cpp Commande.cpp ServiceConnexion.cpp\n</code></pre> -   <code>g++</code> va compiler chaque fichier <code>.cpp</code> et les lier (\"link\") ensemble pour cr\u00e9er un seul ex\u00e9cutable nomm\u00e9 <code>exemple</code>.</p>"},{"location":"notes/semaine_1_4_compilation_cpp20/#4-executer-votre-programme","title":"4. Ex\u00e9cuter votre Programme","text":"<p>Une fois la compilation r\u00e9ussie (si la commande ne retourne aucune erreur), un nouveau fichier ex\u00e9cutable appara\u00eetra dans votre dossier.</p> <p>Pour l'ex\u00e9cuter dans le terminal :</p> <ul> <li> <p>Sur Linux ou macOS : <pre><code>./nom_executable \n</code></pre>     (Le <code>./</code> signifie \"dans le dossier actuel\")</p> </li> <li> <p>Sur Windows (cmd ou PowerShell) : <pre><code>.\\nom_executable.exe\n</code></pre></p> </li> </ul>"},{"location":"notes/semaine_1_4_compilation_cpp20/#5-ca-ne-compile-pas-gerer-les-erreurs","title":"5. \"\u00c7a ne compile pas !\" - G\u00e9rer les Erreurs","text":"<p>Il est normal d'avoir des erreurs de compilation. L'art de la programmation est de savoir les lire.</p> <p>Les erreurs les plus courantes au d\u00e9but : -   Oubli d'un point-virgule (<code>;</code>) \u00e0 la fin d'une ligne. -   Faute de frappe dans un nom de variable ou de fonction. -   Accolade (<code>{</code> ou <code>}</code>) manquante. -   Oubli d'inclure un en-t\u00eate (ex: <code>#include &lt;string&gt;</code> pour utiliser <code>std::string</code>).</p> <p>Lisez attentivement les messages d'erreur. <code>g++</code> vous donnera g\u00e9n\u00e9ralement le nom du fichier et le num\u00e9ro de la ligne o\u00f9 l'erreur a \u00e9t\u00e9 d\u00e9tect\u00e9e.</p> <p>Exemple de message d'erreur : <pre><code>main.cpp: In function 'int main()':\nmain.cpp:5:3: error: expected ';' before 'return'\n   return 0;\n   ^~~~~~\n</code></pre> Le compilateur nous dit qu'\u00e0 la ligne 5 du fichier <code>main.cpp</code>, il s'attendait \u00e0 un point-virgule avant le mot-cl\u00e9 <code>return</code>.</p> <p>```</p>"},{"location":"notes/semaine_2_1_passage_copie_reference/","title":"Les 3 Fa\u00e7ons de Passer des Param\u00e8tres","text":"<p>En C++, il y a trois mani\u00e8res de transmettre une variable \u00e0 une fonction. Choisir la bonne m\u00e9thode est essentiel pour la performance et la s\u00e9curit\u00e9 de votre code.</p>"},{"location":"notes/semaine_2_1_passage_copie_reference/#1-passage-par-copie-pass-by-value","title":"1. Passage par Copie (Pass-by-Value)","text":"<p>\"Je te donne une photocopie.\"</p> <p>C'est le comportement par d\u00e9faut pour les types simples (<code>int</code>, <code>char</code>, <code>bool</code>, <code>float</code>).</p> <ul> <li>M\u00e9canisme : La fonction cr\u00e9e une nouvelle variable et copie la valeur de l'originale dedans.</li> <li>Cons\u00e9quence : Si la fonction modifie la variable, l'originale ne change pas.</li> <li>Co\u00fbt : Rapide pour les petits nombres, mais tr\u00e8s lent pour les gros objets (comme une image ou un long texte) car il faut tout dupliquer octet par octet.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nvoid copie(int x) {\n    x = 1000; // Modifie uniquement la photocopie locale\n    std::cout &lt;&lt; \"Dans la fonction : \" &lt;&lt; x &lt;&lt; \"\\n\";\n}\n\nint main() {\n    int a = 10;\n    copie(a);\n    std::cout &lt;&lt; \"Dans le main : \" &lt;&lt; a &lt;&lt; \"\\n\"; // Affiche 10 (intact)\n}\n</code></pre>"},{"location":"notes/semaine_2_1_passage_copie_reference/#2-passage-par-reference-pass-by-reference","title":"2. Passage par R\u00e9f\u00e9rence (Pass-by-Reference)","text":"<p>\"Je te donne acc\u00e8s \u00e0 mon fichier Google Doc original.\"</p> <p>On utilise le symbole <code>&amp;</code>. La fonction ne cr\u00e9e aucune nouvelle variable. Elle travaille directement sur la m\u00e9moire de l'original.</p>"},{"location":"notes/semaine_2_1_passage_copie_reference/#a-reference-modifiable-type","title":"A. R\u00e9f\u00e9rence Modifiable (<code>Type&amp;</code>)","text":"<p>Utilis\u00e9 quand la fonction DOIT modifier l'original.</p> <pre><code>void modifier(int&amp; x) {\n    x = 1000; // Modifie la VRAIE variable du main\n}\n</code></pre>"},{"location":"notes/semaine_2_1_passage_copie_reference/#b-reference-constante-const-type-le-standard","title":"B. R\u00e9f\u00e9rence Constante (<code>const Type&amp;</code>) \ud83c\udf1f LE STANDARD","text":"<p>C'est la m\u00e9thode reine du C++ pour les objets complexes (<code>std::string</code>, <code>std::vector</code>...). Elle combine le meilleur des deux mondes :</p> <ol> <li>Vitesse de la r\u00e9f\u00e9rence (pas de copie).</li> <li>S\u00e9curit\u00e9 de la copie (interdiction de modifier l'original).</li> </ol> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// \"const\" + \"&amp;\" = Je regarde l'original, mais je n'ai pas le droit de toucher\nvoid afficher(const std::string&amp; texte) {\n    std::cout &lt;&lt; texte;\n\n    // \ud83d\uded1 ERREUR DE COMPILATION : \n    // texte = \"Salut\"; // Interdit ! On est en lecture seule.\n}\n\nint main{\n    std::string allo {\"hello\"};\n    afficher(allo);\n}\n</code></pre>"},{"location":"notes/semaine_2_1_passage_copie_reference/#3-passage-par-pointeur-pass-by-pointer","title":"3. Passage par Pointeur (Pass-by-Pointer)","text":"<p>\"Je te donne l'adresse GPS de ma maison.\"</p> <p>C'est l'anc\u00eatre de la r\u00e9f\u00e9rence, h\u00e9rit\u00e9 du langage C. On utilise le symbole <code>*</code> pour d\u00e9clarer le pointeur et <code>&amp;</code> pour r\u00e9cup\u00e9rer l'adresse d'une variable.</p> <ul> <li>M\u00e9canisme : La fonction re\u00e7oit l'adresse m\u00e9moire (un nombre hexad\u00e9cimal) de la variable, pas la variable elle-m\u00eame.</li> <li>Syntaxe : C'est plus lourd \u00e0 utiliser. Il faut \"d\u00e9r\u00e9f\u00e9rencer\" le pointeur avec l'\u00e9toile <code>*</code> pour acc\u00e9der \u00e0 la valeur stock\u00e9e \u00e0 cette adresse.</li> <li>La Diff\u00e9rence Cl\u00e9 : Un pointeur peut \u00eatre vide (<code>nullptr</code>). Une r\u00e9f\u00e9rence, elle, doit toujours \u00eatre li\u00e9e \u00e0 une variable existante.</li> </ul> <pre><code>// La fonction attend une adresse (int*)\nvoid remiseAZero(int* ptr) {\n    // S\u00e9curit\u00e9 : on v\u00e9rifie que l'adresse existe (n'est pas nulle)\n    if (ptr != nullptr) { \n        *ptr = 0; // On va \u00e0 l'adresse point\u00e9e et on \u00e9crit 0\n    }\n}\n\nint main() {\n    int note = 20;\n\n    // Appel : On envoie l'adresse de 'note' avec '&amp;'\n    remiseAZero(&amp;note); \n}\n</code></pre> <p>## 4. Le Grand R\u00e9capitulatif</p> <p>Voici le tableau de synth\u00e8se pour savoir quelle m\u00e9thode utiliser en un coup d'\u0153il.</p> M\u00e9thode Syntaxe (D\u00e9claration) Syntaxe (Appel) Modifie Original ? Peut \u00eatre Null ? Usage Recommand\u00e9 Copie <code>void f(int a)</code> <code>f(a)</code> \u274c Non \u274c Non Petits types simples (<code>int</code>, <code>bool</code>, <code>char</code>). R\u00e9f\u00e9rence <code>void f(int&amp; a)</code> <code>f(a)</code> \u2705 Oui \u274c Non Quand la fonction doit modifier la variable. R\u00e9f. Const <code>void f(const int&amp; a)</code> <code>f(a)</code> \u274c Non \u274c Non Standard pour les objets (<code>string</code>, <code>vector</code>) en lecture seule. Pointeur <code>void f(int* a)</code> <code>f(&amp;a)</code> \u2705 Oui \u2705 Oui Donn\u00e9es optionnelles ou h\u00e9ritage du C. <p>## 5. Guide de D\u00e9cision : Quoi utiliser quand ?</p> <p>C'est la question la plus importante. Suivez cet algorithme mental pour choisir le bon type de param\u00e8tre.</p> <p>L'Algorithme de Choix</p> <ol> <li> <p>La variable est-elle \"petite\" ? (<code>int</code>, <code>double</code>, <code>char</code>, <code>bool</code>)     \ud83d\udc49 Utilisez la COPIE. (Ex: <code>void setAge(int age)</code>)     C'est plus simple et le processeur g\u00e8re \u00e7a tr\u00e8s vite.</p> </li> <li> <p>La variable est \"grosse\" (<code>string</code>, <code>vector</code>) et je veux juste la lire ?     \ud83d\udc49 Utilisez la R\u00c9F\u00c9RENCE CONSTANTE. (Ex: <code>void afficher(const std::string&amp; nom)</code>)     C'est rapide (z\u00e9ro copie) et s\u00fbr.</p> </li> <li> <p>La fonction doit-elle modifier l'original ?     \ud83d\udc49 Utilisez la R\u00c9F\u00c9RENCE. (Ex: <code>void monterNiveau(Joueur&amp; j)</code>)</p> </li> <li> <p>La donn\u00e9e est-elle optionnelle (peut ne pas exister) ?     \ud83d\udc49 Utilisez le POINTEUR. (Ex: <code>void cibler(Ennemi* cible)</code>)     Cela permet de passer <code>nullptr</code> pour dire \"rien\".</p> </li> </ol>"},{"location":"notes/semaine_2_1_passage_copie_reference/#6-le-cas-special-des-tableaux-c","title":"6. Le Cas Sp\u00e9cial des Tableaux C","text":"<p>Attention : Les tableaux de style C (<code>int tab[]</code>) sont des tra\u00eetres !</p> <p>Le Pi\u00e8ge du Decay (D\u00e9g\u00e9n\u00e9rescence)</p> <p>M\u00eame si vous ne mettez pas de <code>&amp;</code>, un tableau C pass\u00e9 \u00e0 une fonction se comporte toujours comme un pointeur. Il n'est jamais copi\u00e9.</p> <p>Cela signifie que la fonction peut modifier votre tableau original sans pr\u00e9venir.</p> <pre><code>// Ceci modifie le VRAI tableau, m\u00eame sans '&amp;' !\nvoid hack(int tab[]) { \n    tab[0] = 0; // Le tableau du main est modifi\u00e9\n}\n</code></pre> <p>Note : La Solution Moderne</p> <p>C'est pour cela qu'en C++ moderne, on pr\u00e9f\u00e8re <code>std::vector</code> ou <code>std::span</code> qui sont plus s\u00fbrs.</p>"},{"location":"notes/semaine_2_1_passage_copie_reference/#exemple-des-pointeurs-vu-en-classe","title":"Exemple des pointeurs vu en classe.","text":"<pre><code>#include &lt;iostream&gt; //instruction de pr\u00e9compilation\n\nvoid fonction_quelconque(int* le_pointeur_de_int) { //j'ai oubli\u00e9 de dire qu'en c++ c'est la casse \"serpent\"\n    std::cout &lt;&lt; \" entr\u00e9e de fonction \" &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" adresse o\u00f9 pointe le pointeur : \" &lt;&lt; le_pointeur_de_int &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" la valeur par d\u00e9r\u00e9f\u00e9rencement : \" &lt;&lt; *le_pointeur_de_int &lt;&lt; std::endl;\n    // d\u00e9r\u00e9f\u00e9rencer -&gt; enlever la r\u00e9f\u00e9rence et tomber sur le type en dessous, int dans notre cas\n\n    //modification de la valeur\n    *le_pointeur_de_int *= 2; //x2 la valeur\n    std::cout &lt;&lt; \" Fin de fonction \" &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\nint main() {\n    int a { 10 };\n    std::cout &lt;&lt; \"adresse de a \" &lt;&lt; &amp;a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a\n\n    std::cout &lt;&lt; \"valeur de a avant l'appel de fonction \" &lt;&lt; a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a\n    fonction_quelconque(&amp;a); //appel de la fonction avec l'adresse de a\n    std::cout &lt;&lt; \"valeur de a apr\u00e8s l'appel de fonction \" &lt;&lt; a &lt;&lt; std::endl; //ici pas besoin de rien de sp\u00e9cial pour a\n\n    //preuve que la fonction re\u00e7oit un pointeur\n    int* a_ptr = &amp;a; //d\u00e9claration d'un pointeur sur l'adresse de la variable a\n    fonction_quelconque(a_ptr);\n}\n</code></pre>"},{"location":"notes/semaine_2_2_les_structs/","title":"De la <code>struct</code> \u00e0 la <code>class</code> : Une Introduction Progressive","text":"<p>L'objectif de cette note est de comprendre l'\u00e9volution de la pens\u00e9e en C++ : comment on passe d'une simple structure de donn\u00e9es \u00e0 un objet complet et robuste. Nous allons suivre une progression en plusieurs \u00e9tapes.</p>"},{"location":"notes/semaine_2_2_les_structs/#partie-1-la-struct-comme-simple-conteneur-de-donnees","title":"Partie 1 : La <code>struct</code> comme Simple Conteneur de Donn\u00e9es","text":"<p>Au niveau le plus simple, une <code>struct</code> est une mani\u00e8re de regrouper plusieurs variables en un seul type. On la d\u00e9finit g\u00e9n\u00e9ralement dans un fichier d'en-t\u00eate (<code>.hpp</code>) pour pouvoir la r\u00e9utiliser.</p>"},{"location":"notes/semaine_2_2_les_structs/#11-len-tete-joueurhpp-et-les-gardes","title":"1.1 - L'En-t\u00eate (<code>Joueur.hpp</code>) et les Gardes","text":"<p>Un fichier d'en-t\u00eate doit \u00eatre prot\u00e9g\u00e9 contre l'inclusion multiple. Si un m\u00eame <code>.hpp</code> est inclus plusieurs fois, le compilateur verra la d\u00e9finition de la <code>struct</code> en double et g\u00e9n\u00e9rera une erreur. Pour \u00e9viter cela, on utilise une \"garde d'en-t\u00eate\".</p> <p>M\u00e9thode Moderne (<code>#pragma once</code>) : \u00c0 placer sur la toute premi\u00e8re ligne. C'est la m\u00e9thode privil\u00e9gi\u00e9e pour ce cours.</p> <pre><code>// Fichier : Joueur.hpp\n#pragma once\n#include &lt;string&gt;\n\n// La seule responsabilit\u00e9 de ce fichier est de d\u00e9finir la struct Joueur.\nstruct Joueur {\n    std::string nom;\n    int points_de_vie;\n    int niveau;\n};\n</code></pre> <p>M\u00e9thode Traditionnelle (<code>ifndef</code>) : Fonctionne sur tous les compilateurs. Le nom (<code>JOUEUR_HPP</code>) doit \u00eatre unique.</p> <pre><code>#ifndef JOUEUR_HPP\n#define JOUEUR_HPP\n// ... contenu du .hpp ...\n#endif // JOUEUR_HPP\n</code></pre>"},{"location":"notes/semaine_2_2_les_structs/#12-utilisation-simple-dans-maincpp","title":"1.2 - Utilisation simple dans <code>main.cpp</code>","text":"<p>Le <code>main.cpp</code> inclut le <code>.hpp</code> et peut ensuite cr\u00e9er et manipuler des variables du type <code>Joueur</code>.</p> <pre><code>// Fichier : main.cpp\n#include &lt;iostream&gt;\n#include &lt;format&gt;\n#include \"Joueur.hpp\" // On inclut la d\u00e9finition de notre struct\n\nint main() {\n    Joueur p1 {\n        .nom = \"Frodon Sacquet\",\n        .points_de_vie = 20,\n        .niveau = 1\n    };\n\n    p1.niveau = 2; // Acc\u00e8s direct aux membres publics\n\n    std::cout &lt;&lt; std::format(\"{} est maintenant niveau {}\\n\", p1.nom, p1.niveau);\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_2_2_les_structs/#partie-2-struct-avec-fonctions-libres","title":"Partie 2 : <code>struct</code> avec Fonctions Libres","text":"<p>Rapidement, on se rend compte que du code se r\u00e9p\u00e8te (par exemple, l'affichage d'un joueur). On peut cr\u00e9er des fonctions pour ces t\u00e2ches. Pour garder notre projet organis\u00e9, on s\u00e9pare les d\u00e9clarations des d\u00e9finitions.</p> <ul> <li><code>JoueurActions.hpp</code> : D\u00e9clare les fonctions \"libres\" qui travaillent sur <code>Joueur</code>. C'est le \"menu des actions\".</li> <li><code>JoueurActions.cpp</code> : Impl\u00e9mente le code de ces fonctions.</li> </ul> <p><pre><code>// Fichier : JoueurActions.hpp\n#pragma once\n#include \"Joueur.hpp\" // Pour savoir ce qu'est un Joueur\n\nvoid afficher_joueur(const Joueur&amp; j); // Signature (prototype)\n</code></pre> <pre><code>// Fichier : JoueurActions.cpp\n#include \"JoueurActions.hpp\"\n#include &lt;iostream&gt;\n#include &lt;format&gt;\n\nvoid afficher_joueur(const Joueur&amp; j) { // Impl\u00e9mentation\n    std::cout &lt;&lt; std::format(\"- Nom: {}, PV: {}\\n\", j.nom, j.points_de_vie);\n}\n</code></pre> <pre><code>// Fichier : main.cpp (modifi\u00e9)\n#include \"Joueur.hpp\"\n#include \"JoueurActions.hpp\" // On inclut maintenant les actions\n\nint main() {\n    Joueur p1 { .nom = \"Sam Gamegie\", .points_de_vie = 30 };\n    afficher_joueur(p1); // On utilise notre fonction\n    return 0;\n}\n</code></pre></p>"},{"location":"notes/semaine_2_2_les_structs/#partie-21-structure-inclusions-et-compilation","title":"Partie 2.1 : Structure, Inclusions et Compilation","text":"<p>Cette s\u00e9paration des fichiers suit un principe essentiel : le Principe de Responsabilit\u00e9 Unique. Chaque fichier a un seul r\u00f4le.</p> <ul> <li><code>Joueur.hpp</code> : D\u00e9finit ce qu'EST un <code>Joueur</code>.</li> <li><code>JoueurActions.hpp</code> : D\u00e9clare ce qu'on PEUT FAIRE avec un <code>Joueur</code>.</li> <li><code>JoueurActions.cpp</code> : Explique COMMENT on le fait.</li> <li><code>main.cpp</code> : Lance le programme.</li> </ul>"},{"location":"notes/semaine_2_2_les_structs/#schema-des-inclusions","title":"Sch\u00e9ma des Inclusions","text":"<p>Voici comment les fichiers d\u00e9pendent les uns des autres. Une fl\u00e8che <code>A -&gt; B</code> signifie que le fichier <code>A</code> inclut le fichier <code>B</code>.</p> <pre><code>           main.cpp  ---------------&gt; JoueurActions.hpp\n                                          |\nJoueurActions.cpp  ------------&gt; JoueurActions.hpp\n                                          |\n                                          v\n                                      Joueur.hpp\n</code></pre> <p>Le <code>main.cpp</code> n'a pas besoin de conna\u00eetre les d\u00e9tails de <code>Joueur.hpp</code>. Il fait confiance \u00e0 <code>JoueurActions.hpp</code> pour lui fournir les actions n\u00e9cessaires.</p>"},{"location":"notes/semaine_2_2_les_structs/#compilation-du-projet","title":"Compilation du Projet","text":"<p>Pour cr\u00e9er l'ex\u00e9cutable, vous devez fournir tous les fichiers <code>.cpp</code> au compilateur. Celui-ci va les traduire en code machine, puis l'\u00e9diteur de liens (linker) va les assembler en un seul programme.</p> <p><pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp JoueurActions.cpp\n</code></pre> Notez qu'on ne donne jamais les fichiers <code>.hpp</code> au compilateur directement. Ils sont inclus par les <code>.cpp</code>.</p>"},{"location":"notes/semaine_2_2_les_structs/#partie-3-evolution-vers-les-fonctions-membres","title":"Partie 3 : \u00c9volution vers les Fonctions Membres","text":"<p>L'\u00e9tape suivante est de lier plus fortement un comportement \u00e0 la <code>struct</code> elle-m\u00eame. Si une fonction est intrins\u00e8quement li\u00e9e \u00e0 un objet (comme <code>afficher</code>), on peut en faire une fonction membre.</p> <p>Important : \u00c0 ce stade, la <code>struct</code> reste un conteneur \"passif\" avec des donn\u00e9es publiques. C'est une \u00e9tape d'organisation, pas encore de protection.</p> <ul> <li><code>Joueur.hpp</code> : La fonction est d\u00e9clar\u00e9e DANS la <code>struct</code>.</li> <li><code>Joueur.cpp</code> : Un fichier source pour <code>Joueur</code> impl\u00e9mente ses fonctions membres.</li> </ul> <p><pre><code>// Fichier : Joueur.hpp (refactoris\u00e9)\n#pragma once\n#include &lt;string&gt;\n\nstruct Joueur {\n    std::string nom;\n    int points_de_vie;\n    int niveau;\n    void afficher() const; // D\u00e9claration de la fonction MEMBRE\n};\n</code></pre> <pre><code>// Fichier : Joueur.cpp (nouveau)\n#include \"Joueur.hpp\"\n#include &lt;iostream&gt;\n#include &lt;format&gt;\n\nvoid Joueur::afficher() const { // Joueur:: indique que c'est une fonction de Joueur\n    std::cout &lt;&lt; std::format(\"- Nom: {}, PV: {}\\n\", nom, points_de_vie);\n}\n</code></pre> <pre><code>// Fichier : main.cpp (refactoris\u00e9)\n#include \"Joueur.hpp\"\n\nint main() {\n    Joueur p1 { .nom = \"Gandalf\", .points_de_vie = 1000 };\n    p1.afficher(); // Appel plus naturel : on demande \u00e0 l'objet de s'afficher.\n    return 0;\n}\n</code></pre></p>"},{"location":"notes/semaine_2_2_les_structs/#partie-4-gestion-de-la-memoire-et-fonctions","title":"Partie 4 : Gestion de la M\u00e9moire et Fonctions","text":"<p>Comment passer et retourner des <code>struct</code>s efficacement et sans danger.</p>"},{"location":"notes/semaine_2_2_les_structs/#41-acces-point-vs-fleche-","title":"4.1 - Acc\u00e8s : Point (<code>.</code>) vs. Fl\u00e8che (<code>-&gt;</code>)","text":"Si vous avez... Op\u00e9rateur Syntaxe Exemple L'objet ou une r\u00e9f\u00e9rence Le point (<code>.</code>) <code>mon_objet.membre</code> <code>p1.nom</code> Un pointeur vers l'objet La fl\u00e8che (<code>-&gt;</code>) <code>ptr_objet-&gt;membre</code> <code>ptr_p1-&gt;nom</code> <p>La fl\u00e8che <code>-&gt;</code> est un raccourci pour d\u00e9r\u00e9f\u00e9rencer puis acc\u00e9der : <code>(*ptr_p1).nom</code>.</p>"},{"location":"notes/semaine_2_2_les_structs/#42-passage-en-parametre","title":"4.2 - Passage en Param\u00e8tre","text":"<ul> <li>Lecture Seule (<code>const&amp;</code>) : Le plus s\u00fbr et le plus efficace pour passer des objets que la fonction ne doit pas modifier. \u00c9vite une copie.     <pre><code>void afficher_details(const Joueur&amp; j) { /* ... */ }\n</code></pre></li> <li>Lecture/\u00c9criture (<code>&amp;</code>) : Quand la fonction DOIT modifier l'objet original.     <pre><code>void monter_niveau(Joueur&amp; j) { j.niveau += 1; }\n</code></pre></li> </ul>"},{"location":"notes/semaine_2_2_les_structs/#43-retour-de-struct-depuis-une-fonction","title":"4.3 - Retour de <code>struct</code> depuis une fonction","text":"<ul> <li>Par Copie (S\u00fbr) : La fonction retourne une copie. L'objet original cr\u00e9\u00e9 dans la fonction est d\u00e9truit, mais sa copie survit.     <pre><code>Joueur creer_ennemi() {\n    Joueur orc { .nom = \"Orc de base\", .niveau = 1 };\n    return orc; // OK : une copie de 'orc' est envoy\u00e9e.\n}\n</code></pre></li> <li>Par Pointeur (DANGEREUX !)     !!! failure \"\u00c0 NE JAMAIS FAIRE\"     Il ne faut jamais retourner l'adresse (<code>&amp;</code>) ou un pointeur (<code>*</code>) d'une variable locale. La variable est d\u00e9truite \u00e0 la fin de la fonction, et le pointeur devient un \"dangling pointer\" qui pointe vers une zone m\u00e9moire invalide. Utiliser ce pointeur m\u00e8ne \u00e0 un comportement ind\u00e9fini (crash, corruption).     <pre><code>Joueur* creer_ennemi_dangereux() {\n    Joueur gobelin { .nom = \"Gobelin\", .niveau = 1 };\n    return &amp;gobelin; // ERREUR FATALE !  \n    /* \n     * gobelin va \u00eatre d\u00e9truit apr\u00e8s la fonction.  \n     * C'est une variable locale, donc, le pointeur  \n     * va pointer sur une valeur instable.  \n     * (m\u00e9moire libre pour autre chose) \n     */\n}\n</code></pre></li> </ul>"},{"location":"notes/semaine_2_2_les_structs/#partie-5-ouverture-vers-la-class-semaine-3","title":"Partie 5 : Ouverture vers la <code>class</code> (Semaine 3)","text":"<p>Le probl\u00e8me de nos <code>struct</code>s actuelles est que leurs donn\u00e9es sont publiques et vuln\u00e9rables (<code>p1.niveau = -99;</code>). La prochaine \u00e9tape est d'apprendre \u00e0 prot\u00e9ger les donn\u00e9es et \u00e0 garantir des r\u00e8gles (invariants) en utilisant le mot-cl\u00e9 <code>class</code>.</p>"},{"location":"notes/semaine_2_2_les_structs/#apercu-de-levolution-en-class","title":"Aper\u00e7u de l'\u00c9volution en <code>class</code>","text":"<p><pre><code>// Fichier : Joueur.hpp (Version Semaine 3)\n#pragma once\n#include &lt;string&gt;\n\nclass Joueur {\nprivate: // Les donn\u00e9es sont maintenant prot\u00e9g\u00e9es et inaccessibles de l'ext\u00e9rieur.\n    std::string nom_;\n    int points_de_vie_;\n    int niveau_;\n\npublic:\n    // Un \"constructeur\" pour garantir que chaque Joueur est cr\u00e9\u00e9 dans un \u00e9tat valide.\n    Joueur(const std::string&amp; nom, int pv, int niveau);\n\n    // Une fonction membre pour une modification contr\u00f4l\u00e9e des donn\u00e9es.\n    void subir_degats(int degats);\n\n    // Une fonction membre pour un acc\u00e8s en lecture seule.\n    void afficher() const;\n\n    // Un \"getter\" pour lire une valeur priv\u00e9e de mani\u00e8re contr\u00f4l\u00e9e.\n    int get_niveau() const;\n};\n</code></pre> Cette structure est le c\u0153ur de la programmation orient\u00e9e objet en C++ et sera l'objet de la semaine 3.</p>"},{"location":"notes/semaine_2_2_les_structs/#partie-6-exercices","title":"Partie 6 : Exercices","text":"<p>(Les exercices de la version pr\u00e9c\u00e9dente sont plac\u00e9s ici pour la mise en pratique.) Pour mettre en pratique les concepts ci-dessus, imaginez que vous travaillez avec la structure de fichiers suivante : - <code>Livre.hpp</code> - <code>Exercices.hpp</code> - <code>Exercices.cpp</code> - <code>main.cpp</code></p>"},{"location":"notes/semaine_2_2_les_structs/#exercice-1-definition-et-initialisation","title":"Exercice 1 : D\u00e9finition et Initialisation","text":"<ol> <li>Dans <code>Livre.hpp</code>, d\u00e9finissez une <code>struct Livre</code> avec <code>titre</code>, <code>auteur</code>, <code>annee_publication</code>.</li> <li>Dans <code>main.cpp</code>, cr\u00e9ez une instance de <code>Livre</code> et affichez ses membres.</li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-2-fonctions-libres","title":"Exercice 2 : Fonctions Libres","text":"<ol> <li>Cr\u00e9ez <code>LivreActions.hpp</code>/<code>.cpp</code>.</li> <li>D\u00e9clarez et d\u00e9finissez une fonction <code>void afficher_livre(const Livre&amp; l);</code>.</li> <li>Appelez cette fonction depuis <code>main</code>.</li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-3-fonctions-membres","title":"Exercice 3 : Fonctions Membres","text":"<ol> <li>Modifiez <code>Livre.hpp</code> pour y d\u00e9clarer une fonction membre <code>void afficher() const;</code>.</li> <li>Cr\u00e9ez <code>Livre.cpp</code> pour impl\u00e9menter <code>Livre::afficher()</code>.</li> <li>Modifiez <code>main.cpp</code> pour appeler <code>mon_livre.afficher()</code>.</li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-4-modification-et-pointeur","title":"Exercice 4 : Modification et Pointeur","text":"<ol> <li>\u00c9crivez une fonction membre <code>void corriger_annee(int nouvelle_annee);</code> qui modifie l'ann\u00e9e.</li> <li>Dans <code>main</code>, cr\u00e9ez un pointeur sur votre livre et utilisez <code>-&gt;</code> pour appeler <code>corriger_annee</code>.</li> </ol>"},{"location":"notes/semaine_2_2_les_structs/#exercice-5-factory-function","title":"Exercice 5 : Factory Function","text":"<ol> <li>\u00c9crivez une fonction libre <code>Livre creer_best_seller();</code> qui retourne un <code>Livre</code> par copie.</li> <li>Appelez-la depuis <code>main</code> pour cr\u00e9er un nouveau livre.</li> </ol> <p>```</p>"}]}