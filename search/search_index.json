{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Programmation 2 (420-2A6-VI) - Hiver 2025","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Vous trouverez ici les notes et exercices du cours. J'ajouterai du nouveau contenu continuellement.</p> <p>Pr\u00e9alable \u00e0 ce cours : 420-1D6-VI Programmation 1</p> <p>Ce cours est pr\u00e9alable \u00e0 : 420-5B5-VI Projet int\u00e9grateur 1 Cheminement complet: https://informatique.apical.xyz/</p>"},{"location":"#environnement-de-travail","title":"Environnement de travail","text":"<p>Pour le cours vous avez deux logiciels \u00e0 installer:</p> <ul> <li>WSL (Windows subsystem for linux)</li> <li>Un \u00e9diteur de texte \u00e9volu\u00e9 tel notepad++ (recommand\u00e9) </li> <li>Codeblock</li> <li>Git</li> </ul>"},{"location":"#wsl","title":"WSL","text":"<p>Vous devez installer git et build-essentials dans l'environnement linux. Les paquets tels que, mais non limit\u00e9s \u00e0, gemini, claude, chatgpt sont proscrit. \u2003</p>"},{"location":"#notepad-ou-autre-editeur-compatible","title":"Notepad++ (ou autre \u00e9diteur compatible)","text":"<p>Parfois git vous demande de faire l'\u00e9ditions de fichiers tel que les commentaires pour les soumissions. (git commit). Il arrive \u00e9galement que des conflits soient pr\u00e9sent. Le logiciels permet de mieux travailler dans ces situations plus complexe.</p>"},{"location":"#git","title":"Git","text":"<p>Installation normale, portez attention \u00e0 l'\u00e9diteur par d\u00e9faut. Autrement, vous allez vous retrouver avec vim pour \u00e9diter vos fichiers</p> <p>Votre identit\u00e9 : dans WSL vous \u00eates dans un environnement \"nouveau\" donc git va vous demander votre identit\u00e9. Utilisez votre courriel coll\u00e8ge comme configuration de courriel globale : @etudiant.cegepvicto.ca  Pour votre nom vous pouvez r\u00e9utiliser votre num\u00e9ro de DA  </p> <pre><code>*** Please tell me who you are.\n\nRun\n\n  git config --global user.email \"[DA]@etudiant.cegepvicto.ca\"\n  git config --global user.name \"Votre nom\"\n\nto set your account's default identity.\nOmit --global to set the identity only in this repository.\n</code></pre>"},{"location":"#regles-de-classes-et-explications","title":"R\u00e8gles de classes et explications :","text":"<p>Petit rappel des r\u00e8gles au niveau de la P.D.E.A</p>"},{"location":"#conditions-pedagogiques-particulieres","title":"Conditions p\u00e9dagogiques particuli\u00e8res","text":"<p>Utilisation de g\u00e9n\u00e9rateur automatique :  </p> <p>Dans le cadre des activit\u00e9s acad\u00e9miques du cours, l'utilisation de g\u00e9n\u00e9rateurs de code automatiques, d'assistants d'IA tels que ChatGPT, Copilot ou tout autre outil similaire permettant la cr\u00e9ation automatique de contenu, la g\u00e9n\u00e9ration de code ou l\u2019assistance \u00e0 la r\u00e9solution d'exercices, est formellement interdite. Toute utilisation de ces outils durant un cours entra\u00eenera l'exclusion imm\u00e9diate de l'\u00e9l\u00e8ve de la p\u00e9riode concern\u00e9e.  </p>"},{"location":"#utilisation-des-cellulaires-ou-dappareils-mobiles-en-classe","title":"Utilisation des cellulaires ou d'appareils mobiles en classe","text":"<p>Toute utilisation d'appareil mobile tel que cellulaire, tablette ou console de jeux mobile est proscrite pendant le bloc horaire \u00e0 l'int\u00e9rieur du local. (Pr\u00e9cision : pauses incluses.) L'utilisation de tels appareils doit imp\u00e9rativement se faire hors du local afin de favoriser le climat d'apprentissage.  </p> <p>Les manquements aux articles pr\u00e9c\u00e9dents seront consign\u00e9s. Apr\u00e8s trois (3) exclusions, des d\u00e9marches administratives seront entreprises avec l'API afin de d\u00e9terminer les modalit\u00e9s de cheminement.</p>"},{"location":"#environnement-numerique-dapprentissage-plateforme","title":"Environnement num\u00e9rique d\u2019apprentissage (plateforme)","text":"<ul> <li>Team</li> <li>Github</li> <li>Github classroom</li> </ul> <p>L'\u00e9l\u00e8ve a la responsabilit\u00e9 d'avoir un compte github avec un nom d'utilisateur r\u00e9pondant \u00e0 la norme suivante :</p> <p>cgpvicto-[son num\u00e9ro de DA]</p> <p>exemple : cgpvicto-9999999</p> <p>Une fois le compte github cr\u00e9\u00e9. On doit rejoindre le github classroom correspondant \u00e0 son groupe, proc\u00e9dure qui sera donn\u00e9e en classe lors des premi\u00e8res semaines</p>"},{"location":"conventions/","title":"Normes et Conventions de Code C++","text":"<p>Standard du Cours</p> <p>Ce cours utilise officiellement le standard C++20. Tous les exemples et exercices doivent \u00eatre compil\u00e9s avec un compilateur compatible.</p> <p>Ce document d\u00e9finit les standards de programmation attendus pour tous les travaux pratiques et examens. L'objectif est de produire un code lisible, maintenable et proche des standards industriels modernes.</p>"},{"location":"conventions/#1-nommage-naming-convention","title":"1. Nommage (Naming Convention)","text":"<p>Nous adoptons le style de la Biblioth\u00e8que Standard C++ (STL).</p>"},{"location":"conventions/#la-regle-snake_case","title":"La r\u00e8gle : <code>snake_case</code>","text":"\u00c9l\u00e9ment Format Exemple Variables <code>snake_case</code> <code>nombre_etudiants</code>, <code>index_courant</code> Fonctions <code>snake_case</code> <code>calculer_moyenne()</code>, <code>sauvegarder_fichier()</code> Classes / Structs <code>PascalCase</code> <code>Etudiant</code>, <code>GestionnaireFichier</code> Constantes <code>SCREAMING_SNAKE</code> <code>MAX_BUFFER_SIZE</code>, <code>PI</code>"},{"location":"conventions/#2-structure-et-complexite","title":"2. Structure et Complexit\u00e9","text":""},{"location":"conventions/#regle-des-3-niveaux","title":"R\u00e8gle des 3 niveaux","text":"<p>L'imbrication (nesting) ne doit jamais d\u00e9passer 3 niveaux de profondeur.</p>"},{"location":"conventions/#clause-de-garde-guard-clause","title":"Clause de Garde (Guard Clause)","text":"<p>Privil\u00e9giez toujours le retour anticip\u00e9 (Early Return) pour r\u00e9duire la complexit\u00e9 et l'imbrication.</p>"},{"location":"conventions/#3-bonnes-pratiques-fichiers-et-performance","title":"3. Bonnes pratiques : Fichiers et Performance","text":""},{"location":"conventions/#31-organisation-une-classe-par-fichier","title":"3.1. Organisation : Une Classe par Fichier","text":"<p>\u00c0 l'instar de Java ou C#, chaque <code>class</code> ou <code>struct</code> doit \u00eatre d\u00e9finie dans son propre couple de fichiers (<code>.hpp</code> et <code>.cpp</code>). - Le fichier d'en-t\u00eate (<code>Article.hpp</code>) contient la d\u00e9claration de la classe. - Le fichier source (<code>Article.cpp</code>) contient son impl\u00e9mentation.</p> <p>Cette s\u00e9paration am\u00e9liore la clart\u00e9, la modularit\u00e9 et acc\u00e9l\u00e8re la compilation en ne recompilant que ce qui a chang\u00e9.</p>"},{"location":"conventions/#32-fichiers-den-tete-et-pragma-once","title":"3.2. Fichiers d'en-t\u00eate et <code>#pragma once</code>","text":"<p>Tout fichier <code>.hpp</code> doit commencer imp\u00e9rativement par <code>#pragma once</code>.</p>"},{"location":"conventions/#33-le-const-et-le-passage-par-reference","title":"3.3. Le <code>const</code> et le passage par r\u00e9f\u00e9rence","text":"<p>Pour les types complexes (<code>string</code>, <code>vector</code>, objets), utilisez toujours le passage par r\u00e9f\u00e9rence constante (<code>const type&amp;</code>) en param\u00e8tre de fonction pour \u00e9viter des copies inutiles en m\u00e9moire.</p>"},{"location":"conventions/#4-documentation-du-code-doxygen","title":"4. Documentation du Code (Doxygen)","text":"<p>Le standard de documentation est Doxygen. Il permet de g\u00e9n\u00e9rer de la documentation externe et est utilis\u00e9 par les IDEs pour afficher l'aide contextuelle.</p>"},{"location":"conventions/#41-ou-documenter","title":"4.1. O\u00f9 documenter ?","text":"<p>\ud83d\udc49 R\u00e8gle absolue : Toujours dans le fichier d'en-t\u00eate (<code>.hpp</code>). Le <code>.hpp</code> est le contrat de votre classe.</p>"},{"location":"conventions/#42-documentation-des-classes-et-structs","title":"4.2. Documentation des Classes et Structs","text":"<p>Chaque <code>class</code> ou <code>struct</code> doit \u00eatre pr\u00e9c\u00e9d\u00e9e d'un bloc <code>/** ... */</code> expliquant son r\u00f4le. - Obligatoire : <code>@brief</code> pour une description courte.</p>"},{"location":"conventions/#43-documentation-des-methodes","title":"4.3. Documentation des M\u00e9thodes","text":"<p>Chaque m\u00e9thode publique dans le <code>.hpp</code> doit \u00eatre pr\u00e9c\u00e9d\u00e9e d'un bloc <code>///</code> d\u00e9crivant son but (<code>@brief</code>), ses param\u00e8tres (<code>@param</code>) et sa valeur de retour (<code>@return</code>).</p>"},{"location":"conventions/#5-exemple-complet-dapplication","title":"5. Exemple Complet d'Application","text":"<p>T\u00e9l\u00e9charger l'exemple complet (ZIP)</p> <p>Voici un exemple concret qui rassemble tous les standards. (Pour commencer la session)</p>"},{"location":"conventions/#51-structure-des-fichiers","title":"5.1. Structure des fichiers","text":"<pre><code>/exemple_commande\n|-- Article.hpp\n|-- Commande.cpp\n|-- Commande.hpp\n|-- main.cpp\n|-- ServiceConnexion.cpp\n`-- ServiceConnexion.hpp\n</code></pre>"},{"location":"conventions/#52-fichiers-den-tete","title":"5.2. Fichiers d'en-t\u00eate","text":"Fichier : <code>Article.hpp</code> <pre><code>#pragma once\n#include &lt;string&gt;\n\n/**\n * @brief Repr\u00e9sente un article simple avec un nom et une quantit\u00e9.\n */\nstruct Article {\n    std::string nom_produit;\n    int quantite_en_stock;\n};\n</code></pre> Fichier : <code>ServiceConnexion.hpp</code> <pre><code>#pragma once\n\n/**\n * @brief Simule une connexion \u00e0 un service externe.\n */\nclass ServiceConnexion {\npublic:\n    /// @brief V\u00e9rifie si la connexion au service est active.\n    /// @return true si le service est disponible, sinon false.\n    bool est_active() const;\n};\n</code></pre> Fichier : <code>Commande.hpp</code> <pre><code>#pragma once\n\n#include &lt;vector&gt;\n#include &lt;string&gt; // N\u00e9cessaire pour std::string dans Article.hpp si pas d\u00e9j\u00e0 inclus par un autre fichier.\n#include \"Article.hpp\"          // D\u00e9pendance vers la structure Article\n#include \"ServiceConnexion.hpp\" // D\u00e9pendance vers la classe ServiceConnexion\n\n// Constante en SCREAMING_SNAKE\nconst int MAX_ARTICLES = 100;\n\n/**\n * @brief Repr\u00e9sente une commande client et ses informations de validation.\n */\nclass Commande { // PascalCase\npublic:\n    /// @brief Construit une nouvelle commande avec un identifiant.\n    /// @param id L'identifiant num\u00e9rique unique de la commande.\n    explicit Commande(int id);\n\n    /// @brief Ajoute un article \u00e0 la commande.\n    /// @param article L'article \u00e0 ajouter (pass\u00e9 par r\u00e9f\u00e9rence constante).\n    void ajouter_article(const Article&amp; article);\n\n    /// @brief V\u00e9rifie si la commande est valide pour \u00eatre trait\u00e9e.\n    /// @return true si la commande a un ID positif et contient des articles.\n    bool est_valide() const;\n\n    /// @brief V\u00e9rifie la disponibilit\u00e9 en stock de tous les articles.\n    /// @return true si tous les articles sont en stock, sinon false.\n    bool a_du_stock() const;\n\n    /// @brief Orchestre le traitement de la commande en appliquant les r\u00e8gles de validation.\n    /// @param connexion Le service de connexion \u00e0 utiliser (r\u00e9f\u00e9rence constante).\n    void traiter_commande(const ServiceConnexion&amp; connexion);\n\nprivate:\n    // Attributs en snake_case\n    int id_commande_;\n    std::vector&lt;Article&gt; articles_;\n\n    // M\u00e9thodes priv\u00e9es en snake_case\n    void envoyer_commande() const;\n    void log_erreur(const std::string&amp; message) const;\n};\n</code></pre>"},{"location":"conventions/#53-fichiers-source","title":"5.3. Fichiers source","text":"Fichier : <code>ServiceConnexion.cpp</code> <pre><code>#include \"ServiceConnexion.hpp\"\n\nbool ServiceConnexion::est_active() const {\n    // Dans un vrai projet, on v\u00e9rifierait une vraie connexion.\n    // Pour l'exemple, on simule qu'elle est toujours active.\n    return true;\n}\n</code></pre> Fichier : <code>Commande.cpp</code> <pre><code>#include \"Commande.hpp\"\n#include &lt;iostream&gt;\n\nCommande::Commande(int id)\n    : id_commande_(id) {\n    // Le constructeur initialise les valeurs par d\u00e9faut.\n    // L'utilisation de la liste d'initialisation est une bonne pratique.\n}\n\nvoid Commande::ajouter_article(const Article&amp; article) {\n    if (articles_.size() &lt; MAX_ARTICLES) {\n        articles_.push_back(article);\n    }\n}\n\nbool Commande::est_valide() const {\n    // Une commande est valide si elle a un ID positif et n'est pas vide.\n    return id_commande_ &gt; 0 &amp;&amp; !articles_.empty();\n}\n\nbool Commande::a_du_stock() const {\n    // V\u00e9rifie si tous les articles de la commande sont en stock.\n    for (const auto&amp; article : articles_) {\n        if (article.quantite_en_stock &lt;= 0) {\n            return false; // Au moins un article est en rupture de stock\n        }\n    }\n    return true; // Tous les articles sont disponibles\n}\n\nvoid Commande::traiter_commande(const ServiceConnexion&amp; connexion) {\n    std::cout &lt;&lt; \"--- Traitement de la commande \" &lt;&lt; id_commande_ &lt;&lt; \" ---\" &lt;&lt; std::endl;\n\n    // Garde 1 : Validation de la commande elle-m\u00eame\n    if (!est_valide()) {\n        log_erreur(\"Commande invalide ou vide.\");\n        return; // Retour anticip\u00e9\n    }\n\n    // Garde 2 : Validation de la connexion\n    if (!connexion.est_active()) {\n        log_erreur(\"Le service de connexion est inactif.\");\n        return; // Retour anticip\u00e9\n    }\n\n    // Garde 3 : Validation du stock\n    if (!a_du_stock()) {\n        log_erreur(\"Un ou plusieurs articles sont en rupture de stock.\");\n        return; // Retour anticip\u00e9\n    }\n\n    // \"Happy Path\" : toutes les v\u00e9rifications ont r\u00e9ussi.\n    // L'indentation est minimale.\n    envoyer_commande();\n\n    std::cout &lt;&lt; std::endl;\n}\n\n// M\u00e9thodes priv\u00e9es\n\nvoid Commande::envoyer_commande() const {\n    std::cout &lt;&lt; \"SUCCES : La commande \" &lt;&lt; id_commande_ &lt;&lt; \" a ete envoyee avec succes.\" &lt;&lt; std::endl;\n}\n\nvoid Commande::log_erreur(const std::string&amp; message) const {\n    std::cout &lt;&lt; \"ERREUR (Cmd \" &lt;&lt; id_commande_ &lt;&lt; \"): \" &lt;&lt; message &lt;&lt; std::endl;\n}\n</code></pre> Fichier : <code>main.cpp</code> <pre><code>#include &lt;iostream&gt;\n#include \"Commande.hpp\" // Inclut Commande.hpp qui lui-m\u00eame inclut Article.hpp et ServiceConnexion.hpp\n\nint main() {\n    ServiceConnexion service_connexion;\n    Article article_disponible = {\"Stylo\", 10};\n    Article article_indisponible = {\"Cahier\", 0};\n\n    std::cout &lt;&lt; \"--- Debut des tests de scenarios ---\" &lt;&lt; std::endl;\n\n    // Sc\u00e9nario 1 : Commande valide\n    Commande cmd_valide(101);\n    cmd_valide.ajouter_article(article_disponible);\n    cmd_valide.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 2 : Article en rupture de stock\n    Commande cmd_stock_epuise(102);\n    cmd_stock_epuise.ajouter_article(article_disponible);\n    cmd_stock_epuise.ajouter_article(article_indisponible);\n    cmd_stock_epuise.traiter_commande(service_connexion);\n\n    // Sc\u00e9nario 3 : Commande invalide (vide)\n    Commande cmd_vide(103);\n    cmd_vide.traiter_commande(service_connexion);\n\n    std::cout &lt;&lt; \"\\n--- Fin des tests ---\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"conventions/#54-compilation-et-resultat","title":"5.4. Compilation et R\u00e9sultat","text":"<p>Pour compiler et ex\u00e9cuter cet exemple :</p> <pre><code>g++ -std=c++20 -Wall -o exemple_commande/exemple exemple_commande/main.cpp exemple_commande/Commande.cpp exemple_commande/ServiceConnexion.cpp\n./exemple_commande/exemple\n</code></pre> <p>Le r\u00e9sultat attendu est :</p> <pre><code>--- Debut des tests de scenarios ---\n\nSUCCES : La commande 101 a ete envoyee avec succes.\n\n--- Traitement de la commande 102 ---\nERREUR (Cmd 102): Un ou plusieurs articles sont en rupture de stock.\n--- Traitement de la commande 103 ---\nERREUR (Cmd 103): Commande invalide ou vide.\n---\n\n--- Fin des tests ---\n</code></pre>"},{"location":"horaire%20-%20Copie/","title":"Horaire du cours de programmation 2","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises 1 1 2025-01-17 2 2025-01-21 2 3 2025-01-24 4 2025-01-28 3 5 2025-01-31 6 2025-02-04 4 7 2025-02-07 Formatif formel 8 2025-02-11 Retour formatif 5 9 2025-02-14 10 2025-02-18 6 11 2025-02-21 Examen 1 12 2025-02-25 7 13 2025-02-28 14 2025-03-11 8 15 2025-03-14 16 2025-03-18 9 17 2025-03-21 18 2025-03-28 10 19 2025-04-01 20 2025-04-04 Examen 2 11 21 2025-04-08 22 2025-04-11 12 23 2025-04-15 24 2025-04-22 13 25 2025-04-24 26 2025-04-29 14 27 2025-05-06 28 2025-05-09 15 29 2025-05-13 30 2025-05-16 Examen final"},{"location":"horaire/","title":"Horaire du cours","text":"<p>Planification de la session Hiver 2026.</p> <p>Remarque importante</p> <p>Les dates de remises sont indiqu\u00e9es par le drapeau \ud83d\udea9. Assurez-vous de v\u00e9rifier cette colonne r\u00e9guli\u00e8rement.</p>"},{"location":"horaire/#partie-1-avant-la-relache","title":"Partie 1 : Avant la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 1 Cours 01 19-01-2026 08:15 Pr\u00e9sentation du plan de cours Cours 02 21-01-2026 13:15 Semaine 2 Cours 03 26-01-2026 08:15 Cours 04 29-01-2026 13:15 Semaine 3 Cours 05 02-02-2026 08:15 Cours 06 05-02-2026 13:15 Semaine 4 Cours 07 09-02-2026 08:15 Cours 08 12-02-2026 13:15 Semaine 5 Cours 09 16-02-2026 08:15 Cours 10 19-02-2026 13:15 Semaine 6 Cours 11 23-02-2026 08:15 Cours 12 26-02-2026 13:15 {: .horaire } <p>\ud83c\udf34 SEMAINE DE REL\u00c2CHE : Du 2 au 6 mars 2026</p> <p>Aucun cours.</p>"},{"location":"horaire/#partie-2-apres-la-relache","title":"Partie 2 : Apr\u00e8s la rel\u00e2che","text":"Semaine Cours Date Sections Mati\u00e8re Bloc Travail \u00e0 faire Remises \ud83d\udea9 Semaine 7 Cours 13 09-03-2026 08:15 Cours 14 12-03-2026 13:15 Semaine 8 Cours 15 16-03-2026 08:15 Cours 16 19-03-2026 13:15 Semaine 9 Cours 17 23-03-2026 08:15 Cours 18 26-03-2026 13:15 Semaine 10 Cours 19 30-03-2026 08:15 Cours 20 02-04-2026 13:15 Prochaine rencontre dans 1 sem. Semaine 11 Cours 21 09-04-2026 13:15 Cours 22 13-04-2026 08:15 Semaine 12 Cours 23 16-04-2026 13:15 Cours 24 20-04-2026 08:15 Semaine 13 Cours 25 27-04-2026 08:15 Cours 26 30-04-2026 13:15 Semaine 14 Cours 27 04-05-2026 08:15 Cours 28 07-05-2026 13:15 Semaine 15 Cours 29 11-05-2026 08:15 Cours 30 14-05-2026 13:15 {: .horaire }"},{"location":"ressources/","title":"Ressources","text":""},{"location":"ressources/#documentation-officielle","title":"Documentation officielle","text":"<p>C# documentation officielle : https://learn.microsoft.com/fr-ca/dotnet/csharp/tour-of-csharp/</p> <p>.Net 8.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-8.0</p> <p>.Net 9.0 : https://learn.microsoft.com/fr-ca/dotnet/api/?view=net-9.0</p> <p>Tests unitaires MSTest : https://learn.microsoft.com/fr-ca/dotnet/core/testing/unit-testing-with-mstest </p> <p>Table ASCII : https://www.asciitable.com/</p>"},{"location":"exercices/exercice_semaine_1_1/","title":"Exercices de la Semaine 1 : Les Bases","text":"<p>Ces exercices sont con\u00e7us pour pratiquer les concepts de base vus dans les notes de la semaine 1. Concentrez-vous sur la ma\u00eetrise de la compilation, de l'affichage, de la saisie et des fonctions simples.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-1-affichage-et-saisie-simple","title":"Bloc 1 : Affichage et Saisie Simple","text":"<p>Exercice 1 : Bonjour le Monde - Objectif : Cr\u00e9er un programme C++ de base. - T\u00e2che : \u00c9crivez un programme qui affiche \"Bonjour le monde !\" dans la console et qui se termine en retournant <code>0</code>.</p> <p>Exercice 2 : Fiche de Pr\u00e9sentation - Objectif : Manipuler <code>std::cout</code> avec plusieurs lignes. - T\u00e2che : \u00c9crivez un programme qui affiche votre nom, votre ville et votre \u00e2ge sur des lignes s\u00e9par\u00e9es.</p> <p>Exercice 3 : D\u00e9claration de Variables - Objectif : Se familiariser avec les types primitifs. - T\u00e2che : D\u00e9clarez quatre variables : un <code>int</code>, un <code>double</code>, un <code>char</code>, et un <code>bool</code>. Assignez-leur des valeurs de votre choix et affichez chaque valeur avec une description.</p> <p>Exercice 4 : Interaction Simple - Objectif : Utiliser <code>std::cin &gt;&gt;</code> avec <code>std::string</code> et <code>int</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur son pr\u00e9nom et son ann\u00e9e de naissance. Calculez (approximativement) son \u00e2ge et affichez un message comme <code>\"Bonjour [Pr\u00e9nom], vous avez environ [Age] ans.\"</code>.</p> <p>Exercice 5 : Calcul d'Aire - Objectif : Utiliser des types <code>double</code> avec <code>std::cin</code>. - T\u00e2che : Demandez \u00e0 l'utilisateur la largeur et la hauteur d'un rectangle. Calculez et affichez son aire.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-2-gestion-du-buffer-et-erreurs-de-saisie","title":"Bloc 2 : Gestion du Buffer et Erreurs de Saisie","text":"<p>Exercice 6 : Le Pi\u00e8ge de <code>getline</code> - Objectif : R\u00e9soudre le conflit entre <code>std::cin &gt;&gt;</code> et <code>std::getline</code>. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur son num\u00e9ro de porte (un <code>int</code>).   2. Demandez-lui ensuite son nom de rue complet (un <code>std::string</code> avec <code>getline</code>).   3. Observez que le programme ignore la saisie de la rue.   4. Corrigez le probl\u00e8me en nettoyant le buffer apr\u00e8s la lecture du nombre.</p> <p>Exercice 7 : Gestion d'Erreur Simple - Objectif : Utiliser <code>std::cin.fail()</code> pour d\u00e9tecter une erreur. - T\u00e2che : Demandez \u00e0 l'utilisateur d'entrer un nombre. Si la saisie \u00e9choue (si l'utilisateur tape du texte), affichez \"Erreur : saisie invalide.\". Sinon, affichez \"Merci !\".</p> <p>Exercice 8 : Boucle de Saisie Robuste - Objectif : Cr\u00e9er une boucle qui force une saisie num\u00e9rique valide. - T\u00e2che : Cr\u00e9ez une boucle <code>while</code> qui continue de demander \"Entrez votre age :\" jusqu'\u00e0 ce que l'utilisateur entre un nombre entier valide. Si l'utilisateur se trompe, le programme doit afficher une erreur et lui redemander.</p> <p>Exercice 9 : Analyse d'Entr\u00e9e Mixte - Objectif : Comprendre comment <code>cin</code> g\u00e8re les lectures partielles. - T\u00e2che :   1. Demandez \u00e0 l'utilisateur un nombre. L'utilisateur doit taper <code>45abc</code>.   2. Lisez la saisie dans une variable de type <code>int</code>.   3. Affichez l'entier que vous avez r\u00e9ussi \u00e0 lire.   4. Ensuite, lisez le reste du buffer dans une variable <code>std::string</code>.   5. Affichez la cha\u00eene de caract\u00e8res. Le r\u00e9sultat devrait vous montrer ce qui restait dans le buffer.</p>"},{"location":"exercices/exercice_semaine_1_1/#bloc-3-fonctions-et-tableaux","title":"Bloc 3 : Fonctions et Tableaux","text":"<p>Exercice 10 : Calculatrice Simple - Objectif : \u00c9crire et appeler des fonctions simples. - T\u00e2che : \u00c9crivez quatre fonctions : <code>addition(int a, int b)</code>, <code>soustraction(int a, int b)</code>, <code>multiplication(int a, int b)</code>, et <code>division(int a, int b)</code>. Chaque fonction doit retourner le r\u00e9sultat du calcul. Dans <code>main</code>, testez chaque fonction avec des valeurs de votre choix et affichez les r\u00e9sultats.</p> <p>Exercice 11 : Passage par Copie - Objectif : Constater l'effet d'un passage par copie. - T\u00e2che :   1. \u00c9crivez une fonction <code>ajouter_vingt(int nombre)</code> qui re\u00e7oit un entier, lui ajoute 20, et n'a pas de <code>return</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur</code> \u00e0 <code>10</code>.   3. Appelez <code>ajouter_vingt(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 12 : Passage par R\u00e9f\u00e9rence - Objectif : Utiliser une r\u00e9f\u00e9rence pour modifier une variable externe. - T\u00e2che :   1. \u00c9crivez une fonction <code>reinitialiser(int&amp; nombre)</code> qui change la valeur de l'entier re\u00e7u \u00e0 <code>0</code>.   2. Dans <code>main</code>, initialisez une variable <code>ma_valeur</code> \u00e0 <code>123</code>.   3. Appelez <code>reinitialiser(ma_valeur)</code>.   4. Affichez <code>ma_valeur</code> apr\u00e8s l'appel. A-t-elle chang\u00e9 ? Pourquoi ?</p> <p>Exercice 13 : Somme d'un Tableau - Objectif : Passer un tableau \u00e0 une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>calculer_somme(const int tableau[], int taille)</code> qui retourne la somme de tous les \u00e9l\u00e9ments d'un tableau. Dans <code>main</code>, initialisez un tableau, trouvez sa taille avec <code>std::ssize</code>, et affichez la somme retourn\u00e9e par votre fonction.</p> <p>Exercice 14 : Trouver le Maximum - Objectif : Parcourir un tableau dans une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>trouver_max(const int tableau[], int taille)</code> qui retourne la plus grande valeur d'un tableau. Testez-la dans <code>main</code>.</p> <p>Exercice 15 : Inversion de Tableau - Objectif : Modifier un tableau via une fonction. - T\u00e2che : Cr\u00e9ez une fonction <code>inverser_tableau(int tableau[], int taille)</code> qui inverse les \u00e9l\u00e9ments du tableau sur place (le premier devient le dernier, etc.). Dans <code>main</code>, d\u00e9clarez un tableau, affichez-le, appelez la fonction, puis affichez-le \u00e0 nouveau pour voir le changement. (Exemple : <code>{1, 2, 3, 4, 5}</code> devient <code>{5, 4, 3, 2, 1}</code>).</p>"},{"location":"notes/semaine_1/","title":"Notes de la Semaine 1","text":""},{"location":"notes/semaine_1/#sujets-abordes","title":"Sujets Abord\u00e9s","text":"<ul> <li>Pr\u00e9sentation du cours</li> <li>Environnement de d\u00e9veloppement C++ (IDE, compilateur)</li> <li>Concepts de base du C++ (variables, types, op\u00e9rateurs)</li> </ul>"},{"location":"notes/semaine_1/#exercices-et-laboratoires","title":"Exercices et Laboratoires","text":"<ul> <li>Configuration de l'environnement</li> <li>Premiers programmes \"Hello World\"</li> </ul>"},{"location":"notes/semaine_1/#remarques","title":"Remarques","text":"<ul> <li>Assurez-vous que votre environnement de d\u00e9veloppement est fonctionnel avant le prochain cours.</li> <li>Consultez le plan de cours pour les lectures et pr\u00e9parations.</li> </ul>"},{"location":"notes/semaine_1/#la-fonction-main-en-c","title":"La fonction <code>main()</code> en C++","text":"<p>La fonction <code>main()</code> est le point d'entr\u00e9e de chaque programme C++. C'est l\u00e0 que l'ex\u00e9cution de votre code commence.</p>"},{"location":"notes/semaine_1/#main-sans-arguments","title":"<code>main()</code> sans arguments","text":"<p>La forme la plus simple de <code>main()</code> ne prend pas d'arguments. <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Bonjour !\" &lt;&lt; std::endl;\n    return 0; // Indique que le programme s'est ex\u00e9cut\u00e9 avec succ\u00e8s\n}\n</code></pre></p>"},{"location":"notes/semaine_1/#return-int-vs-void-main-c","title":"<code>return int</code> vs <code>void Main</code> (C#)","text":"<p>Contrairement \u00e0 C# o\u00f9 la fonction <code>Main</code> peut \u00eatre <code>void</code>, la fonction <code>main()</code> en C++ doit retourner un <code>int</code>.</p> <ul> <li><code>return 0;</code> : Conventionnellement, un retour de <code>0</code> indique que le programme s'est termin\u00e9 avec succ\u00e8s.</li> <li><code>return un_nombre_non_nul;</code> : Un retour diff\u00e9rent de <code>0</code> (ex: <code>1</code>) indique qu'une erreur s'est produite. Ce code peut \u00eatre utilis\u00e9 par d'autres programmes ou scripts pour d\u00e9tecter un probl\u00e8me.</li> </ul>"},{"location":"notes/semaine_1/#entrees-et-sorties-en-c-avec-iostream","title":"Entr\u00e9es et Sorties en C++ avec <code>iostream</code>","text":"<p>La m\u00e9thode standard et s\u00e9curitaire pour g\u00e9rer les entr\u00e9es et sorties en C++ est la biblioth\u00e8que <code>&lt;iostream&gt;</code>. Elle utilise des flux (<code>streams</code>) pour envoyer ou recevoir des donn\u00e9es.</p> <ul> <li><code>std::cout</code> : Flux de sortie standard (g\u00e9n\u00e9ralement la console).</li> <li><code>std::cin</code> : Flux d'entr\u00e9e standard (g\u00e9n\u00e9ralement le clavier).</li> <li><code>std::endl</code> : Ins\u00e8re un retour \u00e0 la ligne (<code>\\n</code>) et vide le tampon de sortie.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n    std::string nom;\n    std::cout &lt;&lt; \"Entrez votre nom : \";\n    std::cin &gt;&gt; nom;\n\n    std::cout &lt;&lt; \"Bonjour \" &lt;&lt; nom &lt;&lt; \" !\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1/#piege-n1-melanger-cin-et-getline","title":"Pi\u00e8ge n\u00b01 : M\u00e9langer <code>cin &gt;&gt;</code> et <code>getline</code>","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> lit les donn\u00e9es jusqu'au premier espace blanc (espace, tabulation, retour \u00e0 la ligne). Le reste, y compris le <code>\\n</code> que vous tapez avec <code>Entr\u00e9e</code>, reste dans le buffer (tampon) d'entr\u00e9e.</p> <p>\u274c Code probl\u00e9matique : <pre><code>int age;\nstd::string nom_complet;\n\nstd::cout &lt;&lt; \"Entrez votre age : \";\nstd::cin &gt;&gt; age; // L'utilisateur tape \"25\" puis \"Entr\u00e9e\".\n                 // \"25\" est lu, mais \"\\n\" reste dans le buffer.\n\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // getline() voit le \"\\n\" restant et croit\n                                     // que l'utilisateur a d\u00e9j\u00e0 entr\u00e9 une ligne vide.\n                                     // Il ne demande pas d'input.\n\nstd::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;\n// Affiche : Age: 25, Nom: ''\n</code></pre></p> <p>\u2705 Solution : Vider le buffer avant <code>getline</code> On utilise <code>std::cin.ignore()</code> pour ignorer les caract\u00e8res restants dans le buffer, notamment le <code>\\n</code>.</p> <pre><code>// ... apr\u00e8s std::cin &gt;&gt; age;\nstd::cin.ignore(); // Ignore le caract\u00e8re \\n restant\nstd::cout &lt;&lt; \"Entrez votre nom complet : \";\nstd::getline(std::cin, nom_complet); // Fonctionne comme pr\u00e9vu\n</code></pre>"},{"location":"notes/semaine_1/#piege-n2-erreur-de-type-lettres-pour-un-nombre","title":"Pi\u00e8ge n\u00b02 : Erreur de type (lettres pour un nombre)","text":"<p>Si l'utilisateur entre des lettres alors que <code>std::cin &gt;&gt;</code> s'attend \u00e0 un <code>int</code>, le flux <code>cin</code> entre en \u00e9tat d'erreur (<code>failbit</code>). Toute tentative de lecture ult\u00e9rieure \u00e9chouera tant que l'erreur n'est pas corrig\u00e9e et le buffer vid\u00e9.</p> <p>Pour g\u00e9rer robustement les erreurs de saisie :</p> <ol> <li>V\u00e9rifier l'\u00e9tat de <code>cin</code> : Boucler tant que la lecture \u00e9choue.</li> <li>Nettoyer les indicateurs d'erreur : <code>std::cin.clear()</code> r\u00e9initialise l'\u00e9tat de <code>cin</code>.</li> <li>Vider le buffer : <code>std::cin.ignore(...)</code> jette le contenu invalide.</li> </ol> <p>\u2705 Solution robuste :</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt; // Requis pour numeric_limits\n\nint main() {\n    int age = 0;\n\n    // Boucle tant que l'entr\u00e9e est invalide\n    while (true) {\n        std::cout &lt;&lt; \"Veuillez entrer votre age : \";\n        std::cin &gt;&gt; age;\n\n        if (std::cin.good()) {\n            // La saisie est un nombre valide, on peut sortir de la boucle.\n            break; \n        }\n\n        // Si on arrive ici, la saisie a \u00e9chou\u00e9.\n        std::cout &lt;&lt; \"Erreur : Veuillez entrer un nombre valide.\" &lt;&lt; std::endl;\n\n        // 1. Nettoyer l'indicateur d'erreur de cin\n        std::cin.clear();\n\n        // 2. Vider le buffer d'entr\u00e9e\n        // On ignore tous les caract\u00e8res jusqu'\u00e0 la prochaine fin de ligne '\\n'.\n        // C'est la mani\u00e8re idiomatique et s\u00e9curitaire de le faire.\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n    }\n\n    std::cout &lt;&lt; \"Vous avez \" &lt;&lt; age &lt;&lt; \" ans.\" &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Attention aux Nombres Magiques</p> <p>Vous verrez parfois <code>std::cin.ignore(10000, '\\n');</code>. C'est une mauvaise pratique. On suppose arbitrairement que l'utilisateur ne tapera pas plus de 10 000 caract\u00e8res invalides. </p> <p>La m\u00e9thode correcte, <code>std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');</code>, est la fa\u00e7on C++ standard de dire \"ignorer autant de caract\u00e8res que n\u00e9cessaire\". Elle ne repose sur aucune supposition.</p>"},{"location":"notes/semaine_1_1/","title":"Les Types de Donn\u00e9es en C++ (Partie 1)","text":"<p>Cette section couvre les types de donn\u00e9es fondamentaux en C++, en se concentrant sur les diff\u00e9rences avec d'autres langages comme C# ou Java.</p>"},{"location":"notes/semaine_1_1/#1-les-types-primitifs","title":"1. Les Types Primitifs","text":"Type Description Exemple de valeur <code>int</code> Nombre entier. <code>42</code>, <code>-10</code> <code>double</code> Nombre \u00e0 virgule flottante (double pr\u00e9cision). <code>3.14159</code>, <code>-0.01</code> <code>char</code> Un seul caract\u00e8re, entour\u00e9 d'apostrophes (<code>'</code>). <code>'A'</code>, <code>'!'</code> <code>bool</code> Valeur bool\u00e9enne, peut \u00eatre <code>true</code> ou <code>false</code>. <code>true</code>, <code>false</code>"},{"location":"notes/semaine_1_1/#2-les-chaines-de-caracteres","title":"2. Les Cha\u00eenes de Caract\u00e8res","text":""},{"location":"notes/semaine_1_1/#le-stdstring-style-c-moderne","title":"Le <code>std::string</code> (Style C++ Moderne)","text":"<p>C'est la m\u00e9thode fortement recommand\u00e9e. Pour l'utiliser, il faut inclure <code>&lt;string&gt;</code>.</p>"},{"location":"notes/semaine_1_1/#les-chaines-de-caracteres-c-style-char","title":"Les Cha\u00eenes de Caract\u00e8res C-style (<code>char*</code>)","text":"<p>Comprendre les cha\u00eenes C-style (tableaux de <code>char</code>) est essentiel car <code>std::string</code> les utilise en arri\u00e8re-plan. L'objectif du cours est de vous amener \u00e0 coder votre propre classe <code>String</code>.</p>"},{"location":"notes/semaine_1_1/#3-les-tableaux-statiques","title":"3. Les Tableaux Statiques (<code>[]</code>)","text":"<p>En C++, un tableau statique est un bloc de m\u00e9moire de taille fixe. Ce n'est pas un objet comme en C# ou Java. Sa taille, d\u00e9finie \u00e0 la compilation, ne peut pas changer.</p> <p>Pas de v\u00e9rification de limites</p> <p>Le C++ ne vous emp\u00eachera pas d'\u00e9crire en dehors des limites d'un tableau (ex: <code>notes[5]</code> pour un tableau de 5 \u00e9l\u00e9ments). C'est une source d'erreurs majeure.</p>"},{"location":"notes/semaine_1_1/#4-utiliser-les-tableaux-avec-des-fonctions","title":"4. Utiliser les Tableaux avec des Fonctions","text":""},{"location":"notes/semaine_1_1/#le-probleme-la-taille-est-perdue","title":"Le Probl\u00e8me : La Taille est Perdue","text":"<p>Quand vous passez un tableau \u00e0 une fonction, C++ ne transmet qu'un pointeur vers le premier \u00e9l\u00e9ment. Toute information sur sa taille est perdue. <pre><code>// MAUVAIS : Cette fonction ne peut PAS conna\u00eetre la taille du tableau.\nvoid afficher_notes(int notes[]) {\n    // int taille = std::size(notes); // NE COMPILE PAS !\n}\n</code></pre></p>"},{"location":"notes/semaine_1_1/#determiner-la-taille-dun-tableau-localement","title":"D\u00e9terminer la taille d'un tableau (localement)","text":"<p>Il existe plusieurs fa\u00e7ons de trouver la taille d'un tableau statique, mais seulement dans le scope o\u00f9 il est d\u00e9clar\u00e9.</p>"},{"location":"notes/semaine_1_1/#la-methode-c20-recommandee-stdssize","title":"La m\u00e9thode C++20 (Recommand\u00e9e) : <code>std::ssize</code>","text":"<p>Depuis C++20, la fonction <code>std::ssize()</code> (de <code>&lt;iterator&gt;</code>) est la meilleure m\u00e9thode. Elle est simple, s\u00fbre, et retourne un type sign\u00e9 (<code>std::ptrdiff_t</code>), ce qui \u00e9vite des bogues potentiels avec les boucles.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt; // Pour std::ssize\n\nint main() {\n    int notes_cours[] = {80, 85, 90, 75, 88};\n\n    // Obtient la taille sign\u00e9e du tableau (m\u00e9thode pr\u00e9f\u00e9r\u00e9e)\n    auto taille = std::ssize(notes_cours);\n\n    std::cout &lt;&lt; \"La taille du tableau est : \" &lt;&lt; taille &lt;&lt; std::endl; // Affiche 5\n\n    for (int i = 0; i &lt; taille; ++i) {\n        std::cout &lt;&lt; notes_cours[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_1/#les-methodes-precedentes","title":"Les m\u00e9thodes pr\u00e9c\u00e9dentes","text":"<ul> <li>C++17 (<code>std::size</code>) : Similaire \u00e0 <code>std::ssize</code>, mais retourne un type non sign\u00e9. <code>std::ssize</code> est g\u00e9n\u00e9ralement pr\u00e9f\u00e9rable.</li> <li>Style C (<code>sizeof</code>) : <code>int taille = sizeof(notes_cours) / sizeof(int);</code>. Cette m\u00e9thode est verbeuse et sujette aux erreurs. Il faut l'\u00e9viter en C++ moderne.</li> </ul> <p><code>std::ssize</code>, <code>std::size</code> et <code>sizeof</code> ne fonctionnent que localement !</p> <p>Ces trois m\u00e9thodes ne fonctionnent que si le tableau est d\u00e9clar\u00e9 dans le m\u00eame scope. D\u00e8s que vous passez le tableau \u00e0 une fonction, il \"d\u00e9g\u00e9n\u00e8re\" en pointeur et ces outils deviennent inutilisables pour trouver sa taille.</p>"},{"location":"notes/semaine_1_1/#la-solution-generale-passer-la-taille-en-parametre","title":"La Solution G\u00e9n\u00e9rale : Passer la taille en param\u00e8tre","text":"<p>Puisque la taille est perdue lorsqu'on passe un tableau, la convention est de toujours passer la taille comme un param\u00e8tre suppl\u00e9mentaire.</p> <p>\u2705 Code correct pour les fonctions : <pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\n// La fonction re\u00e7oit le tableau (en tant que pointeur) ET sa taille\nvoid afficher_moyenne(const int notes[], std::size_t taille) {\n    if (taille == 0) return;\n\n    double somme = 0.0;\n    for (std::size_t i = 0; i &lt; taille; ++i) {\n        somme += notes[i];\n    }\n    std::cout &lt;&lt; \"La moyenne est : \" &lt;&lt; somme / taille &lt;&lt; std::endl;\n}\n\nint main() {\n    int notes_cours_1[] = {80, 85, 90};\n    int notes_cours_2[] = {75, 82, 68, 91, 88};\n\n    // On utilise std::ssize (C++20) pour obtenir la taille et la passer \u00e0 la fonction\n    afficher_moyenne(notes_cours_1, std::ssize(notes_cours_1));\n    afficher_moyenne(notes_cours_2, std::ssize(notes_cours_2));\n\n    return 0;\n}\n</code></pre> Cette technique est fondamentale pour manipuler des tableaux de mani\u00e8re s\u00e9curitaire en C++.</p>"},{"location":"notes/semaine_1_2/","title":"Comprendre <code>std::cin</code> : La Saisie Simple en C++","text":"<p>Cette section vous aidera \u00e0 ma\u00eetriser <code>std::cin</code> pour obtenir des informations de l'utilisateur, en \u00e9vitant les pi\u00e8ges courants.</p>"},{"location":"notes/semaine_1_2/#1-comment-fonctionne-stdcin-et-le-buffer-dentree","title":"1. Comment fonctionne <code>std::cin</code> et le \"Buffer\" d'entr\u00e9e ?","text":"<p>Quand vous tapez au clavier, vos caract\u00e8res ne vont pas directement dans vos variables. Ils sont d'abord mis de c\u00f4t\u00e9 dans une zone d'attente appel\u00e9e le \"buffer\" d'entr\u00e9e. - <code>std::cin</code> va chercher les donn\u00e9es dans ce buffer. - Quand vous appuyez sur <code>Entr\u00e9e</code>, tous les caract\u00e8res tap\u00e9s (y compris <code>\\n</code>) sont envoy\u00e9s dans le buffer. - <code>std::cin</code> va alors lire ce dont il a besoin.</p>"},{"location":"notes/semaine_1_2/#2-lire-differents-types-de-donnees","title":"2. Lire Diff\u00e9rents Types de Donn\u00e9es","text":""},{"location":"notes/semaine_1_2/#a-lire-un-mot-ou-un-nombre-stdcin","title":"a) Lire un mot ou un nombre (<code>std::cin &gt;&gt;</code>)","text":"<p>L'op\u00e9rateur <code>&gt;&gt;</code> est le plus simple. Il lit des mots ou des nombres, en s'arr\u00eatant au premier espace blanc (<code></code>, <code>\\t</code>, <code>\\n</code>). Le caract\u00e8re d'espacement reste dans le buffer.</p>"},{"location":"notes/semaine_1_2/#b-lire-une-ligne-complete-stdgetline","title":"b) Lire une ligne compl\u00e8te (<code>std::getline</code>)","text":"<p><code>std::getline(std::cin, ma_string)</code> lit une phrase enti\u00e8re, espaces inclus, jusqu'\u00e0 <code>\\n</code>. Il consomme et supprime le <code>\\n</code> du buffer.</p>"},{"location":"notes/semaine_1_2/#3-le-piege-courant-suivi-de-getline","title":"3. Le Pi\u00e8ge Courant : <code>&gt;&gt;</code> suivi de <code>getline</code>","text":"<p>Si vous utilisez <code>std::cin &gt;&gt;</code> pour lire un nombre, le <code>\\n</code> reste dans le buffer. Un <code>std::getline</code> juste apr\u00e8s le verra et s'arr\u00eatera imm\u00e9diatement, pensant que vous avez entr\u00e9 une ligne vide.</p> <p>La solution est de toujours nettoyer le buffer apr\u00e8s un <code>std::cin &gt;&gt;</code> si une lecture de ligne doit suivre. <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;limits&gt;\n\nint main() {\n    int age;\n    std::string nom_complet;\n\n    std::cout &lt;&lt; \"Entrez votre age : \";\n    std::cin &gt;&gt; age; \n\n    // On nettoie le buffer du '\\n' et de tout autre caract\u00e8re restant\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    std::cout &lt;&lt; \"Entrez votre nom complet : \";\n    std::getline(std::cin, nom_complet);\n\n    std::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; \", Nom: '\" &lt;&lt; nom_complet &lt;&lt; \"'\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p>"},{"location":"notes/semaine_1_2/#4-gerer-les-erreurs-lectures-partielles-et-echecs","title":"4. G\u00e9rer les Erreurs : Lectures Partielles et \u00c9checs","text":""},{"location":"notes/semaine_1_2/#cas-1-on-veut-un-int-on-recoit-45abc","title":"Cas 1 : On veut un <code>int</code>, on re\u00e7oit <code>45abc</code>","text":"<p>Le code : <pre><code>int age;\nstd::cin &gt;&gt; age;\n</code></pre> Ce qui se passe : 1.  Le Buffer contient : <code>['4', '5', 'a', 'b', 'c', '\\n']</code> 2.  <code>cin</code> lit <code>4</code>, puis <code>5</code>. 3.  <code>cin</code> voit le <code>a</code>. Ce n'est pas un chiffre. Il s'arr\u00eate avant le <code>a</code>.</p> <p>Le R\u00e9sultat : - Variable <code>age</code> : Vaut <code>45</code>. La lecture est un succ\u00e8s partiel. - \u00c9tat du Buffer : Il reste <code>'a', 'b', 'c', '\\n'</code> \u00e0 l'int\u00e9rieur. - Danger \u26a0\ufe0f : La prochaine lecture par <code>cin</code> commencera sur le <code>a</code>, ce qui causera probablement une erreur si elle attend un nombre.</p>"},{"location":"notes/semaine_1_2/#cas-2-on-veut-une-string-on-recoit-abc45","title":"Cas 2 : On veut une <code>string</code>, on re\u00e7oit <code>abc45</code>","text":"<p>Le code : <pre><code>std::string texte;\nstd::cin &gt;&gt; texte;\n</code></pre> Ce qui se passe : 1.  Le Buffer contient : <code>['a', 'b', 'c', '4', '5', '\\n']</code> 2.  <code>cin</code> lit <code>a</code>, <code>b</code>, <code>c</code>. Ce sont des caract\u00e8res valides pour une <code>string</code>. 3.  <code>cin</code> lit <code>4</code>, <code>5</code>. Ce sont aussi des caract\u00e8res valides. 4.  <code>cin</code> voit le <code>\\n</code>. C'est un \"espace blanc\". Il s'arr\u00eate.</p> <p>Le R\u00e9sultat : - Variable <code>texte</code> : Vaut <code>\"abc45\"</code>. - \u00c9tat du Buffer : Il reste <code>\\n</code> \u00e0 l'int\u00e9rieur.</p>"},{"location":"notes/semaine_1_2/#le-nettoyage-la-solution-de-pro","title":"Le \"Nettoyage\" (La solution de pro)","text":"<p>Voici une structure de code qui g\u00e8re \u00e0 la fois les lectures partielles (comme <code>45abc</code>) et les \u00e9checs totaux (comme <code>abc45</code>).</p> <p><pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;limits&gt;\n\nint main() {\n    int age = 0;\n    std::cout &lt;&lt; \"Entrez votre age (ex: 45, 45abc, abc45) : \";\n\n    // On tente de lire un entier. 'if (std::cin &gt;&gt; age)' est vrai seulement si la lecture r\u00e9ussit.\n    if (std::cin &gt;&gt; age) {\n        // SUCC\u00c8S : On a lu au moins un nombre (cas '45' ou '45abc')\n        std::cout &lt;&lt; \"Partie numerique lue : \" &lt;&lt; age &lt;&lt; std::endl;\n\n    } else {\n        // \u00c9CHEC : L'utilisateur n'a pas commenc\u00e9 par un chiffre (cas 'abc45')\n        std::cout &lt;&lt; \"Erreur : Saisie invalide. Aucune valeur numerique lue.\" &lt;&lt; std::endl;\n\n        // 1. On r\u00e9pare le cin qui est en \u00e9tat d'erreur\n        std::cin.clear(); \n    }\n\n    // 2. Dans tous les cas (succ\u00e8s partiel ou \u00e9chec), on vide le reste du buffer\n    // pour \u00eatre pr\u00eat pour la prochaine saisie.\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\n\n    // On peut maintenant faire une autre saisie en toute s\u00e9curit\u00e9\n    std::string autre_saisie;\n    std::cout &lt;&lt; \"Entrez autre chose pour continuer : \";\n    std::cin &gt;&gt; autre_saisie;\n    std::cout &lt;&lt; \"Vous avez entre : \" &lt;&lt; autre_saisie &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> Cette approche qui consiste \u00e0 toujours vider le buffer apr\u00e8s une lecture est la plus robuste pour \u00e9viter les erreurs en cascade.</p>"},{"location":"notes/semaine_1_3/","title":"Passage par Copie vs. Passage par R\u00e9f\u00e9rence","text":"<p>Comprendre comment les donn\u00e9es sont pass\u00e9es aux fonctions est l'un des concepts les plus importants en C++. Cela d\u00e9termine si une fonction peut modifier une variable originale ou si elle travaille sur une simple copie.</p>"},{"location":"notes/semaine_1_3/#1-le-passage-par-copie-pass-by-value","title":"1. Le Passage par Copie (Pass-by-Value)","text":"<p>C'est le comportement par d\u00e9faut pour les types simples (<code>int</code>, <code>double</code>, <code>char</code>, etc.).</p> <ul> <li>Principe : La fonction re\u00e7oit une copie de la variable que vous lui passez. Elle ne re\u00e7oit jamais l'original.</li> <li>Analogie : C'est comme donner une photocopie d'un document \u00e0 quelqu'un. La personne peut \u00e9crire sur la photocopie, la d\u00e9chirer... votre document original reste intact.</li> </ul>"},{"location":"notes/semaine_1_3/#exemple-avec-un-int","title":"Exemple avec un <code>int</code>","text":"<p><pre><code>#include &lt;iostream&gt;\n\n// La fonction re\u00e7oit une COPIE de la valeur.\nvoid ajouter_dix_copie(int nombre) {\n    nombre = nombre + 10; // On modifie la copie locale.\n    std::cout &lt;&lt; \" (Dans la fonction copie, la valeur est maintenant \" &lt;&lt; nombre &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n</code></pre> Ici, <code>nombre</code> est une toute nouvelle variable qui existe uniquement \u00e0 l'int\u00e9rieur de la fonction <code>ajouter_dix_copie</code>. Elle est initialis\u00e9e avec la valeur qui lui est pass\u00e9e, mais c'est tout.</p>"},{"location":"notes/semaine_1_3/#2-le-passage-par-reference-pass-by-reference","title":"2. Le Passage par R\u00e9f\u00e9rence (Pass-by-Reference)","text":"<p>Le passage par r\u00e9f\u00e9rence permet \u00e0 une fonction d'acc\u00e9der directement \u00e0 la variable originale. On utilise le symbole <code>&amp;</code> dans la d\u00e9claration du param\u00e8tre de la fonction pour indiquer qu'on veut une r\u00e9f\u00e9rence.</p> <ul> <li>Principe : La fonction re\u00e7oit une r\u00e9f\u00e9rence (un alias, un \"surnom\") vers la variable originale. Toute modification faite via cette r\u00e9f\u00e9rence affecte la variable originale.</li> <li>Analogie : C'est comme envoyer un lien de partage Google Docs avec les droits d'\u00e9dition. Si la personne modifie le document via le lien, c'est bien le document original qui est modifi\u00e9.</li> </ul>"},{"location":"notes/semaine_1_3/#exemple-avec-un-int_1","title":"Exemple avec un <code>int&amp;</code>","text":"<p><pre><code>#include &lt;iostream&gt;\n\n// Le '&amp;' indique que la fonction re\u00e7oit une R\u00c9F\u00c9RENCE vers la variable originale.\nvoid ajouter_dix_reference(int&amp; nombre) {\n    nombre = nombre + 10; // On modifie directement la variable originale.\n    std::cout &lt;&lt; \" (Dans la fonction reference, la valeur est maintenant \" &lt;&lt; nombre &lt;&lt; \")\" &lt;&lt; std::endl;\n}\n</code></pre> Ici, <code>nombre</code> n'est pas une nouvelle variable, c'est un autre nom pour la variable qui a \u00e9t\u00e9 pass\u00e9e depuis le <code>main</code>.</p>"},{"location":"notes/semaine_1_3/#3-demonstration-copie-vs-reference","title":"3. D\u00e9monstration : Copie vs. R\u00e9f\u00e9rence","text":"<p>Voyons l'impact de ces deux m\u00e9thodes sur les variables dans la fonction <code>main</code>.</p> <pre><code>#include &lt;iostream&gt;\n\n// Fonction qui re\u00e7oit une copie\nvoid ajouter_dix_copie(int nombre) {\n    nombre += 10;\n    std::cout &lt;&lt; \"Valeur dans la fonction (copie) : \" &lt;&lt; nombre &lt;&lt; std::endl;\n}\n\n// Fonction qui re\u00e7oit une r\u00e9f\u00e9rence\nvoid ajouter_dix_reference(int&amp; nombre) {\n    nombre += 10;\n    std::cout &lt;&lt; \"Valeur dans la fonction (reference) : \" &lt;&lt; nombre &lt;&lt; std::endl;\n}\n\n\nint main() {\n    // --- Test avec le passage par copie ---\n    int ma_variable_copie = 20;\n    std::cout &lt;&lt; \"1. Avant l'appel (copie), ma_variable_copie = \" &lt;&lt; ma_variable_copie &lt;&lt; std::endl;\n    ajouter_dix_copie(ma_variable_copie);\n    std::cout &lt;&lt; \"3. Apres l'appel (copie), ma_variable_copie = \" &lt;&lt; ma_variable_copie &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; \"\\n-----------------------------------\\n\\n\";\n\n    // --- Test avec le passage par r\u00e9f\u00e9rence ---\n    int ma_variable_reference = 20;\n    std::cout &lt;&lt; \"1. Avant l'appel (reference), ma_variable_reference = \" &lt;&lt; ma_variable_reference &lt;&lt; std::endl;\n    ajouter_dix_reference(ma_variable_reference);\n    std::cout &lt;&lt; \"3. Apres l'appel (reference), ma_variable_reference = \" &lt;&lt; ma_variable_reference &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#resultat-du-programme","title":"R\u00e9sultat du programme :","text":"<p><pre><code>1. Avant l'appel (copie), ma_variable_copie = 20\nValeur dans la fonction (copie) : 30\n3. Apres l'appel (copie), ma_variable_copie = 20\n\n-----------------------------------\n\n1. Avant l'appel (reference), ma_variable_reference = 20\nValeur dans la fonction (reference) : 30\n3. Apres l'appel (reference), ma_variable_reference = 30\n</code></pre> Conclusion : - La variable pass\u00e9e par copie est rest\u00e9e intacte (20). - La variable pass\u00e9e par r\u00e9f\u00e9rence a \u00e9t\u00e9 modifi\u00e9e de mani\u00e8re permanente (30).</p>"},{"location":"notes/semaine_1_3/#4-le-cas-special-des-tableaux","title":"4. Le Cas Sp\u00e9cial des Tableaux","text":"<p>Les tableaux de style C (<code>int mon_tableau[10];</code>) ont un comportement unique et surprenant pour les d\u00e9butants.</p> <p>Comportement Important</p> <p>Quand vous passez un tableau statique \u00e0 une fonction, il n'est pas copi\u00e9. La fonction re\u00e7oit un acc\u00e8s direct au tableau original. Toute modification faite \u00e0 l'int\u00e9rieur de la fonction affectera le tableau original dans le <code>main</code>.</p>"},{"location":"notes/semaine_1_3/#exemple-avec-un-tableau","title":"Exemple avec un Tableau","text":"<pre><code>#include &lt;iostream&gt;\n\n// M\u00eame sans le '&amp;', la fonction peut modifier le tableau original.\nvoid modifier_premier_element(int tableau[], int taille) {\n    if (taille &gt; 0) {\n        tableau[0] = 999; // Cette modification sera visible dans le main !\n    }\n}\n\nvoid afficher_tableau(const int tableau[], int taille) {\n    for (int i = 0; i &lt; taille; ++i) {\n        std::cout &lt;&lt; tableau[i] &lt;&lt; \" \";\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\nint main() {\n    int mes_notes[5] = {80, 75, 92, 88, 79};\n\n    std::cout &lt;&lt; \"Tableau original : \";\n    afficher_tableau(mes_notes, 5);\n\n    // On appelle la fonction pour modifier le tableau\n    modifier_premier_element(mes_notes, 5);\n\n    std::cout &lt;&lt; \"Tableau apres la modification : \";\n    afficher_tableau(mes_notes, 5); // On affiche \u00e0 nouveau pour voir le changement\n\n    return 0;\n}\n</code></pre>"},{"location":"notes/semaine_1_3/#resultat-du-programme_1","title":"R\u00e9sultat du programme :","text":"<p><pre><code>Tableau original : 80 75 92 88 79 \nTableau apres la modification : 999 75 92 88 79 \n</code></pre> Conclusion : La note <code>80</code> a bien \u00e9t\u00e9 remplac\u00e9e par <code>999</code>. Le passage d'un tableau \u00e0 une fonction se comporte comme un passage par r\u00e9f\u00e9rence, m\u00eame si la syntaxe ne contient pas de <code>&amp;</code>.</p> <p>Nous verrons plus tard dans le cours pourquoi les tableaux ont ce comportement \"sp\u00e9cial\". Pour l'instant, retenez simplement qu'ils sont toujours modifiables par les fonctions qui les re\u00e7oivent.</p>"},{"location":"notes/semaine_1_4/","title":"Guide de Compilation en C++20","text":"<p>Ce document explique comment transformer votre code source (<code>.cpp</code>, <code>.hpp</code>) en un programme ex\u00e9cutable \u00e0 l'aide du compilateur <code>g++</code> et du standard C++20.</p>"},{"location":"notes/semaine_1_4/#1-quest-ce-que-la-compilation","title":"1. Qu'est-ce que la Compilation ?","text":"<p>La compilation est le processus qui traduit votre code C++, lisible par un humain, en code machine, compr\u00e9hensible par l'ordinateur. L'outil qui r\u00e9alise cette traduction est appel\u00e9 un compilateur. Dans ce cours, nous utiliserons <code>g++</code>, le compilateur C++ du projet GNU, l'un des plus populaires.</p> <p></p>"},{"location":"notes/semaine_1_4/#2-la-commande-de-compilation-essentielle","title":"2. La Commande de Compilation Essentielle","text":"<p>Pour compiler, vous ouvrirez un terminal (ou une console) et taperez une commande qui ressemble \u00e0 ceci :</p> <pre><code>g++ [options] -o [nom_executable] [vos_fichiers.cpp]\n</code></pre> <p>D\u00e9taillons chaque partie :</p> <ul> <li><code>g++</code> : C'est l'appel au compilateur lui-m\u00eame.</li> <li><code>[options]</code> : Ce sont des \"drapeaux\" (flags) qui modifient le comportement du compilateur. Les deux plus importants pour nous sont :<ul> <li><code>-std=c++20</code> : C'est le drapeau crucial qui dit \u00e0 <code>g++</code> d'utiliser le standard C++20. Sans cela, les fonctionnalit\u00e9s modernes du langage ne seront pas disponibles.</li> <li><code>-Wall</code> : (Abr\u00e9viation de \"Warnings All\") C'est une option tr\u00e8s fortement recommand\u00e9e qui active presque tous les avertissements (<code>warnings</code>). Le compilateur vous signalera des erreurs potentielles dans votre code, m\u00eame si elles ne l'emp\u00eachent pas de compiler. C'est un filet de s\u00e9curit\u00e9 indispensable.</li> </ul> </li> <li><code>-o [nom_executable]</code> : L'option <code>-o</code> (pour \"output\") vous permet de nommer votre programme final. Si vous l'omettez, le fichier de sortie s'appellera <code>a.out</code> (sur Linux/macOS) ou <code>a.exe</code> (sur Windows).</li> <li><code>[vos_fichiers.cpp]</code> : C'est la liste de tous vos fichiers <code>.cpp</code>, s\u00e9par\u00e9s par des espaces. Vous n'avez pas besoin d'inclure les fichiers <code>.hpp</code>, car ils sont g\u00e9r\u00e9s via les directives <code>#include</code> dans vos fichiers <code>.cpp</code>.</li> </ul>"},{"location":"notes/semaine_1_4/#3-exemples-concrets","title":"3. Exemples Concrets","text":""},{"location":"notes/semaine_1_4/#cas-1-un-projet-avec-un-seul-fichier","title":"Cas 1 : Un Projet avec un Seul Fichier","text":"<p>Imaginons que vous avez un seul fichier <code>main.cpp</code>.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o mon_programme main.cpp\n</code></pre> -   Ceci cr\u00e9era un ex\u00e9cutable nomm\u00e9 <code>mon_programme</code>.</p>"},{"location":"notes/semaine_1_4/#cas-2-un-projet-avec-plusieurs-fichiers","title":"Cas 2 : Un Projet avec Plusieurs Fichiers","text":"<p>Reprenons notre exemple <code>Commande</code>. Nous avons trois fichiers <code>.cpp</code> \u00e0 compiler ensemble.</p> <p>Commande : <pre><code>g++ -std=c++20 -Wall -o exemple main.cpp Commande.cpp ServiceConnexion.cpp\n</code></pre> -   <code>g++</code> va compiler chaque fichier <code>.cpp</code> et les lier (\"link\") ensemble pour cr\u00e9er un seul ex\u00e9cutable nomm\u00e9 <code>exemple</code>.</p>"},{"location":"notes/semaine_1_4/#4-executer-votre-programme","title":"4. Ex\u00e9cuter votre Programme","text":"<p>Une fois la compilation r\u00e9ussie (si la commande ne retourne aucune erreur), un nouveau fichier ex\u00e9cutable appara\u00eetra dans votre dossier.</p> <p>Pour l'ex\u00e9cuter dans le terminal :</p> <ul> <li> <p>Sur Linux ou macOS : <pre><code>./nom_executable \n</code></pre>     (Le <code>./</code> signifie \"dans le dossier actuel\")</p> </li> <li> <p>Sur Windows (cmd ou PowerShell) : <pre><code>.\\nom_executable.exe\n</code></pre></p> </li> </ul>"},{"location":"notes/semaine_1_4/#5-ca-ne-compile-pas-gerer-les-erreurs","title":"5. \"\u00c7a ne compile pas !\" - G\u00e9rer les Erreurs","text":"<p>Il est normal d'avoir des erreurs de compilation. L'art de la programmation est de savoir les lire.</p> <p>Les erreurs les plus courantes au d\u00e9but : -   Oubli d'un point-virgule (<code>;</code>) \u00e0 la fin d'une ligne. -   Faute de frappe dans un nom de variable ou de fonction. -   Accolade (<code>{</code> ou <code>}</code>) manquante. -   Oubli d'inclure un en-t\u00eate (ex: <code>#include &lt;string&gt;</code> pour utiliser <code>std::string</code>).</p> <p>Lisez attentivement les messages d'erreur. <code>g++</code> vous donnera g\u00e9n\u00e9ralement le nom du fichier et le num\u00e9ro de la ligne o\u00f9 l'erreur a \u00e9t\u00e9 d\u00e9tect\u00e9e.</p> <p>Exemple de message d'erreur : <pre><code>main.cpp: In function 'int main()':\nmain.cpp:5:3: error: expected ';' before 'return'\n   return 0;\n   ^~~~~~\n</code></pre> Le compilateur nous dit qu'\u00e0 la ligne 5 du fichier <code>main.cpp</code>, il s'attendait \u00e0 un point-virgule avant le mot-cl\u00e9 <code>return</code>.</p> <p>```</p>"}]}